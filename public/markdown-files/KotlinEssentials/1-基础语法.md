# kotlin基础

> ps: 本页只是对《Kotlin核心编程》第二章内容进行简单概括，kt概览复习请移步到Azuremy的Kotlin 基础.md

##  类型声明

### 类型声明方式

使用 `val`  和 `var` 定义变量，格式为 `变量名`:  `类型名称` = `表达式值`

```kotlin
val a: String = "I am Kotlin"   // 声明一个字符串变量
val int = 1314                  // 支持类型推导

```

声明函数返回值类型时，使用 `fun` 作为关键字，有 `表达式函数体` 和 `代码块函数体`

```kotlin
/* 一般函数定义 (代码块函数体) */
fun sum(x: Int, y: Int) : Int { return x + y }
/* 等号定义函数 （表达式函数体) */
fun sum(x: Int, y: Int) = x + y
```

---

> Tips:  Kotlin不支持`全局类型推导（global type inference）`。 表达式定义函数时，出现诸如递归等复杂状况，必须显示声明类型
>
> ```kotlin
> fun foo(n: Int): Int = if (n == 0) 1 else n * foo (n - 1) // 需显示声明返回类型
> >>> foo(2)
> 2
> ```
>
> 必须添加显示声明类型的三种情况:
>
> - **函数的参数    **
> - **递归函数**
> - **公有方法的返回值**  

---

### val 和 var 的使用规则

`val`和 `var` 都是用于变量声明的关键字，区别在于引用是否可变：

使用 `val`  声明为 `引用不可变` 类型变量，只可赋值一次，效果和Java中 ` final` 关键字定义的变量[^1]。

```kotlin
val <变量名> : <类型> = <初始化值>
```

使用 `var`  声明为 `引用可变` 类型变量，可以被重复赋值[^2]。

```kotlin
var <变量名> : <类型> = <值>
```

### 函数的类型格式 

没有参数的函数类型[^3]：

```kotlin
() -> <返回值类型>
```

只有一个参数的函数类型：

```kotlin
(<参数类型>) -> <返回值类型>
```

拥有参数名称的函数类型：

```kotlin
(<参数名称> : <参数类型>) -> <返回值类型>
```

多个参数的函数类型：

```kotlin
(<参数类型>, ...args) -> <返回值类型>
```

类型可空的函数类型：

```kotlin
(<参数名称> : <参数类型>?) -> <返回值类型>
```

函数类型可选：

```kotlin
((<参数类型>, ...args) -> <返回值类型>)?
```

函数类型的返回值为另一个函数：

```kotlin
(<参数类型>) -> ((<参数类型>) -> <返回值类型>)
```

可以省略后半段的括号，变为：

```kotlin
(<参数类型>) -> <参数类型> -> <返回值类型>
```

类似的，函数类型的参数也可以是一个函数类型：

```kotlin
((<函数类型>) -> <返回值类型>) -> <返回值类型>
```

## 函数

### 方法和成员引用

我们可以通过 `::` 引用某个类的实例对象的方法：

```kotlin
<实例对象> :: <方法名称>
```

也可以引用类的成员变量：

```kotlin
<类名称> :: <成员变量>
```

可以通过`::` 创建构造方法引用变量

```kotlin
::<类名称>
```

### 函数可变参数

Kotlin中通过`varargs` 关键字来定义函数的`可变参数`，且没有`java`中`必须为最后一个参数的限制`

```kotlin
fun printLetters(varargs letters: String, count: Int): Unit {
    print("${count} letter are")
    for (letter in letters) print(letter)
}
>>> printLetters("a", "b", "c", count = 3)   // kotlin可以指定调用的参数的名称
3 letters are abc
```

此外，可以使用 `* `来传入外部变量作为可变参数的变量：

```kotlin
val letters = arrayOf("a", "b", "c")
>>> printLetters(*letters, count = 3)
3 letters are abc
```



### 匿名函数

Kotlin支持在缺省函数名的时候，直接定义一个函数：

```kotlin
fun(<参数名称> : <类型名称>) : Int{
    return 0
}
```

### 高阶函数

`高阶函数`，即`以其他函数作为参数或返回值的函数`[^4], 完整格式如下：

```kotlin
fun (<参数名称> : <函数类型>) : <函数类型>{
    ...
    return <函数表达式>
}
```

### Lambda表达式

`Lambda表达式` 是一种简化表达之后的匿名函数的表达式形式[^5]。

使用`Lambda` 定义一个函数通常的形式是：

```kotlin
val <变量名称> : <函数类型> = {<参数名称> : <参数类型> -> <表达式>}
```

由于支持 `类型推导` ，上述有时[^6]可表示为：

```kotlin
val <变量名称> = {<参数名称> : <参数类型> -> <表达式>}
```

或者：

```kotlin
val <变量名称> : <函数类型> = {<参数类型> -> <表达式>}
```

如果Lambda表达式只有一个函数参数，可以用 `it` [^7]代替，称为 `单个参数的隐式名称` ：

```kotlin
{foo(it)} // 等价于 <参数名称> : <函数类型> -> foo(<参数名称>)
```

<span id="omitParentheses">如果函数只有 `一个 `参数，且该参数为 `函数类型` 的时候，函数调用时，外部的括号可以省略：</span>

````kotlin
fun omitParentheses(block: () -> Unit) {
    block()
}
>>> omitParentheses { println("omitParentheses is omitted...") }
omitParentheses is omitted...
````



### 闭包

在 `kotlin` 中，`闭包` 指 `访问外部环境变量` 的函数。`Lambda` 是kotlin中最常见的闭包形式[^8]：

与 `java` 不同的是，Kotlin的闭包可以 `修改` 访问到的`外部环境变量`：

```kotlin
var sum = 0
listOf(1, 2, 3).filter{ it > 0 }.forEach {
    sum += it
}
>>> println(sum)
6
```

kotlin支出一种`自运行` 的 `Lambda` :

```kotlin
>>> { X : Int -> println(x)} (1)
1
```

### 柯里化

`柯里化` 就是把接收多个参数的函数变换为一系列只接受单一参数函数的过程。

多参数版本的普通加法函数：

```kotlin
fun sum (x: Int, y : Int, z: Int) = x + y + z
>>> sum(1, 2, 3)
6
```

经过`柯里化` 后的版本

````kotlin
fun sum(x: Int) = { y: Int -> 
    { z: Int -> x + y + z}
}
>>> sum(1)(2)(3)
6
````

前面描述过如何<a href="#omitParentheses">省略外部括号</a>[^9]，此外，如果参数不止一个。且最后一个参数为 `函数类型` 时，可以采用 `类柯里化`调用 ：

```kotlin
fun curryingLike(content : String, block: (String) -> Unit) {
    block(content)
}
curryingLike("looks like currying style") {
    content -> 
    println(content)
}
// 运行结果
look like currying style
```

它等价于以下的调用方式：

```kotlin
curryingLike("looks like currying style", {
    content -> 
    println(content)
})
```

### 扩展函数

`扩展函数`允许我们在不修改已有类的前提下，给它增加新的方法：

```kotlin
fun <类名称>.<方法名称>(<参数名称> : <参数类型>) 
```

## 表达式和语句

`语句` 通常是指程序中执行特定操作的指令或命令。

`表达式` [^10 ]是可以返回值的 `语句` ：

`kotlin`  中，其他语言常见的`一般语句`, 也可以当做 `表达式` 来使用。

```kotlin
val res: Int? = try {
    if (result.success) {
        jsonDecode(result.response)
    } else null
} catch (e: JsonDecodeException) {
    null
}
```

### 枚举类

在`kotlin` 中，`枚举` 是通过 `枚举类` 来实现的。

```kotlin
enum class <类名称> (<变量修饰符>? <参数名称> : <参数类型>) {
    <枚举对象1>(<参数名称>),
    <枚举对象2>(<参数名称>)
    ;                    // 如果枚举类存在额外的方法或者属性的定义，必须加上分号";"
    fun <方法名称>() : <参数类型> {
        return day
    }
}
```

### when表达式

`when` 表达式是`kotlin` 新增加的`条件语句表达式` ：

```kotlin
when (<参数名称>) {
    <键> -> <表达式>
    <键> -> {<语句块>}
    else -> <表达式>
}
```

`when` 也可以和`表达式函数` 结合使用，支持`类型推导`，默认为`Unit`：

```kotlin
fun <函数名称>(<参数名称>: <参数类型>) = when (<参数名称>) {
    <键> -> <表达式>
    <键> -> {<语句块>}
    else -> <表达式>
}
```

### 范围表达式

`kotlin` 中存在一种特殊的表示`某个范围内`的值的表达式，可以进行`遍历`、 `查找` 等操作。

关于字符串的范围表达式：

```kotlin
"abc"..'xyz'
```

整数的范围表达式：

```kotlin
1..1O
```

`kotlin`允许我们通过` step` 函数定义步长

```kotlin
>>> for(i in 1..10 step 2) print(i)
13579
```

此外，还可以通过`downTo` 方法实现倒序遍历

```kotlin
>>> for(i in 10 downTo 1 step 2) print(i)
108642
```

可以通过`until` 函数定义`半开区间`[^12 ]

```kotlin
>>> for(i in 1 until 10) print(i)
123456789
```

### in关键字

`in` 关键字可以检查成员关系：

```kotlin
>>> "a" in listOf("b", "c")
false
```

可以加上`!` 进行逻辑取反
```kotlin
>>> "a" in listOf("b", "c")
false
```
`in`可以结合`范围表达式`来判断指定值是否在某个`区间`

```kotlin
>>> "kot" in "abc"..."xyz"
true
```

任何有`迭代器`的结构都可以使用`for/in` 进行迭代

```kotlin
>>> for (c in listOf("a", "b", "c")) print(c)
abc
```

可以通过调用`array` 的 `withIndex` 方法，提供一个`键值`元组：

```kotlin
>>> for ((index, value) in listOf("a", "b", "c").withIndex()) println("$index: $value")
0: a
1: b
2: c
```



### 中缀表达式

在`Kotlin` 中，`中缀表达式（infix expression）`是一种特殊的函数调用语法，允许将函数作为`中缀操作符`来使用。要定义一个`中缀函数`，需要满足以下条件：

- 函数必须是`成员函数`或`扩展函数`。

- 函数必须只有`一个`参数，且不能为`可变参数`。

- 函数必须使用` infix `关键字进行修饰。
- 函数参数不能有`默认值` 。

```kotlin
infix fun <类名称>.<中缀方法>(<参数名称>: <参数类型>) : <返回值类型>
```

调用格式如下：

```kotlin
<类名称> <中缀方法> <参数名称>
```

常见的`中缀表达式`，如`to`，是一个通过`泛型` 实现的中缀方法：

```kotlin
infix fun <A, B> A.to(that: B): Pair<A, B>
```

`to` 的使用方式可能如下，通过`to` 生成`Pair`值对来定义一个`map`字典：

```kotlin
mapOf(
   1 to "one",
   2 to "two",
   3 to "three"
)
```

## 字符串

与`Java` 一样，通过`双引号`来定义字符串，它是`不可变对象`：

```kotlin
val str = "hello world! "
```

下面是`字符串`的一些熟悉的操作：

```kotlin
str.length  // 12
str.substring(0, 5) // hello
str + " hello kotlin!" // hello world! hello kotlin!
```

此外，对`字符串`的遍历：

```kotlin
>>> for(i in str.toUpperCase()) { print(i) }
HELLO WORLD!
```

访问字符串成员：

```kotlin
str[0] //h
str.first() // h
str.last() // !
str[str.length - 1] // !
```

 其他字符串API，请参阅<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/" target=_blank>Kotlin文档</a>。

### 原生字符串

`kotlin` 增加了对`原生字符串` 的支持，最终打印结果和代码呈现的结果一致[^13 ]：

```kotlin
val html = """<html>
                  <body>
                      <p>Hello World.</p>
                  </body>
              </html>
           """
```

### 字符串模板

此外，`kotlin` 还引入了`字符串模板`，支持将 `表达式`植入 `字符串`：

```kotlin
>>> "kotlin has ${if ("koltin".length > 0) "kotlin".length else "no"} letters"
kotlin has 6 letters
```





[^1]: 尽可能使用`val`、`不可变对象`及`纯函数`设计程序。
[^2]: 针对`数据结构`，使用`var`是更加适合的解决方案。
[^3]: 返回值类型即便是`Unit`，也必须显示声明
[^4]: 此话具有分歧，`《JavaScript权威指南》`解释为 “以其他函数作为参数，并返回一个新函数”

[^5]: Lambda表达式是一种 `“语法糖”`
[^6]: 使用`类型推导`的时候请注意不能省略的情况。
[^7]: 作为Lambda的`语法糖`应谨慎使用，避免导致语义不清，降低可读性。
[^8]:  此外，`匿名函数体`、`局部函数`、`object表达式`。访问外部环境变量的函数都可以叫做`闭包`
[^9]: 页面内跳转功能，需导出为`HTML`才可以使用

[^10 ]: `表达式`，可以是一个`值`、`常量`、`变量`、`操作符`、`函数`，或者他们之间的`组合`，`编程语言`对其进行`解释`或`计算`，以求另一个产生的`值`。
[^11 ]: 如`if`、`when`、`fun`、`try` 在Kotlin中也是表达式。
[^12 ]:  指不包括`右边`的值
[^13 ]: `原生字符串` 不会解释`转化转义`字符，以及`Unicode`的转义字符