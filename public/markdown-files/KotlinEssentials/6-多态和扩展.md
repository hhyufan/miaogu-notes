# 多态和扩展

 ## 多态

### 子类型多态

当一个`子类`继承一个`父类`的时候，叫做`子类型多态`。

例如`数据持久化`操作中，继承`Sqlite`操作的相关类：

```kotlin
class CustomerDatabaseHelper(context:Context) : SQLiteOpenHelper(context, "kotlinDemo.db", cursorFactory, db.version) {
    override fun onUpgrade(p0: SQLiteDatabase?, p1: Int, p2: Int) {}
    override fun onCreate(db: SQLiteDatabase) {
        val sql = "CREATE TABLE if not exists StableName { id integer PRIMARY KEY autoincrement, uniqueKey VARCHAR(32)}"
        db.execSQL(sql)
    }
}
```

这样我们可以使用父类` SQLiteOpenHelper`的所有方法，这种用`子类型`替换`超类型`实例的行为，这就是`子类型多态`

### 参数多态

`参数多态`是指`声明与定义` `函数`、 `复合类型`、`变量`时`不指定具体类型`，而把这`部分类型`当做`参数`来使用，最常见的`参数多态`就是`泛型`

```kotlin
interface KeyI {
    val uniqueKey : String
}
class ClassA(override val uniqueKey: String): KeyI {
    ...
}
fun <T: KeyI> persist(t: T) {
    db.save(t.uniqueKey, t)
}
```

这样我们就可以通过一个`方法`来处理`不同参数类型`的`持久化数据`

### 特设多态

`特设多态`是指`多态函数`有多个`不同实现`，依赖于`实参`调用`相应版本`   的函数。

可以通过`接收`一个`接口类型`或者一个带有`函数类型参数`的函数来实现。

```kotlin
interface Animal {
    fun eat()
}

class Dog : Animal {
    override fun eat() {
        println("Dog is eating")
    }
}

class Cat : Animal {
    override fun eat() {
        println("Cat is eating")
    }
}

fun feedAnimal(animal: Animal) {
    animal.eat()
}

fun main() {
    val dog = Dog()
    val cat = Cat()

    feedAnimal(dog) // 输出: Dog is eating
    feedAnimal(cat) // 输出: Cat is eating
}
```

### 运算符重载

`kotlin`支持将`函数`标记为`重载操作符`或`实现约定`，这个标记关键词是`operator`

```kotlin
data class Area(val value: Double)

operator fun Area.plus(that: Area): Area {
    return Area(this.value + that.value)
}
fun main(args: Array<String>) {
    println(Area(1.0) + Area(2.0))
}
```

   这也是一种`特设多态`，通过`运算符重载`我们可以优雅实现业务需求                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

## 扩展

### 开放封闭原则

`开放封闭原则（OCP，Open Closed Principle）`，即：软件实体应该是`可扩展的`，而`不可修改的`。对`扩展开放`，对`修改封闭`

`开闭原则`是所有`面向对象原则`[^1 ]的`核心`，软件设计追求`封装变化`、`降低耦合`，`开闭原则`是这一目标的`直接体现`。

### 扩展函数的声明

`kotlin`中扩展函数的前缀是一个`接收者类型（recievier type）`(通常是类或接口的名称)

声明格式如下：

```kotlin
fun <类名称>.<扩展方法>(<参数列表>) 
```

我们为`MutableList<Int>`扩展一个叫做`exchange`的方法。，它看起来像这样的：

```kotlin
fun MUtableList<Int>.exchange(fromIndex: Int, toIndex: Int) {
    val tmp = this[fromIndex]
    this[fromIndex] = this[toIndex]
    this[toIndex] = tmp
}
```

`kotlin`的`扩展函数体`中的`this`关键字指代的是`接收者类型的对象`。

需要注意的是，如果你的`函数`是`可空的`，那么需要`重写`一个`可空类型`的`扩展函数`。

### 扩展函数的作用域

- 在类的`外部`， 扩展函数在`同一个包内`可以被直接调用，不同包内，使用`import`相应方法即可
- 在一个`Class内部 `时
  - 使用` public`或`默认`修饰，只能在`该类`或者`该类的子类`中`调用`。 
  - 使用` private` 修饰，在`子类`中也不能访问`扩展函数`。

### 扩展函数的优先级

`成员方法`优先级总`高于` `扩展函数`

```kotlin
class MyClass {
    fun greet() {
        println("Hello from member function")
    }
}

fun MyClass.greet() {
    println("Hello from extension function")
}

fun main() {
    val obj = MyClass()
    obj.greet() // 输出: Hello from member function
}
```

### 扩展this指向

`扩展函数`的`this`指代的是`接收者类型的实例对象`，但当我们在`object内部`如何获取`类的实例`呢

可以使用`this@` `强制`指定调用的`this`

```kotlin
class MyClass (val name : String){
    fun greet() {
        println("Hello $name(called by MyClass)")
    }
}
object MySingleton {

    private fun greet(name: String) {
        println("Hello $name(called by MySingleton)")
    }

    @JvmStatic
    fun main() {
        fun MyClass.sayHello() {
            // 在这里使用 "this@" 强制指定类的实例对象
            this@MySingleton.greet(this.name)
        }
        MyClass("Azuremy").sayHello()
    }
}

fun main() {
    MySingleton.main()                 // Hello Azuremy(called by MySingleton)
    println( MyClass("YuFan").greet()) // Hello YuFan(called by MyClass)
}
```

### 标准库中的扩展函数

- **run**

  `run`是任意类型`T`的通用扩展函数，定义如下：
  
  ```kotlin
  public inline fun <T, R> T.run(block:T.() -> R): R = block()
  ```
  
  `run`中执行了`返回类型`为`R`的`扩展函数`，并`返回`了`扩展函数`的`执行结果`
  
  ```kotlin
  run {
      if (!islogin) loginDialog else getNewAccountDialog
  }.show()
  ```
  
  `run`函数拥有一个单独的作用域，由于是`扩展函数`，可以`不依赖` `前缀`直接使用
  
- let

  `let`定义如下：

  ```kotlin
  public inline fun<T, R> T.let(block: (T) -> R): R = block(this)
  ```

  `let`返回`闭包`的`值`，并`限制`了`变量作用域`

  ```kotlin
  data class Student(age: Int)
  class Kot {
      val student : Student? = getStu()
      fun dealStu() {
          val result = student?.let {
              println(it.age)
              it.age
          }
      }
  }
  ```
  
- also

  `also`定义如下：

  ```kotlin
  public inline fun<T> T.also(block: (T) -> Unit): T {block(this); return this }
  ```

  与`apply`一致，返回`函数接收者`

  ```kotlin
  class Kot {
      val student: Student? = getStu()
      var age = 0
      fun dealStu() {
          val result = Student?.also { stu ->
              this.age += stu.age
              println(this.age)
              println(stu.age)
              this.age
          }
      }
  }
  ```

  如果是`apply`，由于内部是一个`接收者类型`的函数，所以`this`指向`stu`而不是`Kot`。
  
- takeIf

  `takeIf`定义如下：

  ```kotlin
  public inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? = if (predicate(this)) this else null
  ```

  当`接收器` 满足`某种条件`才会`继续执行`：

  ```kotlin
  val result = Student.takeIf {it.age >= 18}.let {...}
  ```

  与`takeIf`相反的还有`takeUnless`，`不满足条件`才会`执行`


## 调度

### 静态调度

`静态调度`，即`编译器` 选择`编译时`的类型来`静态地`决定调用哪个`子类`的方法。

```kotlin
open class Base

class Extended : Base()

fun foo(base: Base) {
    // ...
}

fun foo(extended: Extended) {
    // ...
}

fun main() {
    val base: Base = Extended()
    foo(base)
}
```
即使`本质上`，`base`仍然是`Extended`的实例，但最终还是会执行`Base`的方法。
### 动态调度

`动态调度`，即调度的类型取决于`运行时类型`的方法：

```kotlin
open class Animal {
    open fun makeSound() {
        println("动物发出了声音")
    }
}

class Dog : Animal() {
    override fun makeSound() {
        println("汪汪汪")
    }
}

class Cat : Animal() {
    override fun makeSound() {
        println("喵喵喵")
    }
}

fun main() {
    val animal1: Animal = Dog()
    val animal2: Animal = Cat()

    animal1.makeSound()  // 输出：汪汪汪
    animal2.makeSound()  // 输出：喵喵喵
}
```

例如我们对`父类`进行`重写时`，进行的就是`动态调度`

### 调度接收器和扩展接收器

`kotlin`中，`扩展函数`存在着两种接收器，`调度接收器`和`扩展接收器`：

- `扩展接收器（extension receiver）`：表示为其`定义扩展`的`对象`
- `调度接收器（dispatch receiver）：`扩展被声明为`成员`时存在的`特殊接收器`，表示`声明扩展名`的类的`实例`

### 扩展始终静态调度

`扩展函数`都具有一个`接收器(receiver)`，是`字节代码`中`编译方法`的`参数`，因此可以进行`重载`而无法`覆盖`

所以`扩展函数`始终是`静态调度`的：

```kotlin
open class Base
class Extended: Base()
fun Base.foo() = "I am Base.foo!"
fun Extended.foo() = "I am Extended.foo!"
fun main(args: Array<String>) {
    val instance: Base = Extended()
    val instance2 = Extended()
    println(instance.foo())    // I am Base.foo!
    println(instance2.foo())   // I am Extended.foo!
}
```

如果在`类`的内部声明`扩展函数`并加上`open`关键字，我们可以在`子类`中`重写`

此时，`扩展函数`同时具有`扩展接收器`和`调度接收器`

`扩展接收器`是`编译时解析`，而`调度接收器`只能是`动态`

```kotlin
open class Base
class Extended: Base()
open class X {
    open fun Base.foo() {
        println("I am Base.foo in X")
    }
    open fun Extended.foo() {
        println("I am Extended.foo in X")
    }
    fun deal(base: Base) {
        base.foo()
    }
}

class Y: X() {
    open fun Base.foo() {
        println("I am Base.foo in Y")
    }
    open fun Extended.foo() {
        println("I am Extended.foo in Y")
    }
}
X().deal(Base())     // 输出 I am Base.foo in X
Y().deal(Base())     // 输出 I am Base.foo in Y - 调度接收器被动态处理
X().deal(Extended()) //  输出 I am Base.foo in X - 扩展接收器被静态处理
Y().deal(Extended()) //  输出 I am Base.foo in Y
```

`Extended`方法始终没有`被调用`，因为决定`Base`类`扩展函数`执行哪一个，直接因素是`deal`方法的`运行时类型`

>扩展函数需要注意的地方：
>
>- 如果扩展函数是`顶级函数`或者`成员函数`，则`无法被覆盖`
>- 无法访问`接收器`的`非公共属性`
>- `扩展接收器`始终是`静态调度`的

### 正确使用扩展函数

扩展函数固然方便，在`新特性`面前，我们不能过于`喜新厌旧`，应结合`面向对象思想`和`设计模式`来规范。

[^1 ]: 面向对象原则还包括`单一责任原则（SRP）`、`里氏替换原则（LSP）`、  `依赖倒置原则（DIP）`、`接口隔离原则（ISP）`等等..
