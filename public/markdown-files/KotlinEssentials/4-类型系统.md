# 类型系统

## 可空类型

在`Java`中，处理`NPE（NULLPointerException）`问题，可能会用`Optional<T>`来处理。

但是`kotlin`里，引入了`可空类型`的语法，来更好的解决`NPE`问题。

```kotlin
<Object>?  // 等同于Object or not
```

### ?.调用

`kotlin`中，我们可以使用`?.`对`左操作数`进行判断。

```kotlin
<标识符>?.<属性名称>
```

如果左操作数`存在`，则调用`右操作符`。否则`中断调用`

```kotlin
// student存在，才会调用下面的glasses。
println("该位置上学生的眼镜度数: ${s.student?.glasses?.degreeOfMyopia}")
```

### Elvis操作符?:

kotlin的`?:`不是`三元条件运算符`，而是判断类型安全的`合并运算符`[^1 ]版本。

```kotlin
<标识符>?:<值>
```

当`左操作数`不存在，则使用`右操作数`作为默认值。

```kotlin
val result = student.glasses?.degreeOfMyopia?:-1
```

### 非空断言

kotlin提供一种非空断言操作符`!!`，来确保在`测试过程`中确保`变量`不为空[^2 ]：

```kotlin
<标识符>!!.<属性名称>
```

当`左操作数`为空的时候，将会产生`NPE异常`。

### 用Either代替可空类型

我们可以使用`Elvis操作符`如果需要让程序`抛出异常`：

```kotlin
seat?.student?.glasses?.degreeOfMyopia ?: throw NULLPointerException("some reasome")
```

当然可以使用类似`Scala`中的`Either类`替代[^3 ]。

`kotlin`中没有`Either类`，但是我们可以通过`密封类`轻松创建：

```kotlin
sealed class Either<A, B>() {
    class Left<A, B>(val value: A): Either<A, B>()
    class Right<A, B>(val value: A): Either<A, B>()
}
```

下面是使用`Either类`的改造：

```kotlin
fun getDegreeOfMyopiaKt(seat: Seat?): Either<Error, Double> {
    return seat?.student?.glasses?.let {
        Either.Right<Error, Double>(it.degreeOfMyopia)
    } ?: Either.Left<Error, Double>(Error(code=-1))
}
```

---

> **let函数**：
>
> ```kotlin
> public inline fun<T, R> T.let(block: (T) -> R): R = block(this)
> ```
>
> 调用某对象的`let`函数，该对象会作为函数的`参数`，在`函数块`内可以通过`it`指代该对象，返回值为`函数块最后一行`或`指定return表达式`

---

### 类型检查

在`kotlin`中，我们使用`is`来判断`类型`：

```kotlin
when(obj) {
    is String -> print(obj.length)
    ! is String -> print("not a String")
}
```

    ### 智能类型转换

`智能类型转换（smart Casts）`可以`隐式`完成两种类型的转化：

```kotlin
val stu: Any = Student(Glasses(1898.00))
if (stu is Student) println(stu.glasses)
if (stu.glasses != null) println(stu.glasses.degreeOfMyopia)
```

当且仅当`kotlin`的`编译器`定在`类型检查`后发现该变量`不会改变`时，才会进行`智能类型转换`：

利用这点，我们能确保`多线程`应用足够安全：

```kotlin
class Kot {
    var stu: Student? = getStu()
    fun dealStu() {
        if (stu != null) {
            print(stu.glasses)
        }
    }
}
```

上面使用了`var`，意味着进行条件判断之后，stu在`其他线程`中还会被修改，所以被编译器`拒绝`了。

可以用`val`和`let`对上述代码进行修改，确保此类问题不会发生：

```kotlin
class Kot {
    val stu: Student? = getStu()
    fun dealStu() {
        stu?.let {print(it.glasses)}
    }
}
```

在类的`继承`中，将`父类型`转换成`子类型`时，无法进行`smart Casts`

可以使用`as`操作符实现`强制转换`： 

```kotlin
val teacher = getTeacher() as Teacher
print(teacher.name)
```
 如果 `getTeacher`方法实现为`可空类型`，如`fun getTeacher(): Human?`，则会抛出`类型转换错误`异常：

```kotlin
kotlin.TypeCastException: null cannot be cast to non-null type Teacher
```

`kotlin`提供了一种`安全的`类型转换，我们可以在`as`关键字后面加上`?`，变成`as?`来允许可空类型的转换，返回转换结果`null`

```kotlin
val teacher = getTeacher() as? Teacher
if (teacher !== null) {
    print(teacher.name)
}
```

某些业务需要`频繁`进行`类型转换`，配合泛型封装一个`更有效`的`类型转换方法`：

```kotlin
inline fun <reified T> cast(original: Any): T? = oroginal as T
```

## 更面向对象的`Kotlin`

### Any和Any?

- `Any` 是所有`非空类型`的`根类型`
- `Any?`是`Any`类型的`父类型`，是`所有类型`的`根类型`
- 根据`集合关系`，`Any??`等价于`Any?`

### Nothing 和 Nothing?

- `Nothing`是没有`实例`的类型，是`kotlin的`类型层次`的`最底层`。
- `Nothing?`是`Nothing`的`父类型`。只能包含一个值，就是`null`

### 自动装箱和拆箱

`kotlin`中并没有`int`、`float`、`double`、`long`这样的原始类型，而拥有对应的`引用类型包装类`：`Int`、`Float`、`Double`、`Long`

在` Kotlin` 中，`自动装箱和拆箱`[^4 ]是由编译器`自动完成`的，但是和`Java`有所不同：

- `Kotlin`中的`Int`等同于`int`
- `Kotlin`中的`Int?`等同于`Integer`

### 数组类型

 `kotlin`中的`Array`不是原生的`数据结构`，而是`Array类`：

```kotlin
val funList = arrayOf(n1, n2, n3, n4)
```

也可以为其指定类型：

```kotlin
val funList = arrayOf<T>(n1, n2, n3, n4)
```

`kotlin`为`原始类型引用`提供了一些`实用类`：`IntArray`、`CharArray`、`ShortArray`

```kotlin
val xArray = intArrayOf(1, 2, 3)
```

由于`kotlin`对`原始类型`有`特殊优化`（主要体现避免`自动装箱`的`开销`），建议优先使用`原始类型数组`。

## 泛型

和`Java`一样，`kotlin`使用`<>`来表示泛型。

例如我们给`ArrayList`扩展一个`find`泛型方法:

```kotlin
fun <T> ArrayList<T>.find(t: T): T? {
    val index = this.indexOf(t)
    return if (index >= 0) this.get(index) else null
}
fun main(args: Array<String>) {
    val arrayList = ArrayList<String>()
    arrayList.add("one")
    println(arrayList.find("one")) // => one
    println(arrayList.find("two").isNullOrEmpty()) // => true
}
```

### 类型约束：设定类型上界

我们可以使用如下语法，来对传入的类型参数进行约束：

```kotlin
class <类名称><T: <类型上界>>(<类参数>)
```

例如：

```kotlin
class FruitPlate<T: Fruit?>(val t: T)
```

这里只允许`Fruit?`类及其`子类`（包括`Fruit类`及其子类）的传入。

如果定义多个条件的约束，可以通过增加`where`来实现：

```kotlin
interface Ground {}

open class Fruit(val weight: Double)

class Apple(weight: Double): Fruit(weight)

class Watermelon(weight: Double): Fruit(weight), Ground

fun <T> cut(t: T) where T: Fruit, T: Ground {
    print("You can cut me!")
}

cut(Watermelon(3.0)) // 允许
cut(Apple(2.0)) // 不允许
```

### 泛型数组

在`Java`中由于数组是`协变`[^5 ]的。如果给`数组`加入`泛型`。无法满足`数组协变原则`，所以无法`声明泛型数组`

`kotlin`中，数组是`不协变`的，意味着无法将`对象数组`赋值給`Array<Any>`或`Array<Any?>`

```kotlin
val appleArray = arrayOfNulls<Apple>(3)
val anyArray: Array<Any?> = appleArray // 不允许
```

但是由于`泛型机制`的相同，和`java`一样，在`运行时`无法获取`数组类型`：

```kotlin
val appleList = ArrayList<Apple>()
println(appleList.javaClass)  // 无法获取
```



### 类型擦除

受限于`向后兼容`，无论是`Java`还是`kotlin`，`泛型`是通过`类型擦除`实现的。即通过编译时加入`强制类型转换`来实现的。

我们可以`主动指定参数类型`来达到`运行时`获取`泛型参数类型`的效果：

```kotlin
open class Plate<T>(val t: T, val clazz: Class<T>) {
    fun getType() {
        println(clazz)
    }
}

val applePlate = Plate(Apple(1.0), Apple::class.java)

applePlate.getType()
//>>>
class Apple
```

但无法获取`泛型的类型`，如`ArrayList<String>::class.java`

但可以使用`匿名类`来获取各种`类型信息`：

```kotlin
val list1 = ArrayList<String>()
val list2 = object : ArrayList<String>()() // 匿名内部类
println(list1.javaClass.genericSuperclass)
println(list2.javaClass.genericSuperclass)
//>>>
java.util.AbstractList<E>
java.util.ArrayList<java.lang.String>
```

因为`泛型类型擦除`会把类型信息放入对应的class的`常量池`，所以可以通过`相应方式`获取`类型信息`

我们可以设计一个获取`所有类型信息`的`泛型类`：

```kotlin
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type

open class GenericsToken<T> { 
    var type: Type = Any::class.java
    init {
        val superClass = this.javaClass.genericSuperclass
        type = (superClass as ParameterizedType).getActualTypeArguments()[0]
    }
}
fun main(args: Array<String>) {
    val gt = object : GenercsToken<Map<String, String>>()()
    println(gt.type)
}
//>>>
java.util.Map<Java.lang.String, ? extends java.lang.String>
```

### 使用内联函数获取泛型

使用`内联函数`获取`泛型的参数类型`十分简单。在泛型前面加入`reified`关键字即可[^6 ]。

```kotlin
inline fun <reified T> getType() {
    return T::Class.java
}
```

我们现在可以在`kotlin`中改进`Gson`的使用方法：

```kotlin
inline fun<reified T: Any> Gson.fromJson(json: String): T {
    return Gson().fromJson(json, T::class.java)
}
// 使用
val json = ...

val stringList = Gson().fromJson<List<String>>(json)
```

### 协变的List

在`Java`中，`数组`是`协变`的，`List`是`不变`的。

而在`kotlin`中，`数组`是`不协变`的，List是`协变`的。

我们根据两种语言`List`实现来对比，会发现不同的原因：

```java
public interface List<E> extends Collection<E>
```

```kotlin
public interface List<out E> : Collection<E>
```

`kotlin`在List`定义`前加了一个`out`关键字，说明这个泛型类及其泛型方法是`协变`

`协变`意味着`List`无法`添加元素`，只能`读取内容`。

所以`List`没有定义`add`、`remove`、`replace`方法。

---

>Tip：在`默认情况`下，若泛型类支持`协变`，其方法的参数类型不能写`T`类型，因为`方法参数`不允许传入`参数父类型的对象`，但我们可以使用`@UnsafeVariance`解除这个限制。
---

### 逆变的Comparator

我们可以使用`sortWith`方法，根据我们定义的Comparator比较器来进行排序

```kotlin
val doubleComparator = Comparator<Double> {
        a1, a2 -> a1.compareTo(a2)
}

val doubleList = mutableListOf(2.0, 3.0)
doubleList.sortWith(doubleComparator)
print(doubleList)  // [2.0, 3.0]


val numberComparator = Comparator<Number> {
        a1, a2 -> a1.toDouble().compareTo(a2.toDouble())
}

val intList = mutableListOf(3, 2)
intList.sortWith(numberComparator)
print(intList)    // [2, 3]
```

`sortWith`既可以接受`Comparator<Double>`，也可以接受`Comparator<Number>`。下面是`sortWith`的实现：

```kotlin
public fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {
    if (size > 1) java.util.Collection.sort(this, comparator)
}
```

`Comparator<in T>`中的`in T`就是`逆变`[^7 ]，所以我们可以将` numberComparator`作为`doubleComparator`来使用。

我们可以通过`<in T>`声明一个`WriteableList列表`：

```kotlin
interface WriteableList<in T> {
    fun get(index: Int): T // Type parameter T is declared as 'in' but occurs in 'out' position in type T
    fun get(index: Int): Any // 允许
    fun add(t: T): Int // 允许
}
```

可以看出，`WriteableList`是`允许写入`，但`读取`功能`受限`（只能为`Any类型`）的列表。这就是`in T` `逆变`的特性

###  型变

`协变`和`逆变`统称为`型变`，与`不变`对立。

下面是`协变`、`逆变`、`不变`三者的比较：

||协变|逆变|不变|
|:-:|-|-|-|
|Kotlin|`<out T>`, 只能作为消费者，只能读取不能添加|`<in T>`, 只能作为生产者，只能添加，读取受限|`<T>`, 既可以添加又可以读取|
|Java|`<? extends T>`, 只能作为消费者，只能读取不能添加|`<? super T>`, 只能作为生产者，只能添加，读取受限|`<T>`, 既可以添加又可以读取|

### 类型通配符

如果你对`泛型参数的类型`不感兴趣，可以使用`类型通配符*`来替代：

```kotlin
val <变量名称>: <类型名称><*>
```

其实`*`是一种`语法糖`，在工作原理上，类似于`<out Any?>`，所以是`协变`的

所以下面代码用来给`列表添加元素`，是不被允许的：

```kotlin
val list: MutableList<*> = mutableListOf(1, "kotlin")
list.add(2.0) // 出错
```




[^1 ]:  `Javascript`中也存在类似的`操作符`，是`??` `空值合并/先定义 `运算符。
[^2 ]: 除此之外，还有`!is`，`as?`等运算符，也可以进行断言。
[^3 ]: Either只有`left`和`right`两个子类型，Either类型是一种`和类型`。

[^4 ]:   `自动装箱`，`基本类型`自动转为`包装类`。`自动拆箱`，`包装类`自动转为`基本类型`
[^5]: `协变（Covariance）`是指可以使用`子类类型`作为`父类类型`的一种特性。如果泛型类 `G` 的类型参数 `T` 是协变的，如果 `S` 是 `T` 的子类型，那么 `G<S>` 就是 `G<T>` 的`子类型`。
[^6]:  编译时，带有`reified`的`内联函数`会将具体的`类型`插入到相应`字节码`中。这样我们在`运行时`就可以获取`参数类型`了
[^7 ]: `逆变（Contravariance）`与`协变`相对应，如果`S`是`T`的子类型，那么`G<T>`反过来是`G<S>`的`子类型`。

