# 面向对象

## 类和构造方法

### kotlin中的类

`对象` 是由状态和行为组成的，我们可以通过他描述`一个`事物。

`类` 是用来描述具有相似特征和行为的`一组对象`的`集合` 

```kotlin
class <类名称> {
    <修饰符> <成员名称>: <类型> = <值>
    fun <方法>
    ...
}
```

例如一个`Bird` 类：

```kotlin
class Bird {
    val weight: Double = 500.00
    val color: String = "blue"
    val age: Int = 1
    fun fly() {}    // 全局可见
}
```

---

>可以看出，`kotlin` 中的 `类` 声明语法非常近似 `Java` ，但也存在很多不同：
>
>- **不可变属性成员**。`kotlin`使用 `val`  声明引用不可变的属性成员而不是 `final`，使用`var` 定义引用可变。
>- **属性默认值**。`kotlin`除非显示地声明`延迟初始化`，否则就需要指定`属性默认值` 。
>- **不同的可访问修饰符**。`kotlin` 中类的成员默认是 `全局可见`。而`Java` 默认是`包作用域`。 

---

### Kotlin中的接口

在` Kotlin `中，`接口（Interfaces）`用于定义`一组`相关方法的`集合`

这些方法只有声明而没有具体的实现。接口提供了一种`约定`，告诉`类`应该实现哪些方法。

```kotlin
interface <接口名称> {
    <修饰符> <成员名称>: <类型> 
    fun <方法>
    ...
}
```

例如一个`Flyer`接口，支持接口方法的`默认实现`：

```kotlin
interface Flyer {
    val speed： Int
    fun Kind()
    fun fly() {
        println("I can fly! ")
    }
}
```

`kotlin`接口的属性声明是通过`get`方法实现的，要想给接口的属性默认的值，需要使用`get`方法，就像这样：

```kotlin
interface Flyer {
    val height
        get() = 1000
}
```

### 构造类的对象

`kotlin`中没有`new`关键字，而是有更直接的语法构造类的实例对象：

```kotlin
val bird = Bird()
```

koltin使用`构造方法默认参数`来解决不必要的`方法重载`：

```kotlin
class <类名称>(<修饰符> <参数名称>: <参数类型> = <默认值>) // 可以省略{}
```

使用这个，来改写`Bird`类：

```kotlin
class Bird(val weight: Double = 0.00, val age: Int = 0，, val color: String = "blue")
```

由于`参数默认值` 的存在，创建一个类的`实例对象`的时候，最好指定`参数名称` ，否则必须按照实际参数的顺序进行赋值：

```kotlin
val bird1 = Bird(weight = 1000.00, color = "black")
val bird2 = Bird(1000.00, 1, "black")
val bird3 = Bird(1000.00, "black")  // error
```

`构造方法`的`参数名`可以不加上`var` 和 `val`[^1 ]，一下是 `Bird` 类的`构造参数`不带 `引用可变修饰符`的实现：

```kotlin
class Bird(
        weight: Double = 0.00, // 参数名前没有val
        age: Int = 0,
        color: String = "blue") {
    val weight: Double
    val age: Int
    val color: String
    
    init {
        this.weight = weight
        this.age = age
        this.color = color
    }
}
```

### init语句块

`init句块` 允许我们在`初始化`构造函数的时候进行一些`额外操作`。

```kotlin
class Bird(weight: Double , age: Int , color: String) {
    init {
        print("the weight is ${weight}")
    }
}
```

构造方法的参数可以在`init`语句块中直接被调用，

`初始化类内部成员`也可以使用`构造方法的参数`。

```kotlin
class Bird(
        weight: Double = 0.00, 
        age: Int = 0,
        color: String = "blue") {
    val weight: Double = weight
    val age: Int = age
    val color: String = color
}
```

此外，构造方法可以同时拥有多个init，会在对象被创建时，按照类`从上到下`先后执行[^2 ]。

### 延迟初始化：by lazy 和lateinit

在一些情况，我们不希望属性成员在`类的初始化`的时候就拥有值[^3 ]：

所以可以使用`延迟初始化`，可以通过`by lazy`来修饰`延迟初始化`的成员：

```kotlin
class Bird(val weight: Double, val age: Int, val color: String) {
    val sex: String by lazy {
        if (color == "yellow") "male" else "female"
    }
}
```

`by lazy`语法特点如下：

- 该变量必须是`引用不可变`的，不能通过`var`修饰。
- `首次调用`可以被赋值操作，一但被`赋值`无法修改。

---

>关于 `by lazy`语法的补充交代：
>
>- `lazy` 的背后是接受了一个`lambda` 并返回一个`Lazy<T>`实例的函数。第一次访问该属性时，会执行`lazy`对应的`Lambda`表达式并记录结果，后续访问该属性只是返回记录的结果。
>- 系统会给`lazy`上一个`同步锁`，也就是`LazyThreadSafetyMode.SYNCHRONIZED`，同一刻只允许一个线程对`lazy`属性初始化，保证`线程安全性`。如果给`lazy`传递`LazyThreadSafetyMode.NONE`参数，将不会有任何线程方面的`开销`及`保证`：
>```kotlin
>val sex: String by lazy(LazyThreadSafetyMode.PUBLICATION) {
>    // 并行模式
>    if (color == "yello") "male" else "female"
>}
>val sex: String by lazy(LazyThreadSafetyMode.NONE) {
>    // 不会有任何线程保证，也不会有任何线程开销。
>    if (color == "yello") "male" else "female"
>}
---

`lateinit` 主要用于`var` 声明的变量，但不能用于`基本数据类型`[^4 ]的变量：

然而可以使用`包装类`来替代。

```kotlin
class Bird(val weight: Double, val age: Int, val color: String) {
    lateinit val sex: String  // sex 可以延迟初始化
    
    fun printSex() {
        this.sex = if (this.color == "yellow") "male" else "female"
        println(this.sex)
    }
}
```

### 主从构造方法

`kotlin`每个类存在`一个` `主构造方法`和`多个` `从构造方法`。

在类的外部定义的`构造参数`，称为`主构造方法`。

用`constructor`构造方法构造类的对象，称为`从构造方法`。

```kotlin
constructor(<构造参数>: <参数类型>): this(<委托方法>) {...}
```

如果类存在`主构造方法`，那么每个`从构造方法`都要直接或者间接`委托`给它：

```kotlin
import org.joda.time.DataTime
import org.joda.time.Years
class Bird(age: Int) {
    val age: Int 
    init {this.age = age}
    constructor(timestamp: Long): this(DataTime(timestamp))  // 从构造方法A, 委托给从构造方法B
    constructor(birth: DateTime): this(getAgeByBirth(birth)) // 从构造方法B，委托给主构造方法。
    fun getAgeByBirth(birth: DateTime): Int {
        return Years.yearsBetween(birth, DateTime.now()).years
    }
}
```

## 访问控制原则

### 限制修饰符

`限制修饰符` 是为一个`类`、`方法`、`属性`指定`修改`或`重写`权限的。

`open` 允许一个类被继承[^5 ]：

```kotlin
open class Bird {
    open fun fly() {
        println("I can fly.")
    }
}
class Penguin: Bird {
    override fun fly() {
        println("I can't fly actually.")
    }
}
```

---

> 实际开发中，我们应该遵循`里氏替换原则`[^6 ]来确保继承关系的合理性：
>
> - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；
> - 子类可以增加自己特有的方法；
> - 当子类的方法实现父类的方法时，方法的前置条件（即方法的形参）要比父类的输入参数更宽松。
> - 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

---

`final` 是类的默认修饰符，即不允许类被`继承`或者`重写`。

`abstract`和 `java` 一致，用于定义`抽象类`或`抽象方法`。

### 可见性修饰符

- `kotlin`中，默认的`可见性修饰符` 是`public`。而`Java`是`default`

- `kotlin`使用`internal`修饰符来保证`模块内可见` [^7 ]，而没有`Java`中的`default`表示`包内访问`
- `kotlin`中，`private`可以修饰`类`来限制其`本文件可见`。`类内修饰`则只有`本类可见`

## 多继承

### 接口实现多继承

在`kotlin`中，可以通过一个`类`实现多个`接口`来实现多继承：

```kotlin
interface Flyer {
    fun fly()
    fun kind() = "[Flyer] flying animals"
}
interface Animal {
    val name: String
    fun fly()
    fun kind() = "[Animal] flying animals"
}
class Bird(override val name: String) : Flyer, Animal {
    override fun eat() {
        println("I can eat! ")
    }
    override fun fly() {
        println("I can fly! ")
    }
    override fun kind() = super<Flyer>.kind()
}
fun main(args: Array<String>) {
    val bird = Bird("sparrow")
    println(bird.kind())
}
// 运行结果
[Flyer] flying animals
```

`super`关键字用来指定`父类方法`，或者继承哪个`父接口方法`。

---

> 接口实现多继承时：
>
> - 实现`接口`时，需要实现接口中没有`默认实现`的方法及`未初始化`的属性。
> - 同时实现`多个`接口，接口又出现`相同方法名`的默认实现时，需要用`super<T>` `主动`指出使用哪个`接口方法`或者`重写方法`。
> - 实现接口的`属性`和`方法`时，必须带上`override`，不能省略。

---

### 内部类实现多继承

在`kotlin`中，在`类`中定义一个以`inner`作为修饰符的类，则为`内部类`：

没有`inner`修饰符的`类中类`则为`嵌套类`，类似与`Java`中的`静态内部类`[^8 ]。

`内部类`可以通过`继承`外部其他的`类`来实现`多继承`：

```kotlin
open class Horse {
    fun runFast() {
        println("I can run fast! ")
    }
}
open class Donkey {
    fun doLongTimeThing() {
        println("I can do some thing long time! ")
    }
}
class Mule {
    fun runFast() {
        HorseC().runFast()
    }
    fun doLongTimeThing() {
        DonkeyC().doLongTimeThing()
    }
    
    private inner class HorseC : Horse()
    private inner class DonkeyC : Donkey()
}
```

### 委托代替多继承

`kotlin`中，`委托`作为直观语法出现，我们可以使用`by`关键字来实现`属性`或`方法`的`委托`：

例如使用 `Delegates.notNull()` 方法来创建`属性委托`，该方法会在属性`被访问时`检查是否已经被`赋值`，如果没有则`抛出异常`：

```kotlin
import kotlin.properties.Delegates

class Example {
    var name: String by Delegates.notNull()
}

fun main() {
    val example = Example()
    // 尝试访问属性 name，会抛出异常，因为它还没有被赋值
    println(example.name)
    
    // 为属性 name 赋值
    example.name = "Alice"
    
    // 再次访问属性 name，这次不会抛出异常
    println(example.name)
}
```

`kotlin`的`by`委托可以做一些意想不到的事情，下面是将`类属性`委托给 `Map`的`key`的例子：

```kotlin
class User(val map: Map<String, Any?>) {
  val name: String by map
  val age: Int by map
  val email: String by map
}

fun main() {
  val userMap = mapOf(
    "name" to "John Smith",
    "age" to 30,
    "email" to "john.smith@example.com"
  )
  val user = User(userMap)

  println(user.name) // 输出 John Smith
  println(user.age) // 输出 30
  println(user.email) // 输出 john.smith@example.com

  // 尝试访问不存在的属性
  println(userMap["address"]) // 输出 null
}
```

下面是`方法委托`实现多继承的例子：

```kotlin
interface CanFly {
    fun fly()
}

interface CanEat {
    fun eat()
}

open class Flyer2 : CanFly {
    override fun fly() {
        println("I can fly")
    }
}
open class Animal2 : CanEat {
    override fun eat() {
        println("I can Eat")
    }


}
class Bird2(flyer: Flyer2, animal: Animal2) : CanFly by flyer, CanEat by animal
fun main() {
    val flyer = Flyer2()
    val animal = Animal2()
    val b = Bird2(flyer, animal)
    b.fly()
    b.eat()
}
```

## 数据类

`data class` 是 `kotlin`中的`数据类`，类似于`Java`中的`record`记录[^9 ]：

```kotlin
data class <类名称> (<主构造方法>)
```

`data class`可以通过我们传入的`参数属性`，自动生成`getter/setter`、`equals`、`hashcode`、`构造函数`、`copy`、`componentN`等方法。

我们可以通过`data class` 来避免很多繁琐的`JavaBean`的书写：

例如，我们改写`Bird`类：

```kotlin
data class Bird(var weight: Double, var age: Int, var color: String)

val bird1 = Bird(13.00, 3, "blue")
val bird2 = Bird(13.00, 3, "black")

>>> bird1.color          // get方法，获取bird1的颜色
blue
>>> bird2.hashCode()     // 获取bird2的hashCode
-482242468
>>> bird1.equals(bird2)  // 比较bird1和bird2
false
>>> bird1 == bird2       // 甚至可以直接用"=="比较
false
bird2.color = "blue"     // set方法，改变bird2的颜色
>>> bird1 == bird2       // 现在bird1和bird2相等。
true
```

---

> **数据类的约定和使用：**
>
> - 数据类必须拥有一个构造方法，该方法至少包含一个参数。
> - 数据类构造方法必须强制使用`val` 或 `var`来修饰
> - `data class` 之前不能使用`abstract`、`open`、`sealed`、`inner`来修饰。
> - `kotlin1.1`数据类只允许实现`接口`，之后既可以实现`接口`也可以继承`类`

---

### copy方法

`kotlin`中，`data class`数据类会自动生成一个用于`浅拷贝`的`copy方法` [^10 ]。

常规`浅拷贝`效果如下：

```kotlin
val bird1 = Bird(13.00, 3, "blue")
val bird2 = bird1
bird2.age = 2
>>> bird1
2
>>> bird2
2
```

使用`copy`方法的`浅拷贝`：

```kotlin
val bird1 = Bird(13.00, 3, "blue")
val bird2 = bird1.copy(age = 2)

>>> bird1
3
>>> bird2
2
```

### componentN方法和解构

`componentN`方法允许我们将类的属性，通过定义`对应关系`并`解构`[^11 ]的方法，绑定在相应的`变量`上：

`data class`会自行生成`componentN`方法，但是其余情况需要我们自己定义。

以下是通过与`类属性`委托给 `Map`的`key`的例子的进阶版本，还用到了`componentN`方法，和`kt解构`基础语法：

```kotlin
class Car(data: Map<String, Any?>) {
    private val brand: String by data
    private val model: String by data
    private val year: Int by data

    operator fun component1(): String = brand
    operator fun component2(): String = model
    operator fun component3(): Int = year

    override fun toString(): String {
        return "Car(brand=$brand, model=$model, year=$year)"
    }
}

fun getCarInfo(): Car {
    val data = mapOf(
        "brand" to "Toyota",
        "model" to "Camry",
        "year" to 2022
    )

    return Car(data)
}

fun main() {
    // 基本解构赋值
    val (brand, model, year) = getCarInfo()
    println("Brand: $brand, Model: $model, Year: $year")

    // 使用 componentN 函数进行解构
    val car = getCarInfo()
    val (brand2, model2, year2) = car
    println("Using componentN functions - Brand: $brand2, Model: $model2, Year: $year2")

    // 部分属性解构赋值
    val (_, _, year3) = getCarInfo()
    println("Year only: $year3")
}
```

## object关键字

`object`是`kotlin`引入的全新`关键字`，代替了`static`的位置，还提供了`单例对象`和`简化匿名表达式`等更多功能。

### 伴生对象

`kotlin`使用`companion object`创造`伴生对象`[^12]，代替了`static`的位置，且实现了更好的`职能分离`。

下面是`伴生对象`的语法：

```kotlin
class MyClass {
    companion object {
        fun create(): MyClass {
            return MyClass()
        }
        
        val constantValue: Int = 100
    }
}

fun main() {
    val instance = MyClass.create()  // 调用伴生对象中的方法来创建实例
    println(MyClass.constantValue)  // 访问伴生对象中的常量值
}
```

### 单例对象

在`kotlin`中，我们可以直接使用`object` 直接实现`单例模式`[^13 ]：

```kotlin
object DatabaseConfig {
    var host: String = "127.0.0.1"
    var port: Int = 3306
    var username: String = "root"
    var password: String = ""
}
DatabaseConfig.host = "localhost" // 使用'var'声明，可以直接修改DatabaseConfig的属性
```

### object简化匿名表达式

`object表达式`可以为`kotlin`提供一种新的`匿名表达式`语法：

和传统的`匿名内部类`相比：

- `object表达式`可以赋值给一个`变量`。
- `object表达式`没有`只能继承一个类及实现一个接口`的限制。

下面是通过`object表达式`定义`匿名表达式`的例子：

```kotlin
val comparator = object : Comparator<String> {
    override fun compare(s1: String?, s2: String?): Int {
        if (s1 == null) 
            return -1
        else if (s2 == null) 
            return 1
        return s1.compareTo(s2)
    }
}
Collections.sort(list, comparator)
```

然而，相比这个例子：`Lambda`表达式提供一种更简洁的语法：

```kotlin
val comparator = Comparator<String> { s1, s2 -> 
    if （s1 == null)
        return@Comparator -1  //这种语法会在'Lambda与集合'章节中讲到。
    else if (s2 == null) 
        return@Comparator 1
    s1.compareTo(s2)
}
Collections.sort(list, comparator)
```

---

> **`object表达式`和`Lambda表达式`哪个更适合替代`匿名内部类`？**
>
> - `匿名内部类`使用的`类接口`只需要实现`一个方法`时，使用`Lambda表达式`更合适。
> - `匿名内部类`有`多个方法`实现的时候，使用`object表达式`更合适

---

[^1 ]: 带上`var` 和`val` 之后，等同于在类的内部声明一个同名的`属性`。
[^2 ]:  多个`init块`有利于我们进一步对初始化操作进行`职能分离`，在复杂业务开发显得格外有用。

[^3 ]:  `kotlin`规定，类的所有`非抽象属性成员`必须在创建`实例对象`时初始化。 
[^4 ]: `kotlin`的`基本数据类型`包括：`Byte`, `Short`, `Int`, `Long`, `Float`, `Double`, `Char`, `Boolean`。
[^5 ]:  `kotlin`的`类`和`方法`默认是不可被`继承`和`重写`的，且使用`:` 来代替`继承`和`接口实现`。
[^6 ]: 子类可以`扩展`父类的功能，但`不能改变`父类原有的功能。
[^7 ]: 一个`Eclipse`、`Intellij IDEA`、`Maven`、`Grandle项目`以及一组由一次`Ant任务`执行编译的代码都可以看做为`模块`
[^8 ]: `Java`中的`内部类`无需写`inner`前缀，写`static`的为静态内部类，`kotlin`与之相反。
[^9 ]: `Java` 的 `record`的成员变量默认是 `final` 的，不能被修改，而 Kotlin 的`数据类`没有这个限制。
[^10 ]: `copy`更像是一种`语法糖`，提供一种简洁的方式`复制`对象。
[^11 ]: `解构（Destructuring）`是一种便捷的语法特性，允许我们将一个复杂的结构`（例如数据类对象、数组、集合等）`拆解成多个单独的`变量`
[^12 ]: `伴生对象`，意为`伴随着某个类的对象`，需要声明在类的`内部`，在类被`装载`的时候进行`初始化`。
[^13 ]: `单例模式`是一种创建型`设计模式`，它确保一个类只能有`一个实例`，并提供了一个`全局访问点`来访问该实例。