# 面向对象编程


`OOP(Object Oriented Programing)`，即面向对象编程。是Java的主流编程思想。核心是将问题分解成 `对象`进行分析

#### 1.包(package)

##### 1.1 分类

- 工程/项目包：区分不同工程 / 项目，使用域名的倒写 + . + 项目名称，如：com.baidu.map
- 功能包：对代码按照功能进行分类管理，不能加复数s，比如：test、util、db

##### 1.2 命名规范

- 遵循Java的基础命名规范
- 全部要求小写，不能加复数
- 同一个包下不能存在同名类，不同可以

##### 1.3 声明包

- 声明当前类所在的包，必须放首行

  ```java
  package com.miaogu.oop.test
  ```

##### 1.4 导入包

- 声明当前类中使用的类。位于那个包下

  ```java
  import java.util.Scanner
  ```
- 可以使用通配符 `*`导入指定包下的所有内容

  ```java
  import  com.miaogu.oop.test.*
  ```
- 某些情况无需导包

  - IDE的自动导包功能
  - `import java.lang` 内置工具类
- 导包快捷键：`Alt` + `Enter`

#### 2.类和对象

##### 2.1 类和对象的关系

- 类：类是由对象抽象的模板，属于引用类型
- 对象：对象是类的具体实例（实物）

##### 2.2 类的定义

我们使用 `class`关键字定义类，使用 `变量`表达 `属性`，`方法`表达 `行为`

```java
// 1. 使用class关键字定义类
class Dog {
    // 2. 用变量表达属性
    String name;   // 属性：名字
    int age;       // 属性：年龄
  
    // 3. 用方法表达行为
    void bark() {  // 行为：叫
        System.out.println("Woof! Woof!");
    }
}
```

##### 2.3 对象

使用 `new` 创建/实例化对象，使用 `.`调用自身属性和方法

```java
public class Main {
    public static void main(String[] args) {
        // 1. 使用new创建对象
        Dog myDog = new Dog();
    
        // 2. 设置对象属性
        myDog.name = "Buddy";
        myDog.age = 3;
    
        // 3. 调用对象方法
        myDog.bark();  // 输出: Woof! Woof!
    
        // 4. 访问对象属性
        System.out.println(myDog.name + " is " + myDog.age + " years old");
    }
}
```

##### 2.4 方法

方法是用来定义 `对象的行为`的 `函数`

```java
[修饰符] 返回值类型 方法名(参数类型1 参数名1, 参数类型2 参数名2, ...) {
    // 方法实现
}
```

###### 2.4.1 方法参数

- **作用**：接收数据
- **形参和实参**

  - 形式参数

    - 定义时的参数：`void sleep(String time)` → `time` 为形式参数
    - 重点是数据类型，形参名称不重要
    - 方法重载规则：

      - 方法名相同
      - 参数类型不同
      - 参数数量不同

      ```java
      class Calculator {
          // 参数数量不同
          int add(int a, int b) { return a + b; }
          int add(int a, int b, int c) { return a + b + c; }
      
          // 参数类型不同
          double add(double a, double b) { return a + b; }
      }
      ```
    - 作用域：方法的任意位置
    - 使用完毕内存自动回收
  - 实际参数

    - 调用时的参数：`cat.sleep("22:00")` → `"22:00"` 为实际参数

    ```java
    class Cat {
        // 形式参数：time (重点看数据类型)
        void sleep(String time) {  // time是形参
            System.out.println("Sleep at " + time);
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            Cat mio = new Cat();
            mio.sleep("22:00");  // "22:00"是实参
        }
    }
    ```

> **变量作用域**
>
> - **全局变量**
>
>   - 声明位置：方法外部，类的内部
>   - 初始值：默认值（如 `int` 为 0，引用类型为 `null`）
>   - 作用域：类的内部任意位置
>   - 内存管理：无法自动释放
> - **局部变量**
>
>   - 声明位置：方法或代码块内部
>   - 初始化要求：必须显式初始化
>   - 作用域：声明所在的方法/代码块
>   - 内存管理：使用完毕自动回收
>
>   ```java
>   class Dog {
>       String name;  // 全局变量（默认值null）
>        
>       void bark() {
>           int times = 3;  // 局部变量（必须初始化）
>           System.out.println("Woof! x" + times);
>       }  // times内存回收
>   }
>   ```

###### 2.4.3 参数传递机制

- **值传递**

  - 适用类型：8大基本类型 + `String`
  - 特点：
    - 传递数据值的副本
    - 方法内修改参数值不影响原始数据

  ```java
  void change(int x) {  // 传递值的副本
      x = 100;
  }
  
  public static void main(String[] args) {
      int num = 1;
      change(num);
      System.out.println(num);  // 输出1（原始值不变）
  }
  ```
- **引用传递**

  - 适用类型：除 `String` 外的引用类型
  - 特点：

    - 传递数据的内存地址
    - 方法内修改引用对象的属性会影响原始数据
    - 方法内修改引用本身（如 `new`）不影响原始引用

    ```java
    class Person {
        String name;
        Person(String name) { this.name = name; }
    }
    
    void changeName(Person p) {
        p.name = "Alice";  // 修改属性会影响原始对象
        p = new Person("Bob");  // 修改引用本身不影响原始引用
    }
    
    public static void main(String[] args) {
        Person p = new Person("Tom");
        changeName(p);
        System.out.println(p.name);  // 输出"Alice"
    }
    ```
  - **保护原始数据的方法**：

    - 创建参数副本：

      - 浅拷贝
        - 特点：新对象与原对象共享引用字段
        - 实现：`Object.clone()` 默认实现
      - 深拷贝
        - 特点：递归复制所有引用对象
        - 实现：需重写 `clone()` 方法

      ```java
      class Address implements Cloneable {
          String city;
          protected Object clone() throws CloneNotSupportedException {
              return super.clone();  // 浅拷贝
          }
      }
      
      class Person implements Cloneable {
          String name;
          Address address;
      
          // 深拷贝实现
          protected Object clone() throws CloneNotSupportedException {
              Person cloned = (Person) super.clone();
              cloned.address = (Address) address.clone();  // 手动克隆引用对象
              return cloned;
          }
      }
      ```

###### 2.4.4 可变参数

`jdk5`新增的功能。指 `参数个数`可变。

- 参数数量灵活（`0`~`N`个）
- 可以传入 `数组`
- 内部以 `数组`形式处理

```java
// 标准声明方式。参数数据类型后使用`...`定义可变参数。
public static void printNames(String... names) {
    for (String name : names) {
        System.out.println(name);
    }
}
System.out.println("YuFan", "Mimo", "Azuremy", "MiaoGu");
    /*
      YuFan
      Mimo
      Azuremy
      MiaoGu
    */
```

> ###### 可变参数注意事项
>
> - 在 `方法`中 `最多`只能有 `一个`可变参数
> - 可变参数 `必须`在参数列表的 `最后`一位

###### 2.4.5 方法返回类型和返回值

`方法 / 函数`向 ` 外部（调用者）`返回\提供一个 `指定类型`的结果

- 返回类型：返回数据的类型
- 返回值：通过 `return`返回数据
- void类型
  - `void` 是无返回，是一种特殊的返回类型
  - `void`的方法也可以使用return。表示 `终止方法`的执行

###### 2.4.6 构造器/构造方法()

- 作用：用来构造对象/实例化对象，并给属性赋值
- 定义

  - 方法名必须和类名保持一致
  - 不能有返回类型，包括void

  ```java
  public Person {
      private String name;
      private int age;
      // 空的构造器，适用于无参
      public Person() {}
      // 完整构造器
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  }
  ```
- 使用：`new / 实例化对象`的时候，被系统调用

  ```java
  new Person(); // 无参
  new Person("YuFan", 21) // 完整参数
  ```

> **隐式构造器**
>
> 当类中没有定义 `显式构造器`的时候，系统创建一个 `无参`的 `空构造器`，称为 `隐式构造器`。当类中 `有显示构造器`的时候，系统 `不再`自动创建 `隐式构造器`
>
> ```java
> public Person {
>  private String name;
>  private int age;
> }
>
> //... 在main方法中
> new Person(); // 无参可用
> ```

###### 2.4.7 toString()

当对象需要转换成字符串的时候，调用 `toString()`方法使用其返回值

- 触发 `自动转换`时，无需手动调用。

  ```java
  public Person {
      private String name;
      private int age;
  
      @override
      public String toString() {
          return "Person{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  
  //... 在main方法中
  Person lisi = new Person("李四", 21);
  System.out.println(lisi) // -> Person{name='李四', age=21}
  ```
- 当 `未定义toString()`方法的时候，使用 `内置toString()方法`打印 `实例对象`的 `内存地址`。

  ```java
  System.out.println(lisi) // -> demo01.Person@2f4d3709
  ```

#### 3.面向对象三大特性

面向对象三大特性：`封装`、`继承`、`多态`

##### 3.1 封装

不允许 `外部`直接 `操作属性`，在类的 `内部提供操作属性的方法`。（实现 `高内聚`）

3.1.1 低耦合/高内聚

- 低耦合：不同模块之间的关联越少越好
- 高内聚：同一个模块的功能越完善越好

3.1.2 具体实现

- 将属性/成员变量私有化（private修饰符）
- 使用 setter / getter 方法
  - 对于普通成员变量，使用get + 成员名称 / set + 成员名称(getName，setName)
  - 对于布尔值类型属性，使用 成员名称 / set + 成员名称(isMale，setIsMale)

```java
public class Person {
    private String name;
    private boolean gender;
    private boolean isMarried;

    public Person(String name, boolean gender, boolean isMarried) {
        this.name = name;
        this.gender = gender;
        this.isMarried = isMarried;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isGender() {
        return gender;
    }

    public void setGender(boolean gender) {
        this.gender = gender;
    }

    public boolean isNotMarried() {
        return !isMarried;
    }

    public void setMarried(boolean married) {
        isMarried = married;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", gender=" + gender +
                ", isMarried=" + isMarried +
                '}';
    }

    public boolean marry(Person ta) {
        return ta.gender != this.gender && ta.isNotMarried() && this.isNotMarried();
    }
}
```

> **封装性注意事项**
>
> - 对单个对象操作的其他方法可定义在类内部
> - 在类的外部时定义类内相关方法（Util/ Service类）
> - 如果定义的是实体/模板类，功能方法应定义类外
> - 多个对象的共用方法应定义在类外
> - 当方法内部存在可复用部分，应当方法内联，尽量避免编写重复代码

##### 3.2 继承

允许一个 `类（子类/派生类）`基于 `另一个类（父类/基类/超类）`来构建

- 使用 `extends` 关键字为 `子类` 指定 `父类`
- `Java` 中，类是 `单继承`的，`一个子类`只能有 `一个父类`
- 多层继承：`父类`有 `父类`，`子类`有 `子类`
- 父类中不是所有内容都能被继承
  - `private`修饰符的类
  - 构造器：无法 `被继承`，但是 `被子类调用`

```java
// 父类
class Animal {
    void eat() {
        System.out.println("动物吃东西");
    }
}

// 子类
class Dog extends Animal {  // 继承
    String breed;  // 子类特有属性
  
    void bark() {  // 子类特有方法
        System.out.println("汪汪叫");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // 继承自父类的方法
        dog.bark();  // 子类特有的方法
        dog.breed = "金毛";  // 子类特有的属性
    }
}
```

##### 3.3 多态

`Java`在处理 `对象在编译时`和 `运行时状态`不同的时候用 `多态`。

###### 3.3.1 子类型多态（类型转换）

- 自动类型转换 / 向上转型

  ```java
  IXxxable = new Xxx();
  ```
- 强制类型转换 / 向下转型

  ```java
  A a = (a) Xxx();
  ```

  > **下转型注意事项**
  >
  > `强制`有风险，类型 `不匹配`，报错 `ClassCastException`类
  >

#### 3.3.2 参数多态（泛型）

`泛型`指的是`泛泛的类型`，`定义时`不具体指明某种`数据类型`（类型参数）

- `JDK5`后`支持泛型`
- **泛型的核心是 `类型擦除`**：编译时`检查泛型类型`，`运行时`擦除转换为`原始类型`或`限定类型`

##### Object实现多类型

- **没有泛型前**：需要	`定义Object对象`实现`不同参数类型`支持
- **缺点**：每次使用需要`类型判断`和`强制转换`，系统处理也麻烦

```java
class Box {
    private Object content;
    
    public void setContent(Object content) {
        this.content = content;
    }
    
    public Object getContent() {
        return content;
    }
}

// 使用时需要强制转换
Box box = new Box();
box.setContent("Hello");
String str = (String) box.getContent();  // 需要强制转换
```

##### 实现泛型

- **Java的泛型只能代表引用类型**
- **常用的泛型名称**：
  - `T`：type 类型
  - `E`：element 元素
  - `N`：number 数值
  - `K`：key 键
  - `V`：value 值
- **泛型类型可以在其定义下的任意位置使用**

##### 泛型类

```java
class Box<T> {
    private T content;
    
    public void setContent(T content) {
        this.content = content;
    }
    
    public T getContent() {
        return content;
    }
}

// 使用泛型类
Box<String> stringBox = new Box<>();
stringBox.setContent("Hello");
String str = stringBox.getContent();  // 无需强制转换
```

##### 泛型接口

```java
interface Comparable<T> {
    int compareTo(T other);
}

class Student implements Comparable<Student> {
    private String name;
    
    @Override
    public int compareTo(Student other) {
        return this.name.compareTo(other.name);
    }
}
```

##### 泛型方法

```java
class Utility {
    // 泛型方法
    public static <T> T process(T input) {
        System.out.println("Processing: " + input);
        return input;
    }
    
    // 多个泛型参数
    public static <K, V> void printPair(K key, V value) {
        System.out.println(key + " = " + value);
    }
}

// 使用泛型方法
String result = Utility.process("Hello");
Utility.printPair("name", "Alice");
```

##### 类型变量的限定

- **限定T的类型只能是限定类型的子类型**
- **语法**：`<T extends BoundingType>`
- **可以使用 & 分割限定类型**
- **T 和 限定类型 可以是类，也可以是接口**

```java
// 限定为Number的子类
class NumberBox<T extends Number> {
    private T value;
    
    public double getDoubleValue() {
        return value.doubleValue();  // 可以调用Number的方法
    }
}

// 多重限定
interface Printable {
    void print();
}

class Document<T extends Number & Printable> {
    private T content;
    
    public void process() {
        content.doubleValue();  // Number的方法
        content.print();        // Printable的方法
    }
}
```

#####  通配符

- 定义`方法参数`和`变量`中表示`任意类型`，注意和`Object`区别
- **语法**：`Type<?> identifier`

##### 逆变和协变

**协变 `<? extends BoundingType>`**

- 限定传入类型必须是`子类型`，只读`不写`
- 子类能`上转型`到父类对象，所以`可以读`
- 写入时编译器不知道`具体子类`是什么，所以Java`禁止写入`

```java
List<? extends Number> numbers = new ArrayList<Integer>();
Number num = numbers.get(0);  // 可以读取
// numbers.add(10);  // 编译错误：不能写入
```

**逆变 `<? super BoundingType>`**
- 限定`传入类型`必须是`父类型`，`只写不读`
- 父类能够直接`写入子类对象`内容，所以`可以写`
- 读取时可能是具体子类，所以`返回Object`，`禁止读取`

```java
List<? super Integer> numbers = new ArrayList<Number>();
numbers.add(10);  // 可以写入
Object obj = numbers.get(0);  // 只能读取为Object
```

> **Tips**
>
> `逆变` `协变`适用`生产者`/`消费者`模型，进行`读写安全限制`
>
> 实际编程可以使用`类型判断`和**`强制类型转换`**来取消逆变协变的`读写行为`，但**`不推荐`**

##### 高级技巧

- 使用`匿名内部类`和`反射`访问`泛型类型`参数

```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

abstract class TypeReference<T> {
    private final Type type;
    
    protected TypeReference() {
        Type superClass = getClass().getGenericSuperclass();
        this.type = ((ParameterizedType) superClass).getActualTypeArguments()[0];
    }
    
    public Type getType() {
        return type;
    }
}

// 使用示例
public class GenericTypeExample {
    public static void main(String[] args) {
        // 使用匿名内部类保留泛型信息
        TypeReference<List<String>> typeRef = new TypeReference<List<String>>() {};
        
        Type type = typeRef.getType();
        System.out.println("泛型类型: " + type);
        
        if (type instanceof ParameterizedType) {
            ParameterizedType pType = (ParameterizedType) type;
            System.out.println("原始类型: " + pType.getRawType());
            System.out.println("类型参数: " + Arrays.toString(pType.getActualTypeArguments()));
        }
    }
}
```

- `Runnable接口`异常处理

`Runnable接口`中`不允许抛出检查型异常`，可以使用`泛型`的`extends`绕过

```java
// 传统Runnable不能抛出检查型异常
class TraditionalRunnable implements Runnable {
    @Override
    public void run() {
        try {
            // 必须在内部处理检查型异常
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// 使用泛型接口绕过异常限制
@FunctionalInterface
interface ThrowingRunnable<E extends Exception> {
    void run() throws E;
}

class ExceptionHandler {
    // 泛型方法处理异常
    public static <E extends Exception> void runWithException(
            ThrowingRunnable<E> runnable) throws E {
        runnable.run();
    }
    
    // 包装为普通Runnable
    public static <E extends Exception> Runnable wrap(
            ThrowingRunnable<E> runnable) {
        return () -> {
            try {
                runnable.run();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

// 使用示例
public class ExceptionExample {
    public static void main(String[] args) {
        // 直接抛出检查型异常
        try {
            ExceptionHandler.runWithException(() -> {
                Thread.sleep(1000);  // 可以直接抛出InterruptedException
                System.out.println("任务完成");
            });
        } catch (InterruptedException e) {
            System.out.println("任务被中断");
        }
        
        // 包装为Runnable使用
        Thread thread = new Thread(ExceptionHandler.wrap(() -> {
            Thread.sleep(1000);
            System.out.println("后台任务完成");
        }));
        thread.start();
    }
}
```

> **Tips**
>
> - **不能在实例化时使用类型变量**，如 `new T()`
> - **不能构造泛型数组**
> - **不能在静态字段和方法中引入泛型类型变量**
> - **不能抛出或捕获泛型类的实例**

#### 4. 访问权限修饰符

`访问权限修饰符` 控制 `内容的访问权限`

- `类`和 `接口`只有 `public`、`无修饰 `两种修饰符
- 一个 `java文件`中只能有一个 `public类`

##### 4.1 public：公有的

- 任意位置都可以使用
- 用于公有的工具类

##### 4.2 protected：受保护的

- 本类、本包、子类中可以使用
- 用于父类

##### 4.3 无修饰

- 访问权限和父类一致或更大本类、本包中可以使用
- 用于内部类

##### 4.4 private：私有的

- 本类中可以使用
- 用于封装性

#### 5. **方法重载和方法重写**

##### 5.1 方法重载

`同一个类`中，`多个方法重名`叫做 `方法重载`

- 方法名 `相同`，参数 `不同`（`参数类型和个数`不同）
- 访问权限修饰符、返回类型 `无法决定`重载
- `构造方法`可以 `重载`

```java
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }  // 同名方法，参数类型不同
}
```

##### 5.2 方法重写

`子类`重写 `父类方法`

- 添加 `@Override: 表示当前方法是重写父类的方法`
- 规则（二同二小一大）：
  - 方法名、参数 `相同`
  - `返回类型`和 `抛出的异常范围`，和 `父类一致`或者 `更小`
  - `访问权限`和 `父类` `一致`或 `更大`

```java
class Animal {
    void sound() { System.out.println("动物叫"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("汪汪"); }  // 重写父类方法
}
```

#### 6.this 和 super

##### 6.1 this

`this`指向 `当前对`象，表示 `当前实例化对象`本身

- 通过点(.)调用自身的属性和方法

  - 属性名称和形参名相同时使用this点调用

    ```java
    class Person {
        String name;
    
        void setName(String name) {
            this.name = name;  // this.name指成员变量，name指参数
        }
    }
    ```
- this()调用自身的构造方法

  ```java
  class Rectangle {
      int width, height;
  
      Rectangle() {
          this(1, 1);  // 调用另一个构造方法
      }
  
      Rectangle(int w, int h) {
          this.width = w;
          this.height = h;
      }
  }
  ```

##### 6.2 super

`super`用于调用 `父类（超类）`的方法或访问 `父类的属性`，实现 `继承关系`中的 `代码复用`和 `层级调用`。

- 通过点(.)调用父类的属性和方法

  ```java
  class Animal {
      void eat() {
          System.out.println("动物吃东西");
      }
  }
  
  class Dog extends Animal {
      void eat() {
          super.eat();  // 先调用父类方法
          System.out.println("狗啃骨头");
      }
  }
  ```
- super()调用父类的构造方法

  - 子类必须调用父类的构造方法。

    ```java
    class Animal {
        private String name;
    
        // 父类只有有参构造方法（没有默认无参构造）
        public Animal(String name) {
            this.name = name;
        }
    
        public void eat() {
            System.out.println(name + "在吃东西");
        }
    }
    
    class Dog extends Animal {
        private String breed;
    
        // 必须显式调用父类的有参构造，super不能省略
        public Dog(String name, String breed) {
            super(name);  // 必须显式调用，否则编译错误
            this.breed = breed;
        }
    
        public void bark() {
            System.out.println(breed + "犬在汪汪叫");
        }
    }
    ```
  - 父类存在无参构造时，自动调用父类的无参构造

    ```java
    class Vehicle {
        Vehicle() {
            System.out.println("交通工具初始化");
        }
    }
    
    class Car extends Vehicle {
        Car() {
            super();  // 调用父类构造方法(可省略)
            System.out.println("汽车初始化");
        }
    }
    ```

> **this 和 super 的注意事项**
>
> `this()`、`super()`只能放在构造方法的首行，且不能 `同时存在`

#### 7 final

`final`的意思是 `最终的`，修饰 `无法改变`的 `事物`

- 修饰常量，值无法改变

  ```java
  class Constants {
      public static final double PI = 3.14159;  // final变量必须初始化且不能修改
  
      public void printPI() {
          // PI = 3.14;  // 编译错误，不能修改final变量
          System.out.println("PI的值是: " + PI);
      }
  }
  ```
- 修饰方法，无法被重写

  ```java
  class Parent {
      public final void show() {  // final方法不能被子类重写
          System.out.println("这是父类final方法");
      }
  }
  
  class Child extends Parent {
      // 尝试重写会报错
      // @Override
      // public void show() {}  // 编译错误
  }
  ```
- 修饰类，无法被继承

  ```java
  final class MathUtils {  // final类不能被继承
      public static int add(int a, int b) {
          return a + b;
      }
  }
  
  // 尝试继承会报错
  // class AdvancedMath extends MathUtils {}  // 编译错误
  ```

> **使用 final 的优点**
>
> 被final修饰的，`无需考虑改变`，处理速度 `快`。一般 `工具类`定义为 `final`（如 `String`）
>
> ```java
> public final class StringUtils {  // final工具类
>        private StringUtils() {}  // 私有构造防止实例化
>    
>        public static final String EMPTY = "";  // final常量
>    
>        public static boolean isEmpty(final String str) {  // final参数
>             return str == null || str.length() == 0;
>        }
> }
> ```

#### 8 static

static含义是 `静态的`，`类级别`共享，`独立`于 `实例`，`直接通过类`访问。

- 修饰变量、方法、构造代码块、内部类
- static修饰的事物是独立于实例对象的，静态的内容共享一块静态存储区

##### 8.1 实例变量/方法 和 类变量/方法

- 实例变量/实例方法：普通的变量和方法，由实例对象调用
- 静态变量/静态方法：静态的变量和方法，由类调用

```java
class Example {
    // 实例变量
    int instanceVar = 10;
  
    // 静态变量（类变量）
    static int staticVar = 20;
  
    // 实例方法
    void instanceMethod() {
        System.out.println("实例方法调用");
    }
  
    // 静态方法（类方法）
    static void staticMethod() {
        System.out.println("静态方法调用");
    }
  
    public static void main(String[] args) {
        // 访问静态变量和方法
        System.out.println(Example.staticVar); // 直接通过类访问
        Example.staticMethod();
    
        // 访问实例变量和方法需要创建对象
        Example obj = new Example();
        System.out.println(obj.instanceVar);
        obj.instanceMethod();
    }
}
```

##### 8.2 代码块 / 构造代码块 / 静态构造代码块

- 代码块：使用代码块括起来的一段代码
- 构造代码块：在方法外部定义的代码块，每次实例化对象都会调用1次构造代码块
- 静态构造代码块：使用static修饰的构造代码块。类加载时执行1次的初始化操作

```java
class BlockExample {
    // 静态构造代码块 - 类加载时执行一次
    static {
        System.out.println("静态构造代码块执行");
    }
  
    // 构造代码块 - 每次创建对象时执行
    {
        System.out.println("构造代码块执行");
    }
  
    // 构造函数
    public BlockExample() {
        System.out.println("构造函数执行");
    }
  
    public static void main(String[] args) {
        // 代码块 - 方法内的普通代码块
        {
            int x = 10;
            System.out.println("普通代码块中的x: " + x);
        }
    
        System.out.println("创建第一个对象:");
        new BlockExample();
    
        System.out.println("创建第二个对象:");
        new BlockExample();
    }
}
```

> **注意事项和主要应用场景**
>
> - 注意事项
>
>   - 静态的内容一旦被分配内存，无法回收释放，直到应用停止
>   - 静态方法只能调用类变量和类方法
>   - 静态方法中无法使用this和super关键字
>   - 子类无法重写父类的静态方法
>
> ```java
> class StaticLimitations {
>     static int staticField = 100;
>     int instanceField = 200;
>
>     // 静态方法只能访问静态成员
>     static void staticMethod() {
>         System.out.println(staticField); // 可以访问静态变量
>         // System.out.println(instanceField); // 错误 - 不能访问实例变量
>         // this.staticMethod(); // 错误 - 不能使用this
>     }
>
>     // 实例方法可以访问静态和实例成员
>     void instanceMethod() {
>         System.out.println(staticField); // 可以访问静态变量
>         System.out.println(instanceField); // 可以访问实例变量
>     }
> }
>
> class Parent {
>     static void staticMethod() {
>         System.out.println("父类静态方法");
>     }
> }
>
> class Child extends Parent {
>     // 这不是重写，只是隐藏了父类的静态方法
>     static void staticMethod() {
>         System.out.println("子类静态方法");
>     }
> }
> ```
>
> - 应用场景
>
>   - 状态码：静态常量
>   - 工具类的方法
>   - 一次性初始化操作：静态构造代码块

#### 9 抽象

##### 9.1 抽象方法

只有 `方法的声明`，`没有方法的实现`的方法叫 `抽象方法`

- 抽象方法使用 `abstract`关键字修饰

  ```java
  public abstract void eat();
  ```
- 抽象方法只能存在于抽象类中

  ```java
  public abstract Animal {
      public abstract void eat();
  }
  ```

##### 9.2 抽象类

使用 `abstract`修饰的类称之为 `抽象类`

- 抽象类无法实例化对象的，只能被子类继承
- 抽象类中可以有普通类的任意内容
- 子类如果继承了抽象父类，或实现抽象方法，或定义为抽象类

```java
// 抽象类示例
abstract class Animal {
    // 抽象类可以有构造方法
    public Animal(String name) {
        this.name = name;
        System.out.println("Animal构造方法被调用，name=" + name);
    }
  
    private String name;
  
    // 普通方法
    public void eat() {
        System.out.println(name + "正在吃东西");
    }
  
    // 抽象方法
    public abstract void makeSound();
  
    // 普通属性
    public String getName() {
        return name;
    }
}

// 子类继承抽象类
class Dog extends Animal {
    public Dog(String name) {
        super(name); // 调用父类构造方法
    }
  
    // 实现抽象方法
    @Override
    public void makeSound() {
        System.out.println(getName() + "在叫: 汪汪汪!");
    }
}

public class AbstractClassDemo {
    public static void main(String[] args) {
        // Animal animal = new Animal(); // 错误，抽象类不能实例化
        Animal dog = new Dog("小黑");
        dog.eat();
        dog.makeSound();
    }
}
```

> **抽象类中的构造方法是否可以存在？做什么用。**
>
> `可以存在`。被 `子类`使用 `super`调用。

#### 10 接口

`接口`用来定义 `行为规范`。由于 `抽象类`可以包含 `其他内容`。抽象的 `不够彻底`。开发中往往把 `抽象方法`提取出来放到 `接口`中统一定义。

- 接口使用 `interface`关键字规范。
- 一般规范：`I `+ `名称` +` able`

  - 内部组成
  - JDK8之前：

    - 公有的静态常量（public static final）
    - 公有的抽象方法（public abstract）

    ```java
    // 接口定义
    interface ISwimable {
        // 公有静态常量
        public static final int MAX_SPEED = 50;
    
        // 公有抽象方法
        public abstract void swim();
    }
    
    interface IFlyable {
        void fly(); // 默认就是public abstract
    }
    ```
  - JDK8+：

    - 静态方法
    - 默认方法

    ```java
    interface IComputable {
        // 传统抽象方法
        int calculate(int a, int b);
    
        // JDK8 默认方法
        default void showResult(int result) {
            System.out.println("计算结果是: " + result);
        }
    
        // JDK8 静态方法
        static void printVersion() {
            System.out.println("计算器接口 v1.0");
        }
    }
    ```
- 接口的实现

  - 使用 `implements`实现接口
  - 如果子类实现接口，或实现接口中的抽象方法，或定义为抽象类
  - 多实现：一个子类可以实现多个接口

    ```java
    // 多接口实现
    class Duck implements ISwimable, IFlyable {
        @Override
        public void swim() {
            System.out.println("鸭子在水里游泳，速度不超过" + ISwimable.MAX_SPEED);
        }
    
        @Override
        public void fly() {
            System.out.println("鸭子在天空飞翔");
        }
    }
    ```
- 父实现：`接口`可以有 `多个父接口`

  - `子接口`使用 `extends`继承 `父接口`

    ```java
    // 接口继承
    interface IAmphibiousable extends ISwimable, IFlyable {
        void walk();
    }
    ```

#### 11 内部类

一个类定义在另一个类的内部，就是 `内部类`

- 优点：内部类可以直接调用外部类任何组成部分
- 缺点：破坏了类的结构，而且使用非常麻烦
- 分类：

  - 普通内部类

    ```java
    class Outer {
        class Inner {
            void show() {
                System.out.println("内部类方法");
            }
        }
    
        public static void main(String[] args) {
            Outer.Inner in = new Outer().new Inner();
            in.show();
        }
    }
    ```
  - 静态内部类

    ```java
    class Outer {
        static class Inner {
            static void show() {
                System.out.println("静态内部类方法");
            }
        }
    
        public static void main(String[] args) {
            Outer.Inner.show(); // 直接调用
        }
    }
    ```
  - 匿名内部类

    ```java
    class Outer {
        public static void main(String[] args) {
            new Runnable() { // 匿名内部类
                public void run() {
                    System.out.println("匿名内部类方法");
                }
            }.run();
        }
    }
    ```

> **内部类成为历史**
>
> `JDK8`之后，`内部类`的 `语法`基本被 `Lambda表达式`代替
>
> ```java
> public class MainTest {
>     public static void main(String[] args) {
>         List<Book> books = new ArrayList<>(List.of(
>                 new Book("Java", 100),
>                 new Book("C++", 200),
>                 new Book("Python", 300)
>         ));
>         // 1. 使用匿名内部类实现
>         books.sort( new Comparator<Book>() {
>             @Override
>             public int compare(Book o1, Book o2) {
>                 return o1.getPrice() - o2.getPrice();
>             }
>         });
>         // 2. 进一步简化为lambda表达式
>         books.sort((o1, o2) -> o2.getPrice() - o1.getPrice());
>         // 3. lambda表达式还可以简化为函数式接口 + 方法引用
>         books.sort(Comparator.comparingInt(Book::getPrice));
>     }
> }
> ```

#### 12. 枚举

`枚举`定义一组 `固定的常量`，属于 `引用类型`

- 作用：代替 `静态常量`实现 `状态码`
- 定义

  ```java
  enum Gender {
      MAN, WOMEN
  }
  ```
- 使用

  ```java
  Gender gender = Gender.MAN
  ```
- 枚举判断支持 `if`和 ` switch`

  - `if`

    ```java
    if (gender == Gender.MAN) {
        System.out.println("男性");
    } else if (gender == Gender.WOMAN) {
        System.out.println("女性");
    }
    ```
  - `switch`

    ```java
    String description = switch (gender) {
        case MAN -> "男性";
        case WOMAN -> "女性";
        // 不需要default，因为枚举已经覆盖所有情况
    };
    System.out.println(description);
    
    ```
- 每个 `枚举值`默认都是由 `public` `static` `final` 修饰的
- 枚举值的本质是 `类`的 `实例对象`
- 枚举同样包括 `成员变量`、`构造方法`、`属性`、`方法`

  ```java
  public enum Gender {
      // 枚举值实际上是类的实例对象，调用的是私有构造方法
      MAN("男"),  // 相当于 public static final Gender MAN = new Gender("男");
      WOMAN("女"); // 相当于 public static final Gender WOMAN = new Gender("女");
  
      // 成员变量 - 存储中文值
      private final String chineseValue;
  
      // 私有构造方法 - 枚举的构造方法默认就是private的
      private Gender(String chineseValue) {
          this.chineseValue = chineseValue;
      }
  
      // Getter方法 - 获取中文值
      public String getChineseValue() {
          return this.chineseValue;
      }
  
      // 可以添加其他方法
      public String getDescription() {
          return switch (this) {
              case MAN -> "男性";
              case WOMAN -> "女性";
          };
      }
  }
  ```

> **枚举常用方法**
>
> - `values()`：类似于 `类`的 `静态方法`，返回 `当前枚举类型`的 `所有值`
> - `name()`：获得 `枚举变量`的 `名称`
> - `ordinal()`：获得 `枚举变量`的 `值`
> - `equals()`：判断两个 `枚举变量`是否 `相等`，等价于 `==`
>
> ```java
> public enum Gender {
>     MAN("男"),
>     WOMAN("女");
>   
>     private final String chineseValue;
>   
>     private Gender(String chineseValue) {
>         this.chineseValue = chineseValue;
>     }
>   
>     public String getChineseValue() {
>         return this.chineseValue;
>     }
> }
>
> public class Main {
>     public static void main(String[] args) {
>         // 1. values() 方法 - 获取所有枚举值
>         System.out.println("所有枚举值:");
>         for (Gender gender : Gender.values()) {
>             System.out.println(gender);
>         }
>     
>         // 2. name() 方法 - 获取枚举常量的名称
>         Gender male = Gender.MAN;
>         System.out.println("\nname() 方法:");
>         System.out.println("枚举名称: " + male.name()); // 输出: MAN
>     
>         // 3. ordinal() 方法 - 获取枚举常量的序数(声明位置，从0开始)
>         System.out.println("\nordinal() 方法:");
>         System.out.println("MAN的位置: " + Gender.MAN.ordinal()); // 输出: 0
>         System.out.println("WOMAN的位置: " + Gender.WOMAN.ordinal()); // 输出: 1
>     
>         // 4. equals() 和 == 比较
>         Gender female1 = Gender.WOMAN;
>         Gender female2 = Gender.WOMAN;
>         Gender male2 = Gender.MAN;
>     
>         System.out.println("\n比较方法:");
>         System.out.println("female1 == female2: " + (female1 == female2)); // true
>         System.out.println("female1.equals(female2): " + female1.equals(female2)); // true
>         System.out.println("female1 == male2: " + (female1 == male2)); // false
>     
>         // 5. 结合自定义方法的调用
>         System.out.println("\n自定义方法:");
>         System.out.println("MAN的中文值: " + Gender.MAN.getChineseValue());
>         System.out.println("WOMAN的中文值: " + Gender.WOMAN.getChineseValue());
>     
>         // 6. valueOf() 方法 - 根据名称获取枚举实例
>         try {
>            Gender man = Gender.valueOf("MAN");
>            System.out.println("\nvalueOf() 方法:");
>            System.out.println("找到枚举: " + man);
>    
>    // 不存在的枚举名称会抛出IllegalArgumentException
>            Gender unknown = Gender.valueOf("UNKNOWN");
>        } catch (IllegalArgumentException e) {
>            System.out.println("捕获异常: " + e.getMessage());
>        }
>    }
>}
>```
