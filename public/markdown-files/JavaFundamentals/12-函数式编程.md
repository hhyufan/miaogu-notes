# Java函数式编程

![函数式编程](images\函数式编程.png)

#### 1. 函数式编程概述

##### 1.1 什么是函数式编程

函数式编程是一种编程范式，它将计算视为数学函数的求值，强调函数的使用，避免改变状态和可变数据。

**特点**：

- **不可变性**：数据一旦创建就不能修改
- **纯函数**：相同输入总是产生相同输出，无副作用
- **高阶函数**：函数可以作为参数传递或返回值
- **声明式编程**：关注做什么，而不是怎么做

```java
// 传统命令式编程
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = new ArrayList<>();
for (Integer num : numbers) {
    if (num % 2 == 0) {
        evenNumbers.add(num * 2);
    }
}

// 函数式编程
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .collect(Collectors.toList());
```

#### 2. 函数式接口

##### 2.1 概述

函数式接口是**有且只有一个抽象方法**的接口，是Lambda表达式的基础。

**特点**：

- 接口中有且只有一个抽象方法
- 可以有默认方法和静态方法
- 使用 `@FunctionalInterface`注解标识
- 实现该抽象方法，实现离开接口
- 理解：抽象方法就是接口的表示

```java
@FunctionalInterface
public interface MyFunction {
    int calculate(int a, int b);
  
    default void print() {
        System.out.println("默认方法");
    }
  
    static void info() {
        System.out.println("静态方法");
    }
}
```

##### 2.2 常用函数式接口

###### 2.2.1 Supplier`<T>` - 生产者

**特点**：无参数，返回一个结果

**核心方法**：`T get()`

```java
import java.util.function.Supplier;
import java.util.Random;

public class SupplierDemo {
    public static void main(String[] args) {
        Supplier<Integer> randomSupplier = () -> new Random().nextInt(100);
        System.out.println("随机数：" + randomSupplier.get());
      
        Supplier<String> messageSupplier = () -> "Hello World";
        System.out.println("消息：" + messageSupplier.get());
    }
}
```

###### 2.2.2 Consumer`<T>` - 消费者

**特点**：接受一个参数，无返回值

**核心方法**：`void accept(T t)`

**变种**：`BiConsumer<T, U>` 接受两个参数

```java
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.Arrays;
import java.util.List;

public class ConsumerDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("张三", "李四", "王五");
      
        Consumer<String> printer = name -> System.out.println("姓名：" + name);
        names.forEach(printer);
      
        BiConsumer<String, Integer> scoreConsumer = (name, score) -> 
            System.out.println(name + "的成绩：" + score);
        scoreConsumer.accept("张三", 85);
    }
}
```

###### 2.2.3 Function<T, R> - 转换器

**特点**：接受一个参数，返回一个结果

**核心方法**：`R apply(T t)`

**变种**：

- `BiFunction<T, U, R>`：接受两个参数
- `UnaryOperator<T>`：单参数，返回类型相同，等同于Function<T, T>
- `BinaryOperator<T>`：双参数，返回类型相同，等同于BiFunction<T, T, T>

```java
import java.util.function.*;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class FunctionDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("张三", "李四", "王五");
      
        Function<String, Integer> lengthFunction = String::length;
        List<Integer> lengths = names.stream()
            .map(lengthFunction)
            .collect(Collectors.toList());
        System.out.println("姓名长度：" + lengths);
      
        BiFunction<String, String, String> concat = (a, b) -> a + " " + b;
        String result = concat.apply("Hello", "World");
        System.out.println("拼接结果：" + result);
      
        UnaryOperator<String> addPrefix = name -> "Mr. " + name;
        BinaryOperator<Integer> sum = (a, b) -> a + b;
        System.out.println("求和结果：" + sum.apply(10, 20));
    }
}
```

###### 2.2.4 Predicate`<T>` - 断言

**特点**：接受一个参数，返回布尔值

**核心方法**：`boolean test(T t)`

**变种**：`BiPredicate<T, U>` 接受两个参数

```java
import java.util.function.Predicate;
import java.util.function.BiPredicate;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class PredicateDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
      
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> greaterThan5 = n -> n > 5;
      
        // and操作
        List<Integer> andResult = numbers.stream()
            .filter(isEven.and(greaterThan5))
            .collect(Collectors.toList());
        System.out.println("偶数且大于5：" + andResult);
      
        // or操作
        List<Integer> orResult = numbers.stream()
            .filter(isEven.or(greaterThan5))
            .collect(Collectors.toList());
        System.out.println("偶数或大于5：" + orResult);
      
        // negate操作
        List<Integer> negateResult = numbers.stream()
            .filter(isEven.negate())
            .collect(Collectors.toList());
        System.out.println("奇数：" + negateResult);
      
        BiPredicate<String, Integer> lengthCheck = (str, len) -> str.length() == len;
        System.out.println("字符串长度检查：" + lengthCheck.test("Hello", 5));
    }
}
```

###### 2.2.5 Comparator`<T>` - 比较器

**特点**：比较两个对象（排序）

**核心方法**：`int compare(T o1, T o2)`

```java
import java.util.*;

class Person {
    private String name;
    private int age;
  
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
  
    public String getName() { return name; }
    public int getAge() { return age; }
  
    @Override
    public String toString() {
        return name + "(" + age + "岁)";
    }
}

public class ComparatorDemo {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("张三", 25),
            new Person("李四", 30),
            new Person("王五", 20)
        );
      
        people.sort(Comparator.comparing(Person::getAge));
        System.out.println("按年龄排序：" + people);
      
        people.sort(Comparator.comparing(Person::getAge).reversed());
        System.out.println("按年龄倒序：" + people);
    }
}
```

###### 2.2.6 Runnable - 多线程任务

**特点**：无参数，无返回值（多线程任务）

**核心方法**：`void run()`

```java
public class RunnableDemo {
    public static void main(String[] args) {
        Runnable task1 = new Runnable() {
            @Override
            public void run() {
                System.out.println("传统方式执行任务");
            }
        };
      
        Runnable task2 = () -> System.out.println("Lambda方式执行任务");
      
        new Thread(task1).start();
        new Thread(task2).start();
      
        new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                System.out.println("任务执行中：" + i);
            }
        }).start();
    }
}
```

###### 2.2.7 FileFilter - 文件过滤

**特点**：文件过滤

**核心方法**：`boolean accept(File pathname)`

```java
import java.io.File;
import java.io.FileFilter;

public class FileFilterDemo {
    public static void main(String[] args) {
        File directory = new File(".");
      
        FileFilter javaFilter = new FileFilter() {
            @Override
            public boolean accept(File pathname) {
                return pathname.getName().endsWith(".java");
            }
        };
      
        FileFilter txtFilter = file -> file.getName().endsWith(".txt");
      
        File[] javaFiles = directory.listFiles(javaFilter);
        System.out.println("Java文件数量：" + (javaFiles != null ? javaFiles.length : 0));
      
        File[] files = directory.listFiles(file -> 
            file.isFile() && file.length() > 1024);
        System.out.println("大于1KB的文件数量：" + (files != null ? files.length : 0));
    }
}
```

##### 2.3 原始类型特化接口

为了避免装箱拆箱的性能损耗，Java提供了针对原始类型的特化接口。

###### 2.3.1 IntSupplier、LongSupplier、DoubleSupplier

```java
import java.util.function.*;
import java.util.Random;

public class PrimitiveSupplierDemo {
    public static void main(String[] args) {
        Random random = new Random();
      
        IntSupplier randomInt = () -> random.nextInt(100);
        System.out.println("随机整数：" + randomInt.getAsInt());
      
        LongSupplier currentTime = System::currentTimeMillis;
        System.out.println("当前时间戳：" + currentTime.getAsLong());
      
        DoubleSupplier randomDouble = Math::random;
        System.out.println("随机小数：" + randomDouble.getAsDouble());
    }
}
```

###### 2.3.2 IntConsumer、LongConsumer、DoubleConsumer

```java
import java.util.function.*;
import java.util.stream.IntStream;

public class PrimitiveConsumerDemo {
    public static void main(String[] args) {
        IntConsumer printSquare = x -> System.out.println(x + "的平方是：" + (x * x));
        IntStream.range(1, 4).forEach(printSquare);
      
        LongConsumer printLong = System.out::println;
        printLong.accept(123456789L);
      
        DoubleConsumer printDouble = d -> System.out.printf("%.2f%n", d);
        printDouble.accept(3.14159);
    }
}
```

###### 2.3.3 IntFunction、LongFunction、DoubleFunction

```java
import java.util.function.*;
import java.util.stream.IntStream;
import java.util.List;
import java.util.stream.Collectors;

public class PrimitiveFunctionDemo {
    public static void main(String[] args) {
        IntFunction<String> intToString = i -> "数字" + i;
        List<String> strings = IntStream.range(1, 4)
            .mapToObj(intToString)
            .collect(Collectors.toList());
        System.out.println(strings);
      
        ToIntFunction<String> stringLength = String::length;
        int length = stringLength.applyAsInt("Hello");
        System.out.println("字符串长度：" + length);
      
        IntToDoubleFunction sqrt = Math::sqrt;
        double result = sqrt.applyAsDouble(16);
        System.out.println("16的平方根：" + result);
    }
}
```

###### 2.3.4 IntPredicate、LongPredicate、DoublePredicate

```java
import java.util.function.*;
import java.util.stream.IntStream;
import java.util.List;
import java.util.stream.Collectors;

public class PrimitivePredicateDemo {
    public static void main(String[] args) {
        IntPredicate isEven = x -> x % 2 == 0;
        IntPredicate isPositive = x -> x > 0;
      
        List<Integer> evenPositive = IntStream.range(-3, 6)
            .filter(isEven.and(isPositive))
            .boxed()
            .collect(Collectors.toList());
        System.out.println("正偶数：" + evenPositive);
      
        LongPredicate isLarge = x -> x > 1000000L;
        System.out.println("是否为大数：" + isLarge.test(2000000L));
      
        DoublePredicate isInRange = d -> d >= 0.0 && d <= 1.0;
        System.out.println("是否在[0,1]范围内：" + isInRange.test(0.5));
    }
}
```

###### 2.3.5 IntBinaryOperator、LongBinaryOperator、DoubleBinaryOperator

```java
import java.util.function.*;
import java.util.stream.IntStream;

public class PrimitiveBinaryOperatorDemo {
    public static void main(String[] args) {
        // IntBinaryOperator
        IntBinaryOperator sum = (a, b) -> a + b;
        IntBinaryOperator max = Integer::max;
      
        int total = IntStream.range(1, 6)
            .reduce(0, sum);
        System.out.println("求和：" + total);
      
        int maximum = IntStream.of(3, 7, 2, 9, 1)
            .reduce(Integer.MIN_VALUE, max);
        System.out.println("最大值：" + maximum);
      
        // LongBinaryOperator
        LongBinaryOperator multiply = (a, b) -> a * b;
        long product = multiply.applyAsLong(123L, 456L);
        System.out.println("乘积：" + product);
      
        // DoubleBinaryOperator
        DoubleBinaryOperator average = (a, b) -> (a + b) / 2.0;
        double avg = average.applyAsDouble(10.5, 20.3);
        System.out.println("平均值：" + avg);
    }
}
```

#### 3. Lambda表达式

##### 3.1 Lambda表达式概述

Lambda表达式是Java 8引入的一个重要特性，它允许我们以更简洁的方式表示匿名函数。

**语法格式**：`(参数列表) -> { 方法体 }`

**特点**：

- 简化匿名内部类的写法
- 只能用于函数式接口
- 编译器自动推断类型
- 支持方法引用

##### 3.2 Lambda表达式语法规则

###### 3.2.1 基本语法

```java
import java.util.function.*;

public class LambdaSyntaxDemo {
    public static void main(String[] args) {
        // 1. 无参数，无返回值
        Runnable r1 = () -> System.out.println("无参数Lambda");
      
        // 2. 一个参数，无返回值（参数括号可省略）
        Consumer<String> c1 = s -> System.out.println(s);
        Consumer<String> c2 = (s) -> System.out.println(s);
      
        // 3. 多个参数，无返回值
        BiConsumer<String, Integer> bc = (name, age) -> {
            System.out.println("姓名：" + name + ", 年龄：" + age);
        };
      
        // 4. 一个参数，有返回值
        Function<String, Integer> f1 = s -> s.length();
        Function<String, Integer> f2 = (s) -> s.length();
      
        // 5. 多个参数，有返回值
        BinaryOperator<Integer> bo1 = (a, b) -> a + b;
      
        // 6. 方法体只有一条语句时，大括号可省略
        BinaryOperator<Integer> bo2 = (a, b) -> {
            return a + b;
        };
      
        // 7. 方法体只有一条return语句时，return和大括号都可省略
        BinaryOperator<Integer> bo3 = (a, b) -> a + b;
      
        // 测试
        r1.run();
        c1.accept("Hello Lambda");
        bc.accept("张三", 25);
        System.out.println("字符串长度：" + f1.apply("Hello"));
        System.out.println("求和结果：" + bo1.apply(10, 20));
    }
}
```

##### 3.3 方法引用

方法引用是Lambda表达式的简化写法，当Lambda表达式只是调用一个已存在的方法时，可以使用方法引用。

**语法格式**：
- 静态方法引用：`类名::静态方法名`
- 实例对象方法引用：`对象名::实例方法名`
- 类的实例方法引用：`类名::实例方法名`
- 构造器引用：`类名::new`
- 数组构造引用：`类型[]::new`

###### 3.3.1 简单Demo演示

```java
import java.util.*;
import java.util.function.*;

// 自定义工具类
class Utils {
    // 静态方法
    public static int add(int a, int b) {
        return a + b;
    }
    
    // 实例方法
    public String format(String str) {
        return "[" + str + "]";
    }
}

// 自定义类
class Person {
    private String name;
    
    public Person() {
        this.name = "匿名";
    }
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    @Override
    public String toString() {
        return name;
    }
}

public class MethodReferenceDemo {
    public static void main(String[] args) {
        // 1. 静态方法引用
        BinaryOperator<Integer> add1 = (a, b) -> Utils.add(a, b);  // Lambda
        BinaryOperator<Integer> add2 = Utils::add;                 // 方法引用
        System.out.println("静态方法引用：" + add2.apply(3, 5));
        
        // 2. 实例对象方法引用
        Utils utils = new Utils();
        Function<String, String> format1 = str -> utils.format(str);  // Lambda
        Function<String, String> format2 = utils::format;             // 方法引用
        System.out.println("实例对象方法引用：" + format2.apply("Hello"));
        
        // 3. 类的实例方法引用
        Function<String, Integer> length1 = str -> str.length();  // Lambda
        Function<String, Integer> length2 = String::length;       // 方法引用
        System.out.println("类实例方法引用：" + length2.apply("World"));
        
        // 4. 构造器引用
        Supplier<Person> person1 = () -> new Person();     // Lambda
        Supplier<Person> person2 = Person::new;            // 方法引用
        Function<String, Person> person3 = Person::new;    // 带参构造器
        System.out.println("构造器引用：" + person3.apply("张三"));
        
        // 5. 数组构造器引用
        IntFunction<String[]> array1 = size -> new String[size];  // Lambda
        IntFunction<String[]> array2 = String[]::new;             // 方法引用
        String[] arr = array2.apply(3);
        System.out.println("数组构造器引用：数组长度=" + arr.length);
    }
}
```

###### 3.3.2 常用方法引用对照表

**静态方法引用**

| 方法引用 | Lambda表达式 | 函数式接口 | 方法签名 |
|---------|-------------|-----------|----------|
| `Integer::parseInt` | `s -> Integer.parseInt(s)` | `Function<String, Integer>` | `Integer apply(String)` |
| `Math::abs` | `x -> Math.abs(x)` | `Function<Integer, Integer>` | `Integer apply(Integer)` |
| `Math::max` | `(a, b) -> Math.max(a, b)` | `BinaryOperator<Integer>` | `Integer apply(Integer, Integer)` |
| `Objects::isNull` | `obj -> Objects.isNull(obj)` | `Predicate<Object>` | `boolean test(Object)` |
| `Collections::sort` | `list -> Collections.sort(list)` | `Consumer<List>` | `void accept(List)` |
| `String::valueOf` | `x -> String.valueOf(x)` | `Function<Integer, String>` | `String apply(Integer)` |

**实例对象方法引用**

| 方法引用 | Lambda表达式 | 函数式接口 | 方法签名 |
|---------|-------------|-----------|----------|
| `System.out::println` | `x -> System.out.println(x)` | `Consumer<Object>` | `void accept(Object)` |
| `sb::append` | `s -> sb.append(s)` | `Function<String, StringBuilder>` | `StringBuilder apply(String)` |
| `random::nextInt` | `() -> random.nextInt()` | `Supplier<Integer>` | `Integer get()` |
| `list::add` | `x -> list.add(x)` | `Predicate<Object>` | `boolean test(Object)` |
| `map::get` | `key -> map.get(key)` | `Function<String, Object>` | `Object apply(String)` |
| `scanner::nextLine` | `() -> scanner.nextLine()` | `Supplier<String>` | `String get()` |

**类的实例方法引用**

| 方法引用 | Lambda表达式 | 函数式接口 | 方法签名 |
|---------|-------------|-----------|----------|
| `String::length` | `str -> str.length()` | `Function<String, Integer>` | `Integer apply(String)` |
| `String::toUpperCase` | `str -> str.toUpperCase()` | `Function<String, String>` | `String apply(String)` |
| `String::compareTo` | `(s1, s2) -> s1.compareTo(s2)` | `Comparator<String>` | `int compare(String, String)` |
| `String::equals` | `(s1, s2) -> s1.equals(s2)` | `BiPredicate<String, String>` | `boolean test(String, String)` |
| `Integer::compareTo` | `(i1, i2) -> i1.compareTo(i2)` | `Comparator<Integer>` | `int compare(Integer, Integer)` |
| `Object::toString` | `obj -> obj.toString()` | `Function<Object, String>` | `String apply(Object)` |

**构造器引用**

| 方法引用 | Lambda表达式 | 函数式接口 | 方法签名 |
|---------|-------------|-----------|----------|
| `ArrayList::new` | `() -> new ArrayList<>()` | `Supplier<ArrayList>` | `ArrayList get()` |
| `StringBuilder::new` | `() -> new StringBuilder()` | `Supplier<StringBuilder>` | `StringBuilder get()` |
| `StringBuilder::new` | `str -> new StringBuilder(str)` | `Function<String, StringBuilder>` | `StringBuilder apply(String)` |
| `Person::new` | `name -> new Person(name)` | `Function<String, Person>` | `Person apply(String)` |
| `HashMap::new` | `() -> new HashMap<>()` | `Supplier<HashMap>` | `HashMap get()` |
| `Date::new` | `() -> new Date()` | `Supplier<Date>` | `Date get()` |

**数组构造器引用**

| 方法引用 | Lambda表达式 | 函数式接口 | 方法签名 |
|---------|-------------|-----------|----------|
| `String[]::new` | `size -> new String[size]` | `IntFunction<String[]>` | `String[] apply(int)` |
| `int[]::new` | `size -> new int[size]` | `IntFunction<int[]>` | `int[] apply(int)` |
| `Object[]::new` | `size -> new Object[size]` | `IntFunction<Object[]>` | `Object[] apply(int)` |
| `Person[]::new` | `size -> new Person[size]` | `IntFunction<Person[]>` | `Person[] apply(int)` |

###### 3.3.3 实际应用示例

```java
import java.util.*;
import java.util.stream.Collectors;

public class MethodReferenceApplication {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry");
        List<Integer> numbers = Arrays.asList(1, -2, 3, -4, 5);
        
        // 1. 使用静态方法引用进行类型转换
        List<Integer> lengths = words.stream()
            .map(String::length)  // 类实例方法引用
            .collect(Collectors.toList());
        
        // 2. 使用静态方法引用进行数学运算
        List<Integer> absolutes = numbers.stream()
            .map(Math::abs)  // 静态方法引用
            .collect(Collectors.toList());
        
        // 3. 使用实例对象方法引用进行输出
        words.forEach(System.out::println);  // 实例对象方法引用
        
        // 4. 使用构造器引用创建对象
        List<StringBuilder> builders = words.stream()
            .map(StringBuilder::new)  // 构造器引用
            .collect(Collectors.toList());
        
        // 5. 使用数组构造器引用转换为数组
        String[] wordArray = words.stream()
            .toArray(String[]::new);  // 数组构造器引用
        
        System.out.println("字符串长度：" + lengths);
        System.out.println("绝对值：" + absolutes);
        System.out.println("StringBuilder数量：" + builders.size());
        System.out.println("数组长度：" + wordArray.length);
    }
}
```

#### 4. Stream流

##### 4.1 Stream概述

Stream是Java 8引入的处理集合数据的新方式，它提供了一种声明式的数据处理方法。

**特点**：

- 不存储数据，只是对数据源的视图
- 不改变数据源，会产生新的Stream
- 延迟执行，只有终端操作时才会执行
- 支持并行处理
- 支持链式调用

**Stream操作分类**：

- **中间操作**：返回Stream对象，支持链式调用
- **终端操作**：返回具体结果，结束Stream流

##### 4.2 Stream创建

###### 4.2.1 从集合创建

```java
import java.util.*;
import java.util.stream.Stream;

public class StreamCreationDemo {
    public static void main(String[] args) {
        // 从List创建
        List<String> list = Arrays.asList("apple", "banana", "cherry");
        Stream<String> stream1 = list.stream();
        Stream<String> parallelStream1 = list.parallelStream();
      
        // 从Set创建
        Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Stream<Integer> stream2 = set.stream();
      
        // 从Map创建
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 5);
        map.put("banana", 6);
      
        Stream<String> keyStream = map.keySet().stream();
        Stream<Integer> valueStream = map.values().stream();
        Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();
      
        // 测试输出
        System.out.println("List元素：");
        list.stream().forEach(System.out::println);
      
        System.out.println("Map键值对：");
        map.entrySet().stream()
            .forEach(entry -> System.out.println(entry.getKey() + " = " + entry.getValue()));
    }
}
```

###### 4.2.2 从数组创建

```java
import java.util.Arrays;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.DoubleStream;

public class ArrayStreamDemo {
    public static void main(String[] args) {
        // 从对象数组创建
        String[] stringArray = {"apple", "banana", "cherry"};
        Stream<String> stream1 = Arrays.stream(stringArray);
        Stream<String> stream2 = Stream.of(stringArray);
      
        // 从基本类型数组创建
        int[] intArray = {1, 2, 3, 4, 5};
        IntStream intStream = Arrays.stream(intArray);
      
        long[] longArray = {1L, 2L, 3L};
        LongStream longStream = Arrays.stream(longArray);
      
        double[] doubleArray = {1.1, 2.2, 3.3};
        DoubleStream doubleStream = Arrays.stream(doubleArray);
      
        // 测试输出
        System.out.println("字符串数组：");
        stream1.forEach(System.out::println);
      
        System.out.println("整数数组求和：" + intStream.sum());
        System.out.println("长整数数组平均值：" + longStream.average().orElse(0.0));
        System.out.println("双精度数组最大值：" + doubleStream.max().orElse(0.0));
    }
}
```

###### 4.2.3 直接创建

```java
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.Random;

public class DirectStreamDemo {
    public static void main(String[] args) {
        // Stream.of() 创建
        Stream<String> stream1 = Stream.of("apple", "banana", "cherry");
        stream1.forEach(System.out::println);
      
        // Stream.empty() 创建空流
        Stream<String> emptyStream = Stream.empty();
        System.out.println("空流元素数量：" + emptyStream.count());
      
        // Stream.generate() 创建无限流
        Stream<Double> randomStream = Stream.generate(Math::random)
            .limit(5); // 限制元素数量
        randomStream.forEach(System.out::println);
      
        // Stream.iterate() 创建无限流
        Stream<Integer> iterateStream = Stream.iterate(0, n -> n + 2)
            .limit(10); // 生成偶数序列
        iterateStream.forEach(System.out::println);
      
        // IntStream.range() 创建数字范围流
        IntStream.range(1, 6) // [1, 6)
            .forEach(System.out::println);
      
        // IntStream.rangeClosed() 创建数字范围流
        IntStream.rangeClosed(1, 5) // [1, 5]
            .forEach(System.out::println);
      
        // Random.ints() 创建随机数流
        new Random().ints(5, 1, 100) // 5个[1,100)的随机数
            .forEach(System.out::println);
    }
}
```

##### 4.3 Stream中间操作

中间操作返回Stream对象，支持链式调用，具有延迟执行的特性。

###### 4.3.1 过滤操作

```java
import java.util.*;
import java.util.stream.Collectors;

public class FilterOperationDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
      
        // filter() - 过滤
        List<Integer> evenNumbers = numbers.stream()
            .filter(n -> n % 2 == 0)
            .collect(Collectors.toList());
        System.out.println("偶数：" + evenNumbers);
      
        // distinct() - 去重
        List<Integer> duplicates = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 5);
        List<Integer> unique = duplicates.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println("去重后：" + unique);
      
        // limit() - 限制元素数量
        List<Integer> limited = numbers.stream()
            .limit(5)
            .collect(Collectors.toList());
        System.out.println("前5个元素：" + limited);
      
        // skip() - 跳过元素
        List<Integer> skipped = numbers.stream()
            .skip(5)
            .collect(Collectors.toList());
        System.out.println("跳过前5个元素：" + skipped);
      
        // takeWhile() - 从头开始取元素直到条件不满足（Java 9+）
        List<Integer> taken = numbers.stream()
            .takeWhile(n -> n < 6)
            .collect(Collectors.toList());
        System.out.println("取小于6的元素：" + taken);
      
        // dropWhile() - 从头开始丢弃元素直到条件不满足（Java 9+）
        List<Integer> dropped = numbers.stream()
            .dropWhile(n -> n < 6)
            .collect(Collectors.toList());
        System.out.println("丢弃小于6的元素：" + dropped);
    }
}
```

###### 4.3.2 映射操作

```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

class Person {
    private String name;
    private int age;
    private List<String> hobbies;
  
    public Person(String name, int age, List<String> hobbies) {
        this.name = name;
        this.age = age;
        this.hobbies = hobbies;
    }
  
    public String getName() { return name; }
    public int getAge() { return age; }
    public List<String> getHobbies() { return hobbies; }
  
    @Override
    public String toString() {
        return name + "(" + age + "岁)";
    }
}

public class MapOperationDemo {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry");
      
        // map() - 一对一映射
        List<Integer> lengths = words.stream()
            .map(String::length)
            .collect(Collectors.toList());
        System.out.println("字符串长度：" + lengths);
      
        List<String> upperCase = words.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        System.out.println("大写转换：" + upperCase);
      
        // mapToInt/mapToLong/mapToDouble - 映射为基本类型
        int totalLength = words.stream()
            .mapToInt(String::length)
            .sum();
        System.out.println("总长度：" + totalLength);
      
        // flatMap() - 一对多映射（扁平化）
        List<Person> people = Arrays.asList(
            new Person("张三", 25, Arrays.asList("读书", "游泳")),
            new Person("李四", 30, Arrays.asList("跑步", "音乐", "电影")),
            new Person("王五", 28, Arrays.asList("旅游"))
        );
      
        List<String> allHobbies = people.stream()
            .flatMap(person -> person.getHobbies().stream())
            .collect(Collectors.toList());
        System.out.println("所有爱好：" + allHobbies);
      
        // flatMapToInt - 扁平化为基本类型
        List<List<Integer>> nestedNumbers = Arrays.asList(
            Arrays.asList(1, 2, 3),
            Arrays.asList(4, 5),
            Arrays.asList(6, 7, 8, 9)
        );
      
        int sum = nestedNumbers.stream()
            .flatMapToInt(list -> list.stream().mapToInt(Integer::intValue))
            .sum();
        System.out.println("嵌套列表求和：" + sum);
    }
}
```

###### 4.3.3 排序操作

```java
import java.util.*;
import java.util.stream.Collectors;

class Employee {
    private String name;
    private int age;
    private double salary;
  
    public Employee(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
  
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getSalary() { return salary; }
  
    @Override
    public String toString() {
        return name + "(" + age + "岁, " + salary + "元)";
    }
}

public class SortOperationDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6);
      
        // sorted() - 自然排序
        List<Integer> sorted = numbers.stream()
            .sorted()
            .collect(Collectors.toList());
        System.out.println("自然排序：" + sorted);
      
        // sorted(Comparator) - 自定义排序
        List<Integer> reverseSorted = numbers.stream()
            .sorted(Comparator.reverseOrder())
            .collect(Collectors.toList());
        System.out.println("逆序排序：" + reverseSorted);
      
        List<String> words = Arrays.asList("apple", "pie", "banana", "book");
      
        // 按长度排序
        List<String> sortedByLength = words.stream()
            .sorted(Comparator.comparing(String::length))
            .collect(Collectors.toList());
        System.out.println("按长度排序：" + sortedByLength);
      
        // 复杂对象排序
        List<Employee> employees = Arrays.asList(
            new Employee("张三", 25, 5000),
            new Employee("李四", 30, 8000),
            new Employee("王五", 28, 6000),
            new Employee("赵六", 25, 7000)
        );
      
        // 按年龄排序
        List<Employee> sortedByAge = employees.stream()
            .sorted(Comparator.comparing(Employee::getAge))
            .collect(Collectors.toList());
        System.out.println("按年龄排序：" + sortedByAge);
      
        // 多字段排序：先按年龄，再按薪资
        List<Employee> multiSorted = employees.stream()
            .sorted(Comparator.comparing(Employee::getAge)
                    .thenComparing(Employee::getSalary))
            .collect(Collectors.toList());
        System.out.println("多字段排序：" + multiSorted);
      
        // 逆序排序
        List<Employee> reverseSortedBySalary = employees.stream()
            .sorted(Comparator.comparing(Employee::getSalary).reversed())
            .collect(Collectors.toList());
        System.out.println("按薪资逆序：" + reverseSortedBySalary);
    }
}
```

##### 4.4 Stream终端操作

终端操作会触发流的执行，返回具体结果，结束Stream流。

###### 4.4.1 遍历操作

```java
import java.util.*;
import java.util.stream.IntStream;

public class ForEachOperationDemo {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry");
      
        // forEach() - 遍历元素
        System.out.println("forEach遍历：");
        words.stream()
            .map(String::toUpperCase)
            .forEach(System.out::println);
      
        // forEachOrdered() - 按顺序遍历（并行流中保证顺序）
        System.out.println("forEachOrdered遍历：");
        words.parallelStream()
            .map(String::toUpperCase)
            .forEachOrdered(System.out::println);
      
        // 带索引的遍历
        System.out.println("带索引遍历：");
        IntStream.range(0, words.size())
            .forEach(i -> System.out.println(i + ": " + words.get(i)));
    }
}
```

###### 4.4.2 查找操作

```java
import java.util.*;
import java.util.stream.Collectors;

public class FindOperationDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
      
        // findFirst() - 查找第一个元素
        Optional<Integer> first = numbers.stream()
            .filter(n -> n > 5)
            .findFirst();
        System.out.println("第一个大于5的数：" + first.orElse(-1));
      
        // findAny() - 查找任意一个元素（并行流中性能更好）
        Optional<Integer> any = numbers.parallelStream()
            .filter(n -> n > 5)
            .findAny();
        System.out.println("任意一个大于5的数：" + any.orElse(-1));
      
        // allMatch() - 检查是否所有元素都满足条件
        boolean allPositive = numbers.stream()
            .allMatch(n -> n > 0);
        System.out.println("是否都是正数：" + allPositive);
      
        // anyMatch() - 检查是否有任意元素满足条件
        boolean hasEven = numbers.stream()
            .anyMatch(n -> n % 2 == 0);
        System.out.println("是否有偶数：" + hasEven);
      
        // noneMatch() - 检查是否没有元素满足条件
        boolean noNegative = numbers.stream()
            .noneMatch(n -> n < 0);
        System.out.println("是否没有负数：" + noNegative);
    }
}
```

###### 4.4.3 聚合操作

```java
import java.util.*;
import java.util.stream.Collectors;

public class AggregateOperationDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
      
        // count() - 计数
        long count = numbers.stream()
            .filter(n -> n % 2 == 0)
            .count();
        System.out.println("偶数个数：" + count);
      
        // max() / min() - 最大值/最小值
        Optional<Integer> max = numbers.stream().max(Integer::compareTo);
        Optional<Integer> min = numbers.stream().min(Integer::compareTo);
        System.out.println("最大值：" + max.orElse(0));
        System.out.println("最小值：" + min.orElse(0));
      
        // reduce() - 归约操作
        // 求和
        Optional<Integer> sum1 = numbers.stream().reduce((a, b) -> a + b);
        int sum2 = numbers.stream().reduce(0, (a, b) -> a + b);
        int sum3 = numbers.stream().reduce(0, Integer::sum);
        System.out.println("求和结果：" + sum2);
      
        // 求积
        int product = numbers.stream().reduce(1, (a, b) -> a * b);
        System.out.println("求积结果：" + product);
      
        // 字符串连接
        List<String> words = Arrays.asList("Hello", "World", "Java");
        String joined = words.stream().reduce("", (a, b) -> a + " " + b).trim();
        System.out.println("字符串连接：" + joined);
      
        // 复杂归约：找出最长的字符串
        Optional<String> longest = words.stream()
            .reduce((a, b) -> a.length() >= b.length() ? a : b);
        System.out.println("最长字符串：" + longest.orElse(""));
    }
}
```

###### 4.4.4 收集操作

```java
import java.util.*;
import java.util.stream.Collectors;

public class CollectOperationDemo {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
      
        // collect(Collector) - 使用收集器
        List<String> list = words.stream()
            .filter(w -> w.length() > 4)
            .collect(Collectors.toList());
        System.out.println("长度大于4的单词：" + list);
      
        Set<String> set = words.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toSet());
        System.out.println("大写单词集合：" + set);
      
        // toArray() - 转换为数组
        String[] array1 = words.stream().toArray(String[]::new);
        Object[] array2 = words.stream().toArray();
        System.out.println("转换为数组：" + Arrays.toString(array1));
      
        // 基本类型流的特殊方法
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
      
        // sum() - 求和（仅基本类型流）
        int sum = numbers.stream().mapToInt(Integer::intValue).sum();
        System.out.println("求和：" + sum);
      
        // average() - 平均值（仅基本类型流）
        OptionalDouble average = numbers.stream().mapToInt(Integer::intValue).average();
        System.out.println("平均值：" + average.orElse(0.0));
      
        // summaryStatistics() - 统计信息（仅基本类型流）
        IntSummaryStatistics stats = numbers.stream().mapToInt(Integer::intValue).summaryStatistics();
        System.out.println("统计信息：" + stats);
    }
}
```

##### 4.5 Collectors工具类

Collectors提供了许多预定义的收集器，用于常见的收集操作。

###### 4.5.1 基本收集器

```java
import java.util.*;
import java.util.stream.Collectors;

class Product {
    private String name;
    private String category;
    private double price;
  
    public Product(String name, String category, double price) {
        this.name = name;
        this.category = category;
        this.price = price;
    }
  
    public String getName() { return name; }
    public String getCategory() { return category; }
    public double getPrice() { return price; }
  
    @Override
    public String toString() {
        return name + "(" + category + ", " + price + "元)";
    }
}

public class BasicCollectorsDemo {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("iPhone", "手机", 8999),
            new Product("MacBook", "电脑", 12999),
            new Product("iPad", "平板", 3999),
            new Product("Samsung", "手机", 6999),
            new Product("ThinkPad", "电脑", 8999)
        );
      
        // toList() - 收集到List
        List<String> names = products.stream()
            .map(Product::getName)
            .collect(Collectors.toList());
        System.out.println("产品名称：" + names);
      
        // toSet() - 收集到Set
        Set<String> categories = products.stream()
            .map(Product::getCategory)
            .collect(Collectors.toSet());
        System.out.println("产品类别：" + categories);
      
        // toCollection() - 收集到指定集合
        LinkedList<String> linkedList = products.stream()
            .map(Product::getName)
            .collect(Collectors.toCollection(LinkedList::new));
        System.out.println("LinkedList：" + linkedList);
      
        // joining() - 字符串连接
        String joinedNames = products.stream()
            .map(Product::getName)
            .collect(Collectors.joining(", "));
        System.out.println("连接的名称：" + joinedNames);
      
        String joinedWithPrefix = products.stream()
            .map(Product::getName)
            .collect(Collectors.joining(", ", "[", "]"));
        System.out.println("带前后缀：" + joinedWithPrefix);
    }
}
```

###### 4.5.2 统计收集器

```java
import java.util.*;
import java.util.stream.Collectors;

public class StatisticsCollectorsDemo {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("iPhone", "手机", 8999),
            new Product("MacBook", "电脑", 12999),
            new Product("iPad", "平板", 3999),
            new Product("Samsung", "手机", 6999),
            new Product("ThinkPad", "电脑", 8999)
        );
      
        // counting() - 计数
        long count = products.stream()
            .filter(p -> p.getPrice() > 5000)
            .collect(Collectors.counting());
        System.out.println("价格大于5000的产品数量：" + count);
      
        // summingDouble() - 求和
        double totalPrice = products.stream()
            .collect(Collectors.summingDouble(Product::getPrice));
        System.out.println("总价格：" + totalPrice);
      
        // averagingDouble() - 平均值
        double averagePrice = products.stream()
            .collect(Collectors.averagingDouble(Product::getPrice));
        System.out.println("平均价格：" + averagePrice);
      
        // maxBy() / minBy() - 最大值/最小值
        Optional<Product> mostExpensive = products.stream()
            .collect(Collectors.maxBy(Comparator.comparing(Product::getPrice)));
        System.out.println("最贵的产品：" + mostExpensive.orElse(null));
      
        Optional<Product> cheapest = products.stream()
            .collect(Collectors.minBy(Comparator.comparing(Product::getPrice)));
        System.out.println("最便宜的产品：" + cheapest.orElse(null));
      
        // summarizingDouble() - 统计摘要
        DoubleSummaryStatistics priceStats = products.stream()
            .collect(Collectors.summarizingDouble(Product::getPrice));
        System.out.println("价格统计：" + priceStats);
    }
}
```

###### 4.5.3 分组收集器

```java
import java.util.*;
import java.util.stream.Collectors;

public class GroupingCollectorsDemo {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("iPhone", "手机", 8999),
            new Product("MacBook", "电脑", 12999),
            new Product("iPad", "平板", 3999),
            new Product("Samsung", "手机", 6999),
            new Product("ThinkPad", "电脑", 8999),
            new Product("Surface", "平板", 5999)
        );
      
        // groupingBy() - 按类别分组
        Map<String, List<Product>> byCategory = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory));
        System.out.println("按类别分组：");
        byCategory.forEach((category, productList) -> {
            System.out.println(category + ": " + productList);
        });
      
        // groupingBy() + counting() - 分组计数
        Map<String, Long> countByCategory = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory, Collectors.counting()));
        System.out.println("各类别产品数量：" + countByCategory);
      
        // groupingBy() + summingDouble() - 分组求和
        Map<String, Double> totalPriceByCategory = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory, 
                Collectors.summingDouble(Product::getPrice)));
        System.out.println("各类别总价格：" + totalPriceByCategory);
      
        // groupingBy() + averagingDouble() - 分组平均值
        Map<String, Double> avgPriceByCategory = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory, 
                Collectors.averagingDouble(Product::getPrice)));
        System.out.println("各类别平均价格：" + avgPriceByCategory);
      
        // partitioningBy() - 按条件分区（只有true/false两组）
        Map<Boolean, List<Product>> partitionByPrice = products.stream()
            .collect(Collectors.partitioningBy(p -> p.getPrice() > 7000));
        System.out.println("价格大于7000的产品：" + partitionByPrice.get(true));
        System.out.println("价格不大于7000的产品：" + partitionByPrice.get(false));
      
        // 多级分组
        Map<String, Map<Boolean, List<Product>>> multiLevel = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory,
                Collectors.partitioningBy(p -> p.getPrice() > 7000)));
        System.out.println("多级分组：" + multiLevel);
    }
}
```

#### 5. 并行流（Parallel Stream）

并行流可以利用多核处理器的优势，提高大数据量处理的性能。

##### 5.1 并行流基础

```java
import java.util.*;
import java.util.stream.IntStream;

public class ParallelStreamDemo {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= 1000000; i++) {
            numbers.add(i);
        }
      
        // 创建并行流的方式
        // 1. 从集合创建
        numbers.parallelStream().forEach(System.out::println);
      
        // 2. 从顺序流转换
        numbers.stream().parallel().forEach(System.out::println);
      
        // 3. 直接创建并行流
        IntStream.range(1, 1000).parallel().forEach(System.out::println);
      
        // 检查是否为并行流
        boolean isParallel = numbers.parallelStream().isParallel();
        System.out.println("是否为并行流：" + isParallel);
      
        // 转换为顺序流
        numbers.parallelStream().sequential().forEach(System.out::println);
    }
}
```

##### 5.2 并行流性能对比

```java
import java.util.*;
import java.util.stream.IntStream;

public class ParallelPerformanceDemo {
    public static void main(String[] args) {
        int size = 10000000;
        List<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= size; i++) {
            numbers.add(i);
        }
      
        // 顺序流性能测试
        long startTime = System.currentTimeMillis();
        long sequentialSum = numbers.stream()
            .mapToLong(Integer::longValue)
            .sum();
        long sequentialTime = System.currentTimeMillis() - startTime;
        System.out.println("顺序流结果：" + sequentialSum + "，耗时：" + sequentialTime + "ms");
      
        // 并行流性能测试
        startTime = System.currentTimeMillis();
        long parallelSum = numbers.parallelStream()
            .mapToLong(Integer::longValue)
            .sum();
        long parallelTime = System.currentTimeMillis() - startTime;
        System.out.println("并行流结果：" + parallelSum + "，耗时：" + parallelTime + "ms");
      
        // 性能提升比例
        double speedup = (double) sequentialTime / parallelTime;
        System.out.println("性能提升：" + String.format("%.2f", speedup) + "倍");
      
        // 复杂计算的并行处理
        startTime = System.currentTimeMillis();
        long complexSequential = IntStream.range(1, 1000000)
            .filter(n -> isPrime(n))
            .count();
        long complexSequentialTime = System.currentTimeMillis() - startTime;
        System.out.println("顺序流质数个数：" + complexSequential + "，耗时：" + complexSequentialTime + "ms");
      
        startTime = System.currentTimeMillis();
        long complexParallel = IntStream.range(1, 1000000)
            .parallel()
            .filter(n -> isPrime(n))
            .count();
        long complexParallelTime = System.currentTimeMillis() - startTime;
        System.out.println("并行流质数个数：" + complexParallel + "，耗时：" + complexParallelTime + "ms");
    }
  
    // 判断是否为质数（计算密集型操作）
    private static boolean isPrime(int n) {
        if (n < 2) return false;
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
}
```

##### 5.3 并行流注意事项

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class ParallelStreamCautionsDemo {
    public static void main(String[] args) {
        // 1. 线程安全问题
        List<Integer> unsafeList = new ArrayList<>(); // 线程不安全
        List<Integer> safeList = Collections.synchronizedList(new ArrayList<>()); // 线程安全
      
        // 错误示例：并行流操作非线程安全集合
        IntStream.range(1, 1000)
            .parallel()
            .forEach(unsafeList::add); // 可能导致数据丢失或异常
        System.out.println("非线程安全集合大小（可能不正确）：" + unsafeList.size());
      
        // 正确示例：使用线程安全集合
        IntStream.range(1, 1000)
            .parallel()
            .forEach(safeList::add);
        System.out.println("线程安全集合大小：" + safeList.size());
      
        // 2. 使用collect()而不是forEach()修改集合
        List<Integer> correctList = IntStream.range(1, 1000)
            .parallel()
            .boxed()
            .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
        System.out.println("使用collect()的集合大小：" + correctList.size());
      
        // 3. 共享变量问题
        final int[] counter = {0}; // 共享变量
        IntStream.range(1, 1000)
            .parallel()
            .forEach(i -> counter[0]++); // 线程不安全的操作
        System.out.println("共享变量计数（可能不正确）：" + counter[0]);
      
        // 正确做法：使用reduce()或collect()
        int correctCount = IntStream.range(1, 1000)
            .parallel()
            .reduce(0, (a, b) -> a + 1);
        System.out.println("正确的计数：" + correctCount);
      
        // 4. 何时使用并行流
        demonstrateWhenToUseParallel();
    }
  
    private static void demonstrateWhenToUseParallel() {
        System.out.println("\n=== 何时使用并行流 ===");
      
        // 适合并行：大数据量 + 计算密集型
        List<Integer> largeList = new ArrayList<>();
        for (int i = 1; i <= 1000000; i++) {
            largeList.add(i);
        }
      
        long start = System.currentTimeMillis();
        long sum1 = largeList.stream()
            .mapToLong(i -> heavyComputation(i))
            .sum();
        long time1 = System.currentTimeMillis() - start;
      
        start = System.currentTimeMillis();
        long sum2 = largeList.parallelStream()
            .mapToLong(i -> heavyComputation(i))
            .sum();
        long time2 = System.currentTimeMillis() - start;
      
        System.out.println("顺序流耗时：" + time1 + "ms");
        System.out.println("并行流耗时：" + time2 + "ms");
        System.out.println("并行流适合大数据量 + 计算密集型操作");
      
        // 不适合并行：小数据量或简单操作
        List<Integer> smallList = Arrays.asList(1, 2, 3, 4, 5);
      
        start = System.currentTimeMillis();
        smallList.stream().forEach(System.out::print);
        time1 = System.currentTimeMillis() - start;
      
        start = System.currentTimeMillis();
        smallList.parallelStream().forEach(System.out::print);
        time2 = System.currentTimeMillis() - start;
      
        System.out.println("\n小数据量时，并行流可能反而更慢（线程创建开销）");
    }
  
    private static long heavyComputation(int n) {
        // 模拟计算密集型操作
        long result = 0;
        for (int i = 0; i < 1000; i++) {
            result += Math.sqrt(n * i);
        }
        return result;
    }
}
```

#### 6. Optional与函数式编程

Optional是Java 8引入的容器类，在函数式编程中用于优雅地处理可能为空的值，避免空指针异常。

##### 6.1 Optional在函数式编程中的应用

```java
import java.util.*;

public class OptionalAdvancedDemo {
    public static void main(String[] args) {
        // orElse() - 提供默认值
        Optional<String> empty = Optional.empty();
        Optional<String> nonEmpty = Optional.of("Hello");
      
        String result1 = empty.orElse("默认值");
        String result2 = nonEmpty.orElse("默认值");
        System.out.println("empty.orElse(): " + result1);
        System.out.println("nonEmpty.orElse(): " + result2);
      
        // orElseGet() - 通过Supplier提供默认值（懒加载）
        String result3 = empty.orElseGet(() -> {
            System.out.println("执行Supplier");
            return "懒加载默认值";
        });
        String result4 = nonEmpty.orElseGet(() -> {
            System.out.println("不会执行这个Supplier");
            return "不会返回这个值";
        });
        System.out.println("empty.orElseGet(): " + result3);
        System.out.println("nonEmpty.orElseGet(): " + result4);
      
        // orElseThrow() - 抛出异常
        try {
            String result5 = empty.orElseThrow(() -> new RuntimeException("值为空"));
        } catch (RuntimeException e) {
            System.out.println("捕获异常: " + e.getMessage());
        }
      
        // map() - 转换Optional中的值
        Optional<String> name = Optional.of("john");
        Optional<String> upperName = name.map(String::toUpperCase);
        Optional<Integer> nameLength = name.map(String::length);
        System.out.println("转换为大写: " + upperName.orElse(""));
        System.out.println("名字长度: " + nameLength.orElse(0));
      
        // flatMap() - 扁平化映射
        Optional<String> address = Optional.of("北京市朝阳区");
        Optional<Optional<String>> nestedOptional = address.map(this::getCity);
        Optional<String> flatOptional = address.flatMap(this::getCity);
        System.out.println("嵌套Optional: " + nestedOptional);
        System.out.println("扁平化Optional: " + flatOptional.orElse(""));
      
        // filter() - 过滤Optional中的值
        Optional<Integer> number = Optional.of(42);
        Optional<Integer> evenNumber = number.filter(n -> n % 2 == 0);
        Optional<Integer> oddNumber = number.filter(n -> n % 2 == 1);
        System.out.println("偶数过滤: " + evenNumber.orElse(-1));
        System.out.println("奇数过滤: " + oddNumber.orElse(-1));
      
        // 链式调用
        Optional<String> result = Optional.of("  Hello World  ")
            .filter(s -> !s.trim().isEmpty())
            .map(String::trim)
            .map(String::toUpperCase)
            .filter(s -> s.startsWith("HELLO"));
        System.out.println("链式调用结果: " + result.orElse("未找到"));
    }
  
    private Optional<String> getCity(String address) {
        if (address.contains("北京")) {
            return Optional.of("北京");
        } else if (address.contains("上海")) {
            return Optional.of("上海");
        }
        return Optional.empty();
    }
}
```

#### 7. 函数式编程高级特性

##### 7.1 函数组合

函数组合允许将简单函数组合成复杂功能：

```java
import java.util.function.*;

public class FunctionCompositionDemo {
    public static void main(String[] args) {
        Function<String, String> addPrefix = s -> "前缀_" + s;
        Function<String, String> toUpper = String::toUpperCase;
        
        // compose() - 先执行参数函数，再执行当前函数
        Function<String, String> composed = toUpper.compose(addPrefix);
        System.out.println(composed.apply("test")); // 前缀_TEST
        
        // andThen() - 先执行当前函数，再执行参数函数  
        Function<String, String> pipeline = addPrefix.andThen(toUpper);
        System.out.println(pipeline.apply("test")); // 前缀_TEST
        
        // Predicate组合
        Predicate<Integer> isPositive = n -> n > 0;
        Predicate<Integer> isEven = n -> n % 2 == 0;
        
        Predicate<Integer> combined = isPositive.and(isEven); // 逻辑与
        System.out.println(combined.test(4)); // true
    }
}
```

##### 7.2 柯里化（Currying）

柯里化将多参数函数转换为单参数函数的链：

```java
import java.util.function.*;

public class CurryingDemo {
    public static void main(String[] args) {
        // 传统的多参数函数
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        
        // 柯里化：将多参数函数转换为单参数函数的链
        Function<Integer, Function<Integer, Integer>> curriedAdd = a -> b -> a + b;
        Function<Integer, Integer> add3 = curriedAdd.apply(3);
        System.out.println(add3.apply(4)); // 7
        
        // 三参数函数的柯里化
        Function<Integer, Function<Integer, Function<Integer, Integer>>> curriedAdd3 = 
            a -> b -> c -> a + b + c;
        System.out.println(curriedAdd3.apply(1).apply(2).apply(3)); // 6
    }
}
```

##### 7.3 记忆化（Memoization）

记忆化通过缓存函数结果来提高性能：

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.*;

public class MemoizationDemo {
    // 通用记忆化装饰器
    public static <T, R> Function<T, R> memoize(Function<T, R> function) {
        Map<T, R> cache = new ConcurrentHashMap<>();
        return input -> cache.computeIfAbsent(input, function);
    }
    
    public static void main(String[] args) {
        // 斐波那契数列示例
        Function<Integer, Long> fibonacci = new Function<Integer, Long>() {
            @Override
            public Long apply(Integer n) {
                if (n <= 1) return (long) n;
                return this.apply(n - 1) + this.apply(n - 2);
            }
        };
        
        Function<Integer, Long> memoizedFibonacci = memoize(fibonacci);
        System.out.println(memoizedFibonacci.apply(40)); // 缓存结果
    }
}
```

#### 8. 函数式编程最佳实践

##### 8.1 不可变性（Immutability）

不可变对象避免副作用，提高代码安全性：

```java
import java.util.*;

// 不可变的Person类
final class ImmutablePerson {
    private final String name;
    private final int age;
  
    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }
  
    public String getName() { return name; }
    public int getAge() { return age; }
  
    // 返回新对象而不是修改当前对象
    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(this.name, newAge);
    }
}

public class ImmutabilityDemo {
    public static void main(String[] args) {
        ImmutablePerson person = new ImmutablePerson("Alice", 25);
        ImmutablePerson olderPerson = person.withAge(26);
        
        System.out.println("原始: " + person.getAge()); // 25
        System.out.println("新的: " + olderPerson.getAge()); // 26
    }
}
```

##### 8.2 纯函数（Pure Functions）

纯函数特征：
1. 相同输入总是产生相同输出
2. 没有副作用（不修改外部状态）

```java
import java.util.function.Function;

public class PureFunctionDemo {
    // 非纯函数：有副作用
    private static int counter = 0;
    public static int impureAdd(int a, int b) {
        counter++; // 副作用：修改外部状态
        return a + b;
    }
  
    // 纯函数：无副作用
    public static int pureAdd(int a, int b) {
        return a + b;
    }
  
    // 纯函数的组合
    public static Function<Integer, Integer> addTen = x -> x + 10;
    public static Function<Integer, Integer> multiplyByTwo = x -> x * 2;
  
    public static void main(String[] args) {
        // 纯函数调用
        System.out.println(pureAdd(2, 3)); // 5
        System.out.println(pureAdd(2, 3)); // 5，相同输入总是相同输出
      
        // 函数组合
        Function<Integer, Integer> combined = addTen.andThen(multiplyByTwo);
        System.out.println(combined.apply(5)); // (5+10)*2 = 30
    }
}
```

