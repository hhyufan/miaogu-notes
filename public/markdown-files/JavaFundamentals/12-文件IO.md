# 文件IO

#### 1. File类概述

##### 1.1 File类介绍

`File类`是Java中处理 `文件和文件夹`的核心类

- **功能**：只能对 `文件本身`进行操作，`内容读写`需要使用 `IO流`
- **作用**：创建、删除、重命名文件和目录
- **位置**：`java.io.File`

```java
import java.io.File;
import java.io.IOException;

public class FileDemo {
    public static void main(String[] args) throws IOException {
        // 创建File对象
        File file = new File("test.txt");
  
        // 判断文件是否存在
        if (!file.exists()) {
            // 创建新文件
            boolean created = file.createNewFile();
            System.out.println("文件创建：" + created);
        }
  
        System.out.println("文件名：" + file.getName());
        System.out.println("绝对路径：" + file.getAbsolutePath());
    }
}
```

##### 1.2 路径概念

###### 1.2.1 盘符

- **Windows**：字母 + 冒号，例如 `"C:"`
- **Linux**：无盘符，使用挂载点，以 `/`开头

###### 1.2.2 分隔符

```java
public class PathSeparatorDemo {
    public static void main(String[] args) {
        // 不同操作系统的分隔符
        System.out.println("系统分隔符：" + File.separator);
  
        // 推荐使用方式
        String path1 = "root" + File.separator + "data" + File.separator + "file.txt";
  
        // 使用String.join方法
        String path2 = String.join(File.separator, "root", "data", "file.txt");
  
        System.out.println("路径1：" + path1);
        System.out.println("路径2：" + path2);
  
        // 直接使用斜杠（推荐）
        File file = new File("root/data/file.txt");
    }
}
```

###### 1.2.3 相对路径和绝对路径

```java
import java.io.File;

public class PathTypeDemo {
    public static void main(String[] args) {
        // 相对路径
        File relativeFile1 = new File("./Documents/file.txt");  // 当前目录
        File relativeFile2 = new File("Documents/file.txt");    // 省略./
        File relativeFile3 = new File("../Documents/file.txt"); // 上级目录
  
        // 绝对路径
        File absoluteFileWin = new File("C:\\Users\\username\\Documents\\file.txt");
        File absoluteFileLinux = new File("/home/username/Documents/file.txt");
  
        System.out.println("相对路径1：" + relativeFile1.getPath());
        System.out.println("相对路径2：" + relativeFile2.getPath());
        System.out.println("相对路径3：" + relativeFile3.getPath());
  
        // 获取绝对路径
        System.out.println("转换为绝对路径：" + relativeFile1.getAbsolutePath());
    }
}
```

#### 2. File类API

##### 2.1 路径获取方法

```java
import java.io.File;

public class FilePathDemo {
    public static void main(String[] args) {
        File file = new File("Documents/projects/demo.txt");
  
        // 获得绝对路径
        String absolutePath = file.getAbsolutePath();
        System.out.println("绝对路径：" + absolutePath);
  
        // 获得父目录路径
        String parent = file.getParent();
        System.out.println("父目录路径：" + parent);
  
        // 获得文件名（包括后缀名）
        String name = file.getName();
        System.out.println("文件名：" + name);
  
        // 获得父目录File对象
        File parentFile = file.getParentFile();
        System.out.println("父目录对象：" + parentFile);
  
        // 获得路径
        String path = file.getPath();
        System.out.println("路径：" + path);
    }
}
```

##### 2.2 文件状态判断

```java
import java.io.File;
import java.io.IOException;

public class FileStatusDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("test.txt");
        File directory = new File("testDir");
  
        // 创建文件和目录用于测试
        file.createNewFile();
        directory.mkdir();
  
        // 判断是否存在
        boolean exists = file.exists();
        System.out.println("文件存在：" + exists);
  
        // 判断是否是目录
        boolean isDirectory = file.isDirectory();
        System.out.println("是目录：" + isDirectory);
  
        // 判断是否是文件
        boolean isFile = file.isFile();
        System.out.println("是文件：" + isFile);
  
        // 获得文件长度（字节）
        long length = file.length();
        System.out.println("文件大小：" + length + " 字节");
  
        // 判断是否可读
        boolean canRead = file.canRead();
        System.out.println("可读：" + canRead);
  
        // 判断是否可写
        boolean canWrite = file.canWrite();
        System.out.println("可写：" + canWrite);
  
        // 判断是否隐藏
        boolean isHidden = file.isHidden();
        System.out.println("隐藏文件：" + isHidden);
    }
}
```

#### 3. 文件操作

##### 3.1 文件创建、删除、重命名

```java
import java.io.File;
import java.io.IOException;

public class FileOperationDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("./Documents/file.txt");
  
        // 创建文件
        boolean created = file.createNewFile();
        if (created) {
            System.out.println("文件创建成功");
        } else {
            System.out.println("文件已存在，创建失败");
        }
  
        // 删除文件
        boolean deleted = file.delete();
        if (deleted) {
            System.out.println("文件删除成功");
        } else {
            System.out.println("文件不存在，删除失败");
        }
  
        // 重新创建文件用于重命名演示
        file.createNewFile();
  
        // 重命名文件
        File newFile = new File("./Documents/file2.txt");
        boolean renamed = file.renameTo(newFile);
        if (renamed) {
            System.out.println("文件重命名成功");
        } else {
            System.out.println("文件重命名失败");
        }
    }
}
```

#### 4. 目录操作

##### 4.1 目录创建、删除、重命名

```java
import java.io.File;

public class DirectoryOperationDemo {
    public static void main(String[] args) {
        File folder = new File("./Documents/folder");
        File multiFolder = new File("./Documents/level1/level2/level3");
  
        // 创建单层目录
        boolean created = folder.mkdir();
        if (created) {
            System.out.println("单层目录创建成功");
        } else {
            System.out.println("目录已存在或创建失败");
        }
  
        // 创建多层目录
        boolean createdMulti = multiFolder.mkdirs();
        if (createdMulti) {
            System.out.println("多层目录创建成功");
        } else {
            System.out.println("目录已存在或创建失败");
        }
  
        // 删除目录（只能删除空目录）
        boolean deleted = folder.delete();
        if (deleted) {
            System.out.println("目录删除成功");
        } else {
            System.out.println("目录不为空或删除失败");
        }
  
        // 重命名目录
        File newFolder = new File("./Documents/newFolder");
        folder.mkdir(); // 重新创建
        boolean renamed = folder.renameTo(newFolder);
        if (renamed) {
            System.out.println("目录重命名成功");
        }
    }
}
```

##### 4.2 目录遍历

```java
import java.io.File;
import java.io.FilenameFilter;
import java.io.FileFilter;

public class DirectoryTraversalDemo {
    public static void main(String[] args) {
        File directory = new File("./Documents");
      
        // 返回目录中子文件、子目录的文件名数组
        String[] fileNames = directory.list();
        if (fileNames != null) {
            System.out.println("文件名数组：");
            for (String fileName : fileNames) {
                System.out.println(fileName);
            }
        }
      
        // 返回目录中子文件、子目录的File对象数组
        File[] files = directory.listFiles();
        if (files != null) {
            System.out.println("\nFile对象数组：");
            for (File file : files) {
                System.out.println(file.getName() + " - " + 
                    (file.isDirectory() ? "目录" : "文件"));
            }
        }
      
        // 使用FilenameFilter过滤器
        String[] txtFiles = directory.list(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".txt");
            }
        });
      
        // Lambda表达式简化
        String[] txtFilesLambda = directory.list((dir, name) -> name.endsWith(".txt"));
      
        // 使用FileFilter过滤器
        File[] largeFiles = directory.listFiles(new FileFilter() {
            @Override
            public boolean accept(File pathname) {
                return pathname.isFile() && pathname.length() > 1024;
            }
        });
      
        // Lambda表达式简化
        File[] largeFilesLambda = directory.listFiles(file -> 
            file.isFile() && file.length() > 1024);
    }
}
```

##### 4.3 递归遍历

```java
import java.io.File;

public class RecursiveTraversalDemo {
    public static void main(String[] args) {
        File directory = new File("./Documents");
        traverseDirectory(directory, 0);
    }
  
    /**
     * 递归遍历目录
     * @param directory 要遍历的目录
     * @param level 层级深度
     */
    public static void traverseDirectory(File directory, int level) {
        // 递归终止条件
        if (!directory.exists() || !directory.isDirectory()) {
            return;
        }
      
        // 打印当前目录
        String indent = "  ".repeat(level);
        System.out.println(indent + "[目录] " + directory.getName());
      
        // 获取目录下的所有文件和子目录
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    // 递归调用自身方法
                    traverseDirectory(file, level + 1);
                } else {
                    System.out.println(indent + "  [文件] " + file.getName());
                }
            }
        }
    }
}
```

#### 5. I/O流概述

##### 5.1 I/O流介绍

- **I** - Input 输入
- **O** - Output 输出
- **Stream** - 流
- **作用**：用于数据的传输

##### 5.2 I/O流体系划分

###### 5.2.1 按传输方向划分

- **输入流（InputStream）**：从数据源读取数据到程序
- **输出流（OutputStream）**：从程序写入数据到目标

###### 5.2.2 按传输单位划分

- **字节流**：以字节为单位传输，可以处理任何类型的文件
- **字符流**：以字符为单位传输，专门处理文本文件

###### 5.2.3 按传输方式划分

- **原始流/节点流**：每次传输1字节/1字符，传输效率低
- **处理流**：加工处理原始流/节点流，传输效率高

##### 5.3 I/O流基类

```java
// 四大基类
InputStream    // 字节输入流
OutputStream   // 字节输出流
Reader         // 字符输入流
Writer         // 字符输出流
```

#### 6. 文件流

##### 6.1 文件流类的划分

- **FileInputStream**：文件字节输入流
- **FileOutputStream**：文件字节输出流
- **FileReader**：文件字符输入流
- **FileWriter**：文件字符输出流

**特点**：

- 文件流属于节点流
- 用于文件读写操作
- FileWriter第二个参数为true时，追加写入
- 文件不存在时自动创建

##### 6.2 基本操作流程

1. **创建流**
2. **数据的读/写**
3. **关闭流**

```java
import java.io.*;

public class FileStreamDemo {
    public static void main(String[] args) {
        // 文件字节流示例
        fileByteStreamDemo();
      
        // 文件字符流示例
        fileCharStreamDemo();
    }
  
    /**
     * 文件字节流示例
     */
    public static void fileByteStreamDemo() {
        FileInputStream fis = null;
        FileOutputStream fos = null;
      
        try {
            // 1. 创建流
            fis = new FileInputStream("source.txt");
            fos = new FileOutputStream("target.txt");
          
            // 2. 数据读写
            int data;
            while ((data = fis.read()) != -1) {
                fos.write(data);
            }
          
            System.out.println("文件复制完成");
          
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭流
            try {
                if (fis != null) fis.close();
                if (fos != null) fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
  
    /**
     * 文件字符流示例
     */
    public static void fileCharStreamDemo() {
        // 使用try-with-resources自动关闭流
        try (FileReader fr = new FileReader("input.txt");
             FileWriter fw = new FileWriter("output.txt", true)) { // true表示追加写入
          
            // 字符数组缓冲读取
            char[] buffer = new char[1024];
            int length;
          
            while ((length = fr.read(buffer)) != -1) {
                fw.write(buffer, 0, length);
            }
          
            System.out.println("文本文件处理完成");
          
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 7. 处理流

##### 7.1 处理流概述

**处理流**是包裹节点流来增强功能的流，它们不直接连接到数据源，而是对其他流进行包装以提供额外的功能。

**特点**：

- 包裹节点流增强功能
- 提高传输效率
- 提供更丰富的操作方法
- 可以层层包装

#### 8. 缓冲流

##### 8.1 缓冲流概述

缓冲流通过缓存数据来减少IO次数，从而提高传输效率。

**分类**：

- **任意文件**：
  - `BufferedInputStream`：字节输入缓冲流
  - `BufferedOutputStream`：字节输出缓冲流
- **用于文档**：
  - `BufferedReader`：字符输入缓冲流
  - `BufferedWriter`：字符输出缓冲流

##### 8.2 字节缓冲流

```java
// 基本语法
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("file.txt"));
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("output.txt"));

// 文件复制示例
try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("source.txt"));
     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("target.txt"))) {
  
    byte[] buffer = new byte[8192];
    int bytesRead;
    while ((bytesRead = bis.read(buffer)) != -1) {
        bos.write(buffer, 0, bytesRead);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

##### 8.3 字符缓冲流

```java
// 基本语法
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"));

// 写入文本
try (BufferedWriter bw = new BufferedWriter(new FileWriter("test.txt"))) {
    bw.write("第一行文本");
    bw.newLine(); // 写入换行符
    bw.write("第二行文本");
} catch (IOException e) {
    e.printStackTrace();
}

// 按行读取
try (BufferedReader br = new BufferedReader(new FileReader("test.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 9. 序列化流/对象流

##### 9.1 序列化概述

**序列化**：将Java对象以二进制形式写入文件或网络传输
**反序列化**：将二进制文件读取出Java对象

**分类**：

- `ObjectInputStream`：对象输入流，实现反序列化
- `ObjectOutputStream`：对象输出流，实现序列化

##### 9.2 序列化要求

1. **实现Serializable接口**
2. **提供getter/setter方法**（可选，但推荐）
3. **使用对象输入/输出流**
4. **使用readObject/writeObject方法**

##### 9.3 基本序列化示例

```java
// 可序列化的类
class Student implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
  
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    // getter/setter方法...
}

// 序列化对象
try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("student.ser"))) {
    Student student = new Student("张三", 20);
    oos.writeObject(student);
} catch (IOException e) {
    e.printStackTrace();
}

// 反序列化对象
try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("student.ser"))) {
    Student student = (Student) ois.readObject();
    System.out.println(student);
} catch (IOException | ClassNotFoundException e) {
    e.printStackTrace();
}
```

##### 9.4 序列化集合对象

```java
// 序列化集合
List<Student> students = Arrays.asList(
    new Student("张三", 20),
    new Student("李四", 21)
);

try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("students.ser"))) {
    oos.writeObject(students);
} catch (IOException e) {
    e.printStackTrace();
}

// 反序列化集合
try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("students.ser"))) {
    List<Student> students = (List<Student>) ois.readObject();
    students.forEach(System.out::println);
} catch (IOException | ClassNotFoundException e) {
    e.printStackTrace();
}
```

##### 9.5 序列化注意事项

**关键字段说明**：

- `transient`：标记的字段不会被序列化
- `static`：静态字段不会被序列化
- `serialVersionUID`：版本控制，确保兼容性

```java
class Person implements Serializable {
    private static final long serialVersionUID = 1L; // 版本控制
  
    private String name;
    private transient String password; // 不会被序列化
    private static String company = "公司"; // 不会被序列化
  
    // 自定义序列化方法（可选）
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject(); // 默认序列化
        // 自定义逻辑...
    }
  
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject(); // 默认反序列化
        // 自定义逻辑...
    }
}
```

#### 10. NIO

##### 10.1 NIO概述

**NIO**（New I/O）在Java 1.4中引入，提供了高速、面向块的I/O操作。

**核心组件**：

- **通道（Channel）**
- **缓冲区（Buffer）**
- **选择器（Selector）**

##### 10.2 缓冲区（Buffer）

###### 10.2.1 Buffer概述

- **数据的容器**：缓冲区是一个数组
- **作用**：在NIO中，所有数据都是通过Buffer处理的

###### 10.2.2 Buffer分类

```java
// 各种类型的缓冲区
ByteBuffer     // 字节缓冲区（最常用）
CharBuffer     // 字符缓冲区
ShortBuffer    // 短整型缓冲区
IntBuffer      // 整型缓冲区
LongBuffer     // 长整型缓冲区
FloatBuffer    // 浮点型缓冲区
DoubleBuffer   // 双精度型缓冲区
```

###### 10.2.3 Buffer核心属性与方法

```java
import java.nio.ByteBuffer;

public class BufferDemo {
    public static void main(String[] args) {
        // 创建缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(10);
        
        // 核心属性
        System.out.println("容量(Capacity): " + buffer.capacity()); // 缓冲区最大数据容量
        System.out.println("位置(Position): " + buffer.position()); // 下一个要被读或写的元素的索引
        System.out.println("上限(Limit): " + buffer.limit());       // 第一个不能被读或写的元素的索引
        
        // 写入数据
        buffer.put("Hello".getBytes());
        System.out.println("写入后 Position: " + buffer.position());
        
        // flip(): 将limit设为position，position设为0，为从Buffer读取数据做准备
        buffer.flip();
        System.out.println("flip后 Position: " + buffer.position());
        System.out.println("flip后 Limit: " + buffer.limit());
        
        // 读取数据
        byte[] data = new byte[buffer.remaining()];
        buffer.get(data);
        System.out.println("读取的数据: " + new String(data));
        
        // rewind(): 将position设为0，limit不变，为重新读取Buffer中的数据做准备
        buffer.rewind();
        
        // clear(): 将position设为0，limit设为capacity，为向Buffer写入数据做准备
        buffer.clear();
        
        // compact(): 将所有未读的数据复制到Buffer起始处，为继续写入数据做准备
        buffer.put("World".getBytes());
        buffer.flip();
        buffer.get(); // 读取一个字节
        buffer.compact(); // 压缩缓冲区
    }
}
```

##### 10.3 Channel（通道）

###### 10.3.1 Channel概述

**Channel**类似于传统的"流"，但可以双向读写（流是单向的），并且与Buffer配合，实现高效的块传输。

###### 10.3.2 主要实现类

**FileChannel示例**：

```java
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class FileChannelDemo {
    public static void main(String[] args) {
        try (RandomAccessFile file = new RandomAccessFile("test.txt", "rw");
             FileChannel channel = file.getChannel()) {
            
            // 写入数据
            ByteBuffer buffer = ByteBuffer.allocate(48);
            buffer.put("Hello NIO FileChannel".getBytes());
            buffer.flip();
            
            // write(): 将缓冲区数据写入通道
            channel.write(buffer);
            
            // 重置到文件开始位置
            channel.position(0);
            
            // 读取数据
            buffer.clear();
            int bytesRead = channel.read(buffer); // read(): 从通道读取数据到缓冲区
            
            if (bytesRead != -1) {
                buffer.flip();
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                System.out.println("读取的数据: " + new String(data));
            }
            
            // position(): 获取或设置文件位置
            System.out.println("当前位置: " + channel.position());
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**高效文件传输**：

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.nio.channels.FileChannel;

public class FileTransferDemo {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("source.txt");
             FileOutputStream fos = new FileOutputStream("target.txt");
             FileChannel sourceChannel = fis.getChannel();
             FileChannel targetChannel = fos.getChannel()) {
            
            // transferTo(): 高效的文件通道间传输，适用于大文件
            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);
            
            // 或者使用 transferFrom()
            // targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());
            
            System.out.println("文件传输完成");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**网络通道**：

```java
// SocketChannel: 用于TCP网络通信（客户端）
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress("localhost", 8080));

// ServerSocketChannel: 用于监听TCP连接（服务器端）
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind(new InetSocketAddress(8080));
SocketChannel clientChannel = serverChannel.accept();

// DatagramChannel: 用于UDP网络通信
DatagramChannel datagramChannel = DatagramChannel.open();
```

##### 10.4 Selector（选择器）

###### 10.4.1 Selector概述

**Selector**是NIO实现非阻塞I/O多路复用的核心，允许一个线程管理多个Channel。

###### 10.4.2 使用方法

```java
import java.nio.channels.*;
import java.nio.ByteBuffer;
import java.net.InetSocketAddress;
import java.util.Iterator;
import java.util.Set;

public class SelectorDemo {
    public static void main(String[] args) {
        try {
            // 1. 创建Selector
            Selector selector = Selector.open();
            
            // 2. 创建ServerSocketChannel并设置为非阻塞模式
            ServerSocketChannel serverChannel = ServerSocketChannel.open();
            serverChannel.configureBlocking(false);
            serverChannel.bind(new InetSocketAddress(8080));
            
            // 3. 将Channel注册到Selector上，监听ACCEPT事件
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);
            
            System.out.println("服务器启动，监听端口8080");
            
            // 4. 事件循环
            while (true) {
                // select()方法会阻塞，直到有注册的通道事件就绪
                int readyChannels = selector.select();
                
                if (readyChannels == 0) continue;
                
                // 5. 获取就绪的SelectionKey集合
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
                
                while (keyIterator.hasNext()) {
                    SelectionKey key = keyIterator.next();
                    
                    if (key.isAcceptable()) {
                        // 处理连接事件
                        handleAccept(key, selector);
                    } else if (key.isReadable()) {
                        // 处理读事件
                        handleRead(key);
                    }
                    
                    keyIterator.remove();
                }
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private static void handleAccept(SelectionKey key, Selector selector) throws Exception {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        SocketChannel clientChannel = serverChannel.accept();
        clientChannel.configureBlocking(false);
        clientChannel.register(selector, SelectionKey.OP_READ);
        System.out.println("客户端连接: " + clientChannel.getRemoteAddress());
    }
    
    private static void handleRead(SelectionKey key) throws Exception {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        
        int bytesRead = clientChannel.read(buffer);
        if (bytesRead > 0) {
            buffer.flip();
            byte[] data = new byte[buffer.remaining()];
            buffer.get(data);
            System.out.println("收到数据: " + new String(data));
        } else if (bytesRead < 0) {
            clientChannel.close();
            key.cancel();
        }
    }
}
```

##### 10.5 SelectionKey（选择器键）

**SelectionKey**表示一个Channel在Selector上的注册关系，包含就绪的事件集合、对应的Channel和Selector。

```java
// 常用方法
key.isReadable();    // 检查是否准备好进行读取操作
key.isWritable();    // 检查是否准备好进行写入操作
key.isAcceptable();  // 检查ServerSocketChannel是否准备好接受新连接
key.isConnectable(); // 检查SocketChannel是否完成连接操作

key.channel();       // 返回与此键关联的通道对象
key.selector();      // 返回创建此键的选择器对象
```

#### 11. NIO.2

##### 11.1 NIO.2概述

**NIO.2**在Java 7中引入，对旧的Java I/O进行了全面现代化升级，提供了更强大、更直观的API。

**核心概念与优势**：

- **统一的路径抽象（Path）**
- **目录树遍历（FileVisitor）**
- **异步I/O（AsynchronousFileChannel）**
- **文件更改通知（WatchService）**
- **实用方法（Files）**
- **文件属性访问（Attributes）**

##### 11.2 Path接口

###### 11.2.1 Path概述

**Path**是NIO.2的基石，代表一个文件系统路径，可以是绝对的，也可以是相对的。

```java
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.Files;

public class PathDemo {
    public static void main(String[] args) {
        // 获取Path对象：使用Paths.get()工厂方法
        Path path = Paths.get("Documents", "projects", "demo.txt");
        
        // 常用方法
        System.out.println("文件名: " + path.getFileName());     // 获取文件名部分
        System.out.println("父目录: " + path.getParent());       // 获取父目录路径
        System.out.println("根路径: " + path.getRoot());         // 获取根路径
        
        // 路径操作
        Path other = Paths.get("config.properties");
        Path resolved = path.resolve(other);                    // 将两个路径拼接起来
        System.out.println("拼接路径: " + resolved);
        
        Path relativePath = path.relativize(Paths.get("Documents/data/file.txt")); // 计算相对路径
        System.out.println("相对路径: " + relativePath);
        
        Path normalized = Paths.get("Documents/../Documents/./demo.txt").normalize(); // 移除冗余部分
        System.out.println("规范化路径: " + normalized);
        
        Path absolutePath = path.toAbsolutePath();             // 转换为绝对路径
        System.out.println("绝对路径: " + absolutePath);
        
        // 转换为旧的File对象（用于兼容旧代码）
        java.io.File file = path.toFile();
        
        // 检查路径是否存在（属于Files类）
        boolean exists = Files.exists(path);
        System.out.println("路径存在: " + exists);
    }
}
```

##### 11.3 Files文件操作

###### 11.3.1 检查文件状态

```java
import java.nio.file.*;

public class FilesStatusDemo {
    public static void main(String[] args) {
        Path path = Paths.get("test.txt");
        
        // 检查文件状态
        System.out.println("文件存在: " + Files.exists(path));
        System.out.println("可读: " + Files.isReadable(path));
        System.out.println("是目录: " + Files.isDirectory(path));
        System.out.println("是常规文件: " + Files.isRegularFile(path));
    }
}
```

###### 11.3.2 创建文件/目录

```java
import java.nio.file.*;

public class FilesCreateDemo {
    public static void main(String[] args) {
        try {
            // 创建文件
            Path file = Paths.get("newfile.txt");
            Files.createFile(file);
            
            // 创建目录
            Path dir = Paths.get("newdir");
            Files.createDirectory(dir);
            
            // 创建多级目录
            Path multiDir = Paths.get("level1/level2/level3");
            Files.createDirectories(multiDir);
            
            System.out.println("文件和目录创建完成");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

###### 11.3.3 读取文件

```java
import java.nio.file.*;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.io.BufferedReader;

public class FilesReadDemo {
    public static void main(String[] args) {
        Path path = Paths.get("test.txt");
        
        try {
            // 一次性读取所有文件内容，返回字节数组
            byte[] bytes = Files.readAllBytes(path);
            System.out.println("字节数组: " + new String(bytes));
            
            // 一次性读取所有行，返回List<String>
            List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8);
            System.out.println("所有行: " + lines);
            
            // 流式处理大文件
            try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println("行: " + line);
                }
            }
            
            // 处理二进制文件
            try (var inputStream = Files.newInputStream(path)) {
                // 处理二进制数据
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

###### 11.3.4 写入文件

```java
import java.nio.file.*;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.io.BufferedWriter;

public class FilesWriteDemo {
    public static void main(String[] args) {
        Path path = Paths.get("output.txt");
        
        try {
            // 写入字符串列表
            List<String> lines = Arrays.asList("第一行", "第二行", "第三行");
            Files.write(path, lines, StandardCharsets.UTF_8, 
                       StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            
            // 追加写入
            Files.write(path, "\n追加的行".getBytes(), StandardOpenOption.APPEND);
            
            // 缓冲写入
            try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8, 
                                                                StandardOpenOption.APPEND)) {
                writer.write("\n缓冲写入的行");
            }
            
            // 二进制写入
            try (var outputStream = Files.newOutputStream(path, StandardOpenOption.APPEND)) {
                outputStream.write("\n二进制写入".getBytes());
            }
            
            System.out.println("文件写入完成");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**OpenOption常用值**：

```java
// 读写模式
StandardOpenOption.READ
StandardOpenOption.WRITE

// 创建选项
StandardOpenOption.CREATE          // 如果文件不存在则创建
StandardOpenOption.CREATE_NEW      // 创建新文件，如果已存在则失败

// 写入选项
StandardOpenOption.TRUNCATE_EXISTING // 打开时清空文件
StandardOpenOption.APPEND            // 在文件末尾追加
```

###### 11.3.5 复制、移动、删除

```java
import java.nio.file.*;

public class FilesOperationDemo {
    public static void main(String[] args) {
        try {
            Path source = Paths.get("source.txt");
            Path target = Paths.get("target.txt");
            
            // 复制文件
            Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
            
            // 移动文件
            Path moved = Paths.get("moved.txt");
            Files.move(target, moved, StandardCopyOption.REPLACE_EXISTING);
            
            // 重命名文件
            Path renamed = moved.resolveSibling("renamed.txt");
            Files.move(moved, renamed);
            
            // 删除文件
            Files.delete(renamed);              // 如果文件不存在，抛出NoSuchFileException
            boolean deleted = Files.deleteIfExists(source); // 安全删除，不存在返回false
            
            System.out.println("文件操作完成，删除结果: " + deleted);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

###### 11.3.6 获取文件属性

```java
import java.nio.file.*;
import java.nio.file.attribute.*;

public class FilesAttributeDemo {
    public static void main(String[] args) {
        Path path = Paths.get("test.txt");
        
        try {
            // 基本属性
            long size = Files.size(path);                           // 文件大小
            FileTime lastModified = Files.getLastModifiedTime(path); // 上次修改时间
            String owner = Files.getOwner(path).getName();          // 拥有者名称
            
            System.out.println("文件大小: " + size + " 字节");
            System.out.println("修改时间: " + lastModified);
            System.out.println("拥有者: " + owner);
            
            // 获取所有基本属性
            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
            System.out.println("创建时间: " + attrs.creationTime());
            System.out.println("是否为目录: " + attrs.isDirectory());
            System.out.println("是否为常规文件: " + attrs.isRegularFile());
            
            // POSIX系统属性（Linux/Unix）
            if (FileSystems.getDefault().supportedFileAttributeViews().contains("posix")) {
                PosixFileAttributes posixAttrs = Files.readAttributes(path, PosixFileAttributes.class);
                System.out.println("权限: " + PosixFilePermissions.toString(posixAttrs.permissions()));
                System.out.println("组: " + posixAttrs.group().getName());
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

###### 11.3.7 遍历目录

```java
import java.nio.file.*;
import java.util.stream.Stream;

public class FilesTraversalDemo {
    public static void main(String[] args) {
        Path dir = Paths.get(".");
        
        try {
            // 创建目录流，用于迭代指定目录的直接子项
            System.out.println("=== 直接子项 ===");
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
                for (Path entry : stream) {
                    System.out.println(entry.getFileName());
                }
            }
            
            // 使用惰性流操作遍历，返回一个惰性填充的Stream<Path>
            System.out.println("\n=== 递归遍历（Stream） ===");
            try (Stream<Path> paths = Files.walk(dir, 2)) { // 最大深度为2
                paths.filter(Files::isRegularFile)
                     .forEach(System.out::println);
            }
            
            // 使用访问者模式递归遍历目录树
            System.out.println("\n=== 访问者模式遍历 ===");
            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                    System.out.println("文件: " + file);
                    return FileVisitResult.CONTINUE;
                }
                
                @Override
                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                    System.out.println("进入目录: " + dir);
                    return FileVisitResult.CONTINUE;
                }
            });
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

##### 11.4 异步I/O（AsynchronousFileChannel）

```java
import java.nio.file.*;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.channels.CompletionHandler;
import java.nio.ByteBuffer;
import java.util.concurrent.Future;

public class AsyncFileChannelDemo {
    public static void main(String[] args) {
        Path path = Paths.get("async_test.txt");
        
        try {
            // 打开异步文件通道
            AsynchronousFileChannel afc = AsynchronousFileChannel.open(path, 
                StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ);
            
            // 异步写入
            ByteBuffer writeBuffer = ByteBuffer.wrap("Hello Async I/O".getBytes());
            afc.write(writeBuffer, 0, "写入操作", new CompletionHandler<Integer, String>() {
                @Override
                public void completed(Integer result, String attachment) {
                    System.out.println(attachment + "完成，写入字节数: " + result);
                    
                    // 异步读取
                    ByteBuffer readBuffer = ByteBuffer.allocate(100);
                    afc.read(readBuffer, 0, "读取操作", new CompletionHandler<Integer, String>() {
                        @Override
                        public void completed(Integer result, String attachment) {
                            System.out.println(attachment + "完成，读取字节数: " + result);
                            readBuffer.flip();
                            byte[] data = new byte[readBuffer.remaining()];
                            readBuffer.get(data);
                            System.out.println("读取内容: " + new String(data));
                            
                            try {
                                afc.close();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                        
                        @Override
                        public void failed(Throwable exc, String attachment) {
                            System.out.println(attachment + "失败: " + exc.getMessage());
                        }
                    });
                }
                
                @Override
                public void failed(Throwable exc, String attachment) {
                    System.out.println(attachment + "失败: " + exc.getMessage());
                }
            });
            
            // 使用Future方式
            ByteBuffer buffer = ByteBuffer.wrap("\nFuture方式写入".getBytes());
            Future<Integer> writeFuture = afc.write(buffer, 17);
            System.out.println("Future写入结果: " + writeFuture.get() + " 字节");
            
            // 文件操作
            System.out.println("文件大小: " + afc.size());
            System.out.println("通道是否打开: " + afc.isOpen());
            
            // 强制数据写入磁盘
            afc.force(true); // true: 同步文件内容+元数据，false: 只同步内容
            
            // 保持主线程运行，等待异步操作完成
            Thread.sleep(1000);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

##### 11.5 文件系统监视（WatchService）

```java
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

public class WatchServiceDemo {
    public static void main(String[] args) {
        Path dir = Paths.get(".");
        
        try {
            // 1. 获取文件系统的WatchService
            WatchService watchService = FileSystems.getDefault().newWatchService();
            
            // 注册监听事件
            dir.register(watchService, 
                StandardWatchEventKinds.ENTRY_CREATE,
                StandardWatchEventKinds.ENTRY_DELETE,
                StandardWatchEventKinds.ENTRY_MODIFY);
            
            System.out.println("开始监控目录: " + dir.toAbsolutePath());
            
            // 2. 监控循环
            while (true) {
                WatchKey key = watchService.take(); // 阻塞等待事件
                
                // 3. 遍历获取所有事件
                for (WatchEvent<?> event : key.pollEvents()) {
                    WatchEvent.Kind<?> kind = event.kind(); // 获取事件类型
                    Path fileName = (Path) event.context();  // 获取文件的Path对象
                    
                    System.out.println("事件类型: " + kind + ", 文件: " + fileName);
                    
                    if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
                        System.out.println("文件创建: " + fileName);
                    } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
                        System.out.println("文件删除: " + fileName);
                    } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
                        System.out.println("文件修改: " + fileName);
                    }
                }
                
                // 4. 重置key，继续监控
                boolean valid = key.reset();
                
                // 5. 非法情况退出
                if (!valid) {
                    System.out.println("监控已停止");
                    break;
                }
            }
            
            // 6. 循环退出后关闭
            watchService.close();
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
