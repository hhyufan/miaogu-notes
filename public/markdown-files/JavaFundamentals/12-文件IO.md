# Java文件IO

![文件IO](images\文件IO.png)

#### 1. File类概述

##### 1.1 File类介绍

`File类`是Java中处理 `文件和文件夹`的核心类

- **功能**：只能对 `文件本身`进行操作，`内容读写`需要使用 `IO流`
- **作用**：创建、删除、重命名文件和目录
- **位置**：`java.io.File`

```java
import java.io.File;
import java.io.IOException;

public class FileDemo {
    public static void main(String[] args) throws IOException {
        // 创建File对象
        File file = new File("test.txt");
    
        // 判断文件是否存在
        if (!file.exists()) {
            // 创建新文件
            boolean created = file.createNewFile();
            System.out.println("文件创建：" + created);
        }
    
        System.out.println("文件名：" + file.getName());
        System.out.println("绝对路径：" + file.getAbsolutePath());
    }
}
```

##### 1.2 路径概念

###### 1.2.1 盘符

- **Windows**：字母 + 冒号，例如 `"C:"`
- **Linux**：无盘符，使用挂载点，以 `/`开头

###### 1.2.2 分隔符

```java
public class PathSeparatorDemo {
    public static void main(String[] args) {
        // 不同操作系统的分隔符
        System.out.println("系统分隔符：" + File.separator);
    
        // 推荐使用方式
        String path1 = "root" + File.separator + "data" + File.separator + "file.txt";
    
        // 使用String.join方法
        String path2 = String.join(File.separator, "root", "data", "file.txt");
    
        System.out.println("路径1：" + path1);
        System.out.println("路径2：" + path2);
    
        // 直接使用斜杠（推荐）
        File file = new File("root/data/file.txt");
    }
}
```

###### 1.2.3 相对路径和绝对路径

```java
import java.io.File;

public class PathTypeDemo {
    public static void main(String[] args) {
        // 相对路径
        File relativeFile1 = new File("./Documents/file.txt");  // 当前目录
        File relativeFile2 = new File("Documents/file.txt");    // 省略./
        File relativeFile3 = new File("../Documents/file.txt"); // 上级目录
    
        // 绝对路径
        File absoluteFileWin = new File("C:\\Users\\username\\Documents\\file.txt");
        File absoluteFileLinux = new File("/home/username/Documents/file.txt");
    
        System.out.println("相对路径1：" + relativeFile1.getPath());
        System.out.println("相对路径2：" + relativeFile2.getPath());
        System.out.println("相对路径3：" + relativeFile3.getPath());
    
        // 获取绝对路径
        System.out.println("转换为绝对路径：" + relativeFile1.getAbsolutePath());
    }
}
```

#### 2. File类API

##### 2.1 路径获取方法

```java
import java.io.File;

public class FilePathDemo {
    public static void main(String[] args) {
        File file = new File("Documents/projects/demo.txt");
    
        // 获得绝对路径
        String absolutePath = file.getAbsolutePath();
        System.out.println("绝对路径：" + absolutePath);
    
        // 获得父目录路径
        String parent = file.getParent();
        System.out.println("父目录路径：" + parent);
    
        // 获得文件名（包括后缀名）
        String name = file.getName();
        System.out.println("文件名：" + name);
    
        // 获得父目录File对象
        File parentFile = file.getParentFile();
        System.out.println("父目录对象：" + parentFile);
    
        // 获得路径
        String path = file.getPath();
        System.out.println("路径：" + path);
    }
}
```

##### 2.2 文件状态判断

```java
import java.io.File;
import java.io.IOException;

public class FileStatusDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("test.txt");
        File directory = new File("testDir");
    
        // 创建文件和目录用于测试
        file.createNewFile();
        directory.mkdir();
    
        // 判断是否存在
        boolean exists = file.exists();
        System.out.println("文件存在：" + exists);
    
        // 判断是否是目录
        boolean isDirectory = file.isDirectory();
        System.out.println("是目录：" + isDirectory);
    
        // 判断是否是文件
        boolean isFile = file.isFile();
        System.out.println("是文件：" + isFile);
    
        // 获得文件长度（字节）
        long length = file.length();
        System.out.println("文件大小：" + length + " 字节");
    
        // 判断是否可读
        boolean canRead = file.canRead();
        System.out.println("可读：" + canRead);
    
        // 判断是否可写
        boolean canWrite = file.canWrite();
        System.out.println("可写：" + canWrite);
    
        // 判断是否隐藏
        boolean isHidden = file.isHidden();
        System.out.println("隐藏文件：" + isHidden);
    }
}
```

#### 3. 文件操作

##### 3.1 文件创建、删除、重命名

```java
import java.io.File;
import java.io.IOException;

public class FileOperationDemo {
    public static void main(String[] args) throws IOException {
        File file = new File("./Documents/file.txt");
    
        // 创建文件
        boolean created = file.createNewFile();
        if (created) {
            System.out.println("文件创建成功");
        } else {
            System.out.println("文件已存在，创建失败");
        }
    
        // 删除文件
        boolean deleted = file.delete();
        if (deleted) {
            System.out.println("文件删除成功");
        } else {
            System.out.println("文件不存在，删除失败");
        }
    
        // 重新创建文件用于重命名演示
        file.createNewFile();
    
        // 重命名文件
        File newFile = new File("./Documents/file2.txt");
        boolean renamed = file.renameTo(newFile);
        if (renamed) {
            System.out.println("文件重命名成功");
        } else {
            System.out.println("文件重命名失败");
        }
    }
}
```

#### 4. 目录操作

##### 4.1 目录创建、删除、重命名

```java
import java.io.File;

public class DirectoryOperationDemo {
    public static void main(String[] args) {
        File folder = new File("./Documents/folder");
        File multiFolder = new File("./Documents/level1/level2/level3");
    
        // 创建单层目录
        boolean created = folder.mkdir();
        if (created) {
            System.out.println("单层目录创建成功");
        } else {
            System.out.println("目录已存在或创建失败");
        }
    
        // 创建多层目录
        boolean createdMulti = multiFolder.mkdirs();
        if (createdMulti) {
            System.out.println("多层目录创建成功");
        } else {
            System.out.println("目录已存在或创建失败");
        }
    
        // 删除目录（只能删除空目录）
        boolean deleted = folder.delete();
        if (deleted) {
            System.out.println("目录删除成功");
        } else {
            System.out.println("目录不为空或删除失败");
        }
    
        // 重命名目录
        File newFolder = new File("./Documents/newFolder");
        folder.mkdir(); // 重新创建
        boolean renamed = folder.renameTo(newFolder);
        if (renamed) {
            System.out.println("目录重命名成功");
        }
    }
}
```

##### 4.2 目录遍历

```java
import java.io.File;
import java.io.FilenameFilter;
import java.io.FileFilter;

public class DirectoryTraversalDemo {
    public static void main(String[] args) {
        File directory = new File("./Documents");
        
        // 返回目录中子文件、子目录的文件名数组
        String[] fileNames = directory.list();
        if (fileNames != null) {
            System.out.println("文件名数组：");
            for (String fileName : fileNames) {
                System.out.println(fileName);
            }
        }
        
        // 返回目录中子文件、子目录的File对象数组
        File[] files = directory.listFiles();
        if (files != null) {
            System.out.println("\nFile对象数组：");
            for (File file : files) {
                System.out.println(file.getName() + " - " + 
                    (file.isDirectory() ? "目录" : "文件"));
            }
        }
        
        // 使用FilenameFilter过滤器
        String[] txtFiles = directory.list(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".txt");
            }
        });
        
        // Lambda表达式简化
        String[] txtFilesLambda = directory.list((dir, name) -> name.endsWith(".txt"));
        
        // 使用FileFilter过滤器
        File[] largeFiles = directory.listFiles(new FileFilter() {
            @Override
            public boolean accept(File pathname) {
                return pathname.isFile() && pathname.length() > 1024;
            }
        });
        
        // Lambda表达式简化
        File[] largeFilesLambda = directory.listFiles(file -> 
            file.isFile() && file.length() > 1024);
    }
}
```

##### 4.3 递归遍历

```java
import java.io.File;

public class RecursiveTraversalDemo {
    public static void main(String[] args) {
        File directory = new File("./Documents");
        traverseDirectory(directory, 0);
    }
    
    /**
     * 递归遍历目录
     * @param directory 要遍历的目录
     * @param level 层级深度
     */
    public static void traverseDirectory(File directory, int level) {
        // 递归终止条件
        if (!directory.exists() || !directory.isDirectory()) {
            return;
        }
        
        // 打印当前目录
        String indent = "  ".repeat(level);
        System.out.println(indent + "[目录] " + directory.getName());
        
        // 获取目录下的所有文件和子目录
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    // 递归调用自身方法
                    traverseDirectory(file, level + 1);
                } else {
                    System.out.println(indent + "  [文件] " + file.getName());
                }
            }
        }
    }
}
```

#### 5. I/O流概述

##### 5.1 I/O流介绍

- **I** - Input 输入
- **O** - Output 输出  
- **Stream** - 流
- **作用**：用于数据的传输

##### 5.2 I/O流体系划分

###### 5.2.1 按传输方向划分

- **输入流（InputStream）**：从数据源读取数据到程序
- **输出流（OutputStream）**：从程序写入数据到目标

###### 5.2.2 按传输单位划分

- **字节流**：以字节为单位传输，可以处理任何类型的文件
- **字符流**：以字符为单位传输，专门处理文本文件

###### 5.2.3 按传输方式划分

- **原始流/节点流**：每次传输1字节/1字符，传输效率低
- **处理流**：加工处理原始流/节点流，传输效率高

##### 5.3 I/O流基类

```java
// 四大基类
InputStream    // 字节输入流
OutputStream   // 字节输出流
Reader         // 字符输入流
Writer         // 字符输出流
```

#### 6. 文件流

##### 6.1 文件流类的划分

- **FileInputStream**：文件字节输入流
- **FileOutputStream**：文件字节输出流
- **FileReader**：文件字符输入流
- **FileWriter**：文件字符输出流

**特点**：
- 文件流属于节点流
- 用于文件读写操作
- FileWriter第二个参数为true时，追加写入
- 文件不存在时自动创建

##### 6.2 基本操作流程

1. **创建流**
2. **数据的读/写**
3. **关闭流**

```java
import java.io.*;

public class FileStreamDemo {
    public static void main(String[] args) {
        // 文件字节流示例
        fileByteStreamDemo();
        
        // 文件字符流示例
        fileCharStreamDemo();
    }
    
    /**
     * 文件字节流示例
     */
    public static void fileByteStreamDemo() {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        
        try {
            // 1. 创建流
            fis = new FileInputStream("source.txt");
            fos = new FileOutputStream("target.txt");
            
            // 2. 数据读写
            int data;
            while ((data = fis.read()) != -1) {
                fos.write(data);
            }
            
            System.out.println("文件复制完成");
            
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭流
            try {
                if (fis != null) fis.close();
                if (fos != null) fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    
    /**
     * 文件字符流示例
     */
    public static void fileCharStreamDemo() {
        // 使用try-with-resources自动关闭流
        try (FileReader fr = new FileReader("input.txt");
             FileWriter fw = new FileWriter("output.txt", true)) { // true表示追加写入
            
            // 字符数组缓冲读取
            char[] buffer = new char[1024];
            int length;
            
            while ((length = fr.read(buffer)) != -1) {
                fw.write(buffer, 0, length);
            }
            
            System.out.println("文本文件处理完成");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 7. NIO.2 (New I/O 2)

##### 7.1 NIO.2核心类

- **Path（接口）**：表示文件系统中的路径
- **Paths（工具类）**：用于获取Path对象
- **Files（终极工具类）**：提供丰富的文件操作方法

##### 7.2 基础语法与常用操作

```java
import java.nio.file.*;
import java.nio.charset.StandardCharsets;
import java.io.IOException;
import java.util.List;

public class NIODemo {
    public static void main(String[] args) throws IOException {
        // 获取Path对象
        Path path = Paths.get("test.txt");
        Path dirPath = Paths.get("testDir");
        
        // 文件/目录检查
        boolean exists = Files.exists(path);
        boolean isDirectory = Files.isDirectory(dirPath);
        boolean isRegularFile = Files.isRegularFile(path);
        
        System.out.println("文件存在：" + exists);
        System.out.println("是目录：" + isDirectory);
        System.out.println("是普通文件：" + isRegularFile);
        
        // 创建文件/目录
        if (!Files.exists(path)) {
            Files.createFile(path);
            System.out.println("文件创建成功");
        }
        
        if (!Files.exists(dirPath)) {
            Files.createDirectory(dirPath);
            System.out.println("目录创建成功");
        }
        
        // 创建多层目录
        Path multiDirPath = Paths.get("level1/level2/level3");
        Files.createDirectories(multiDirPath);
        
        // 写入文件内容
        String content = "Hello NIO.2!\n这是测试内容。";
        Files.write(path, content.getBytes(StandardCharsets.UTF_8));
        
        // 读取文件内容
        List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8);
        System.out.println("文件内容：");
        lines.forEach(System.out::println);
        
        // 复制文件
        Path copyPath = Paths.get("test_copy.txt");
        Files.copy(path, copyPath, StandardCopyOption.REPLACE_EXISTING);
        
        // 移动/重命名文件
        Path movedPath = Paths.get("test_moved.txt");
        Files.move(copyPath, movedPath, StandardCopyOption.REPLACE_EXISTING);
        
        // 删除文件
        Files.deleteIfExists(movedPath);
        
        // 遍历目录（简单）
        System.out.println("\n目录内容：");
        Files.list(Paths.get("."))
             .forEach(System.out::println);
    }
}
```

##### 7.3 高级特性

###### 7.3.1 Files.walk() - 现代化的目录遍历

`Files.walk()` 是NIO.2提供的现代化目录遍历方法，它返回一个Stream流，可以代替传统的递归遍历。

**优势对比：**
- **传统递归**：手动管理递归调用，容易栈溢出，代码复杂
- **Files.walk()**：基于Stream API，函数式编程，内存效率高，代码简洁

```java
import java.nio.file.*;
import java.io.IOException;
import java.util.stream.Stream;

public class FilesWalkDemo {
    public static void main(String[] args) {
        Path startPath = Paths.get(".");
        
        try {
            // 基本遍历 - 默认深度为Integer.MAX_VALUE
            System.out.println("=== 基本遍历 ===");
            Files.walk(startPath)
                 .limit(10) // 限制输出数量
                 .forEach(System.out::println);
            
            // 限制遍历深度
            System.out.println("\n=== 限制深度为2 ===");
            Files.walk(startPath, 2)
                 .forEach(System.out::println);
            
            // 过滤特定文件类型
            System.out.println("\n=== 查找所有.java文件 ===");
            Files.walk(startPath)
                 .filter(path -> path.toString().endsWith(".java"))
                 .forEach(System.out::println);
            
            // 查找大文件（大于1MB）
            System.out.println("\n=== 查找大文件 ===");
            Files.walk(startPath)
                 .filter(Files::isRegularFile)
                 .filter(path -> {
                     try {
                         return Files.size(path) > 1024 * 1024; // 1MB
                     } catch (IOException e) {
                         return false;
                     }
                 })
                 .forEach(path -> {
                     try {
                         System.out.println(path + " - " + Files.size(path) + " bytes");
                     } catch (IOException e) {
                         System.out.println(path + " - 无法获取大小");
                     }
                 });
            
            // 统计文件数量
            System.out.println("\n=== 统计信息 ===");
            long fileCount = Files.walk(startPath)
                                 .filter(Files::isRegularFile)
                                 .count();
            System.out.println("文件总数: " + fileCount);
            
            long dirCount = Files.walk(startPath)
                                .filter(Files::isDirectory)
                                .count();
            System.out.println("目录总数: " + dirCount);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

**Files.walk() vs 传统递归对比：**

```java
// 传统递归方式
public static void traditionalRecursion(File dir) {
    if (!dir.isDirectory()) return;
    
    File[] files = dir.listFiles();
    if (files != null) {
        for (File file : files) {
            if (file.isDirectory()) {
                traditionalRecursion(file); // 递归调用
            } else {
                System.out.println(file);
            }
        }
    }
}

// NIO.2 Files.walk方式
public static void modernWalk(Path startPath) throws IOException {
    Files.walk(startPath)
         .filter(Files::isRegularFile)
         .forEach(System.out::println);
}
```

###### 7.3.2 遍历目录树（FileVisitor）- 高级控制

当需要更精细的控制时，可以使用 `FileVisitor` 接口：

```java
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.io.IOException;

public class FileVisitorDemo {
    public static void main(String[] args) throws IOException {
        Path startPath = Paths.get(".");
        
        Files.walkFileTree(startPath, new SimpleFileVisitor<Path>() {
            private int level = 0;
            
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                String indent = "  ".repeat(level);
                System.out.println(indent + "[目录] " + dir.getFileName());
                level++;
                
                // 跳过特定目录
                if (dir.getFileName().toString().equals(".git")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                String indent = "  ".repeat(level);
                System.out.println(indent + "[文件] " + file.getFileName() + 
                    " (" + attrs.size() + " bytes)");
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
                level--;
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) {
                System.err.println("访问文件失败: " + file + " - " + exc.getMessage());
                return FileVisitResult.CONTINUE;
            }
        });
    }
}
```

**FileVisitResult 控制选项：**
- `CONTINUE`：继续遍历
- `SKIP_SUBTREE`：跳过当前目录的子树
- `SKIP_SIBLINGS`：跳过当前目录的兄弟节点
- `TERMINATE`：终止整个遍历过程

###### 7.3.3 目录监控（WatchService）

`WatchService` 可以监控目录的变化，实现文件系统事件的实时响应：

```java
import java.nio.file.*;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

public class WatchServiceDemo {
    public static void main(String[] args) throws IOException, InterruptedException {
        Path watchDir = Paths.get("./watchTest");
        
        // 创建监控目录
        if (!Files.exists(watchDir)) {
            Files.createDirectory(watchDir);
        }
        
        // 获取文件系统的WatchService
        WatchService watchService = FileSystems.getDefault().newWatchService();
        
        // 注册监控事件
        watchDir.register(watchService,
            StandardWatchEventKinds.ENTRY_CREATE,    // 文件创建
            StandardWatchEventKinds.ENTRY_DELETE,    // 文件删除
            StandardWatchEventKinds.ENTRY_MODIFY);   // 文件修改
        
        System.out.println("开始监控目录: " + watchDir);
        System.out.println("请在该目录下创建、修改或删除文件...");
        
        // 监控循环
        while (true) {
            // 等待事件发生（阻塞）
            WatchKey key = watchService.take();
            
            // 处理所有事件
            for (WatchEvent<?> event : key.pollEvents()) {
                WatchEvent.Kind<?> kind = event.kind();
                Path fileName = (Path) event.context();
                
                if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
                    System.out.println("文件创建: " + fileName);
                } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
                    System.out.println("文件删除: " + fileName);
                } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
                    System.out.println("文件修改: " + fileName);
                } else if (kind == StandardWatchEventKinds.OVERFLOW) {
                    System.out.println("事件溢出");
                }
            }
            
            // 重置key，继续监控
            boolean valid = key.reset();
            if (!valid) {
                System.out.println("监控已停止");
                break;
            }
        }
        
        watchService.close();
    }
}
```

**高级监控示例 - 非阻塞监控：**

```java
public class NonBlockingWatchDemo {
    public static void main(String[] args) throws IOException, InterruptedException {
        Path watchDir = Paths.get("./watchTest");
        WatchService watchService = FileSystems.getDefault().newWatchService();
        
        watchDir.register(watchService,
            StandardWatchEventKinds.ENTRY_CREATE,
            StandardWatchEventKinds.ENTRY_DELETE,
            StandardWatchEventKinds.ENTRY_MODIFY);
        
        System.out.println("非阻塞监控开始...");
        
        // 非阻塞监控，每秒检查一次
        for (int i = 0; i < 30; i++) { // 监控30秒
            WatchKey key = watchService.poll(1, TimeUnit.SECONDS);
            
            if (key != null) {
                for (WatchEvent<?> event : key.pollEvents()) {
                    System.out.println("检测到事件: " + event.kind() + 
                        " - " + event.context());
                }
                key.reset();
            } else {
                System.out.println("第 " + (i + 1) + " 秒 - 无事件");
            }
        }
        
        watchService.close();
    }
}
```

###### 7.3.4 文件属性视图

```java
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.ZoneId;

public class FileAttributesDemo {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("test.txt");
        
        // 基础属性
        BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
        
        System.out.println("文件大小: " + attrs.size() + " 字节");
        System.out.println("创建时间: " + 
            LocalDateTime.ofInstant(attrs.creationTime().toInstant(), ZoneId.systemDefault()));
        System.out.println("最后修改时间: " + 
            LocalDateTime.ofInstant(attrs.lastModifiedTime().toInstant(), ZoneId.systemDefault()));
        System.out.println("是否为目录: " + attrs.isDirectory());
        System.out.println("是否为普通文件: " + attrs.isRegularFile());
    }
}
```

###### 7.3.5 异步文件通道（AsynchronousFileChannel）

异步文件通道允许非阻塞的文件I/O操作：

```java
import java.nio.file.*;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.channels.CompletionHandler;
import java.nio.ByteBuffer;
import java.io.IOException;
import java.util.concurrent.Future;

public class AsyncFileChannelDemo {
    public static void main(String[] args) throws IOException, InterruptedException {
        Path file = Paths.get("async_test.txt");
        
        // 创建测试文件
        if (!Files.exists(file)) {
            Files.write(file, "Hello Async File Channel!\n这是异步文件操作测试。".getBytes());
        }
        
        // 异步读取示例1：使用Future
        asyncReadWithFuture(file);
        
        // 异步读取示例2：使用CompletionHandler
        asyncReadWithHandler(file);
        
        // 异步写入示例
        asyncWrite(file);
        
        // 等待异步操作完成
        Thread.sleep(2000);
    }
    
    /**
     * 使用Future进行异步读取
     */
    public static void asyncReadWithFuture(Path file) throws IOException {
        try (AsynchronousFileChannel channel = AsynchronousFileChannel.open(file, StandardOpenOption.READ)) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            
            // 异步读取
            Future<Integer> result = channel.read(buffer, 0);
            
            // 可以在这里做其他工作
            System.out.println("异步读取已启动，可以做其他工作...");
            
            try {
                // 获取读取结果
                Integer bytesRead = result.get();
                buffer.flip();
                
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                
                System.out.println("Future方式读取完成，读取字节数: " + bytesRead);
                System.out.println("内容: " + new String(data));
                
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    /**
     * 使用CompletionHandler进行异步读取
     */
    public static void asyncReadWithHandler(Path file) throws IOException {
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(file, StandardOpenOption.READ);
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        
        channel.read(buffer, 0, buffer, new CompletionHandler<Integer, ByteBuffer>() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                attachment.flip();
                byte[] data = new byte[attachment.remaining()];
                attachment.get(data);
                
                System.out.println("Handler方式读取完成，读取字节数: " + result);
                System.out.println("内容: " + new String(data));
                
                try {
                    channel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            
            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                System.err.println("异步读取失败: " + exc.getMessage());
                try {
                    channel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }
    
    /**
     * 异步写入示例
     */
    public static void asyncWrite(Path file) throws IOException {
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(file, 
            StandardOpenOption.WRITE, StandardOpenOption.APPEND);
        
        String content = "\n异步写入的内容 - " + System.currentTimeMillis();
        ByteBuffer buffer = ByteBuffer.wrap(content.getBytes());
        
        channel.write(buffer, Files.size(file), buffer, new CompletionHandler<Integer, ByteBuffer>() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                System.out.println("异步写入完成，写入字节数: " + result);
                try {
                    channel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            
            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                System.err.println("异步写入失败: " + exc.getMessage());
                try {
                    channel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}
```

###### 7.3.6 文件通配符匹配（PathMatcher & Glob）

```java
import java.nio.file.*;
import java.io.IOException;

public class PathMatcherDemo {
    public static void main(String[] args) throws IOException {
        Path directory = Paths.get(".");
        
        // 基本通配符匹配
        System.out.println("=== 匹配所有.txt文件 ===");
        PathMatcher txtMatcher = FileSystems.getDefault().getPathMatcher("glob:*.txt");
        Files.list(directory)
             .filter(txtMatcher::matches)
             .forEach(System.out::println);
        
        // 复杂的Glob模式
        System.out.println("\n=== 匹配所有.java和.class文件 ===");
        PathMatcher javaMatcher = FileSystems.getDefault().getPathMatcher("glob:*.{java,class}");
        Files.walk(directory)
             .filter(javaMatcher::matches)
             .forEach(System.out::println);
        
        // 使用正则表达式
        System.out.println("\n=== 使用正则表达式匹配 ===");
        PathMatcher regexMatcher = FileSystems.getDefault().getPathMatcher("regex:.*\\.(txt|log)$");
        Files.walk(directory)
             .filter(regexMatcher::matches)
             .forEach(System.out::println);
        
        // 更复杂的Glob模式
        System.out.println("\n=== 复杂Glob模式示例 ===");
        
        // 匹配任意深度的src目录下的.java文件
        PathMatcher srcJavaMatcher = FileSystems.getDefault().getPathMatcher("glob:**/src/**/*.java");
        
        // 匹配以test开头的文件
        PathMatcher testMatcher = FileSystems.getDefault().getPathMatcher("glob:test*");
        
        // 匹配单个字符
        PathMatcher singleCharMatcher = FileSystems.getDefault().getPathMatcher("glob:file?.txt");
        
        // 匹配字符范围
        PathMatcher rangeMatcher = FileSystems.getDefault().getPathMatcher("glob:file[0-9].txt");
        
        Files.walk(directory)
             .filter(path -> srcJavaMatcher.matches(path) || 
                           testMatcher.matches(path.getFileName()) ||
                           singleCharMatcher.matches(path.getFileName()) ||
                           rangeMatcher.matches(path.getFileName()))
             .forEach(path -> System.out.println("匹配: " + path));
    }
}
```

**Glob模式语法说明：**
- `*` : 匹配任意数量的字符（不包括目录分隔符）
- `**` : 匹配任意数量的字符（包括目录分隔符）
- `?` : 匹配单个字符
- `[abc]` : 匹配方括号中的任意一个字符
- `[a-z]` : 匹配指定范围内的字符
- `{java,class}` : 匹配大括号中的任意一个模式

**实用的文件查找工具类：**

```java
import java.nio.file.*;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

public class FileSearchUtils {
    
    /**
     * 根据扩展名查找文件
     */
    public static List<Path> findByExtension(Path startPath, String... extensions) throws IOException {
        String pattern = "glob:*.{" + String.join(",", extensions) + "}";
        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(pattern);
        
        return Files.walk(startPath)
                   .filter(Files::isRegularFile)
                   .filter(path -> matcher.matches(path.getFileName()))
                   .collect(Collectors.toList());
    }
    
    /**
     * 根据文件名模式查找文件
     */
    public static List<Path> findByPattern(Path startPath, String globPattern) throws IOException {
        PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:" + globPattern);
        
        return Files.walk(startPath)
                   .filter(Files::isRegularFile)
                   .filter(matcher::matches)
                   .collect(Collectors.toList());
    }
    
    /**
     * 查找大于指定大小的文件
     */
    public static List<Path> findLargeFiles(Path startPath, long minSize) throws IOException {
        return Files.walk(startPath)
                   .filter(Files::isRegularFile)
                   .filter(path -> {
                       try {
                           return Files.size(path) > minSize;
                       } catch (IOException e) {
                           return false;
                       }
                   })
                   .collect(Collectors.toList());
    }
    
    public static void main(String[] args) throws IOException {
        Path currentDir = Paths.get(".");
        
        // 查找所有Java和JavaScript文件
        List<Path> codeFiles = findByExtension(currentDir, "java", "js", "ts");
        System.out.println("代码文件: " + codeFiles.size() + " 个");
        
        // 查找所有测试文件
        List<Path> testFiles = findByPattern(currentDir, "**/test/**/*.java");
        System.out.println("测试文件: " + testFiles.size() + " 个");
        
        // 查找大于1MB的文件
        List<Path> largeFiles = findLargeFiles(currentDir, 1024 * 1024);
        System.out.println("大文件: " + largeFiles.size() + " 个");
    }
}
```

##### 7.4 工具方法

```java
import java.nio.file.*;
import java.io.IOException;

public class NIOUtilsDemo {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("test.txt");
        
        // 获取文件MIME类型
        String contentType = Files.probeContentType(path);
        System.out.println("MIME类型: " + contentType);
        
        // 创建临时文件
        Path tempFile = Files.createTempFile("temp", ".txt");
        System.out.println("临时文件: " + tempFile);
        
        // 创建临时目录
        Path tempDir = Files.createTempDirectory("tempDir");
        System.out.println("临时目录: " + tempDir);
        
        // 文件比较
        Path path2 = Paths.get("test_copy.txt");
        if (Files.exists(path2)) {
            boolean isSame = Files.isSameFile(path, path2);
            System.out.println("文件是否相同: " + isSame);
        }
        
        // 清理临时文件
        Files.deleteIfExists(tempFile);
        Files.deleteIfExists(tempDir);
    }
}
```
