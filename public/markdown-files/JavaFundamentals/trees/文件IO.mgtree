File
  Java中处理文件和文件夹的类
  只能对文件本身进行操作，内容读写使用IO流操作
  创建
    构造方法：File(String filepath)
    路径
      盘符
        windows：字母 + 冒号，例如"C:"
        Linux：无盘符，使用挂载点，以`/`开头
      分隔符
        \\
        /
        File.separator
          String.join(File.separator, "root", "data", "file.txt");
      相对路径
        ./表示当前目录，可省略
          ./Documents/file.txt
          Documents/file.txt
        ../表示上级目录
          ../Documents/file.txt 等价于 username/Documents/file.txt
      绝对路径
        windows：C:\\Users\\username\\Documents\\file.txt
        Linux：/home/username/Documents/file.txt
  API
    路径获取
      获得绝对路径
        file.getAbsolutePath() >java[4]
      获得父目录路径
        file.getParent() >java
      获得文件名包括后缀名
        file.getName() >java
    获得父目录文件对象
      file.getParentFile() >java
    判断File对象
      是否存在
        file.exists() >java++
      是否是目录
        file.isDirectory() >java
      是否是文件
        file.isFile() >java
    获得文件长度，以字节为单位
      file.length() >java
    File对象修改操作
      文件
        File file = new File("./Documents/file.txt") >java++
        创建
          boolean file.createNewFile()
            为true，创建成功 >java
            为false，文件已存在，创建失败 >java
            文件不存在抛出IOException >java
        删除
          boolean file.delete()
            为true，删除成功 >java
            为false。文件不存在，删除失败 >java
        重命名
          File newFile = newFile("./Documents/file2.txt") >java
          boolean file.renameTo(newFile)
            为true，重命名成功 >java
            为false，重命名失败 >java
      目录
        File folder = new File("./Documents/folder") >java++
        创建
          创建单层目录
            boolean folder.mkdir() >java
          创建多层目录
            boolean folder.mkdirs() >java
        删除
          boolean delete()
            只能删除空的目录 >java
        重命名
          同文件 >java
    遍历
      返回目录中子文件、子目录的文件名数组
        String[] file.list() >java++
      返回目录中子文件、子目录的File对象数组
        File[] file.listFiles() >java
      函数式接口-过滤器
        FilenameFilter
          文件名过滤器
            方法签名：boolean accept(File dir, String name) >java
        FileFilter
          文件过滤器
            方法签名：boolean accept(File pathname) >java
      递归遍历>java++
        方法内部去调用自身方法，实现嵌套调用
        递归必须有终止条件，否则死循环#栈溢出
I/O 流
  概述
    i - input 输入
    i - output 输出
    stream  流
    用于数据的传输
  体系划分
    传输方向
      输入流 InputStream
      输出流 OutputStream
    传输单位
      字节流 以字节为单位传输
      字符流 以字符为单位传输
    传输方式
      原始流/节点流 每次传输1字节/1字符
        传输效率低
      处理流 加工处理 原始流/节点流
        传输效率高
  基类
    InputStream：字节输入流
    OutputStream：字节输出流
    Reader：字符输入流
    Writer：字符输出流
  文件流
    直接操作文件字节 / 字符
    类的划分
      FileInputStream：文件字节输入流
      FileOutputStream：文件字节输出流
      FileReader：文件字符输入流
      FileWriter：文件字符输出流
        用于文件写入
        第二个参数为true，追加写入
        文件不存在自动创建
    文件流属于节点流
    基本操作流程>java[11]
      1. 创建流
      2. 数据的读/写
      3. 关闭流
  处理流：包裹节点流增强功能
  缓冲流
    缓存数据减少 IO 次数
    分类
      任意文件
        BufferedInputStream：字节输入缓冲流 >java++
        BufferedOutputStream：字节输出缓冲流 >java
      用于文档
        BufferedReader：字符输入缓冲流 >java++
        BufferedWriter：字符输出缓冲流 >java
  序列化流/对象流
    概述
      序列化
        将Java对象以二进制形式写入
      反序列化
        将二进制文件读取出对象
    分类
      ObjectInputStream
        对象输出流，实现反序列化
      ObjectOutputStream
        对象输出流，实现序列化
    对象的序列化/反序列化操作
      1. 实现getter/setter方法
      2. 实现Serializable接口
      3. 新建对象输入/输出流（使用文件字节输入流）
      4.使用readObject/writeObject来读写对象
    基本序列化实例>java++
    集合对象序列化>java++
NIO
  在 Java 1.4 中引入，提供了高速、面向块的 I/O 操作。
  核心组件
    通道（Channel）
    缓冲区（Buffer）
    选择器（Selector）
  缓冲区（Buffer）
    概述
      数据的容器
      缓冲区是一个数组
    分类
      字节缓冲区
        ByteBuffer
      字符缓冲区
        CharBuffer
      短整型缓冲区
        ShortBuffer
      整型缓冲区
        IntBuffer
      长整型缓冲区
        LongBuffer
      浮点型缓冲区
        FloatBuffer
      双精度型缓冲区
        DoubleBuffer
    核心属性与方法：>java+=3
      容量 (Capacity): 缓冲区最大数据容量。
      位置 (Position): 下一个要被读或写的元素的索引。
      上限 (Limit): 缓冲区中第一个不能被读或写的元素的索引。
      标记 (Mark): 一个备忘位置，通过 mark() 标记，reset() 可回到该位置。
      flip(): 将 limit 设为 position，position 设为 0。为从 Buffer 读取数据做准备。
      clear(): 将 position 设为 0，limit 设为 capacity。为向 Buffer 写入数据做准备（并未真正清除数据）。
      rewind(): 将 position 设为 0，limit 不变。为重新读取 Buffer 中的数据做准备。
      compact(): 将所有未读的数据复制到 Buffer 起始处，然后将 position 设到最后一个未读元素后面，limit 设为 capacity。为继续写入数据做准备。
  Channel（通道）
    类似于传统的“流”，但可以双向读写（流是单向的），并且与 Buffer 配合，实现高效的块传输。
    主要实现类：
      FileChannel: 用于文件的数据读写。>java++
        read(ByteBuffer dst)：从通道的当前位置开始读取数据，并写入到给定的缓冲区 dst 中。
        write(ByteBuffer src)：将缓冲区 src 中剩余的数据（从 position 到 limit）写入到通道的当前位置。
        position()：获取或设置此通道的文件位置。这个位置是下一次进行读或写操作开始的地方。
        transferTo/From>java++
          高效的文件通道间传输，用于在通道之间直接传输数据，适用于大文件
          transferTo(long position, long count, WritableByteChannel target)：将数据从当前文件通道传输到另一个可写字节通道。
          transferFrom(ReadableByteChannel src, long position, long count)：将数据从源通道传输到当前文件通道。
      SocketChannel: 用于 TCP 网络通信（客户端）。>java++
        支持阻塞和非阻塞模式。通过 SocketChannel.open() 创建，用 connect() 连接服务器。
      ServerSocketChannel: 用于监听 TCP 连接（服务器端）。>java
        通过 ServerSocketChannel.open() 创建，用 bind() 绑定端口，accept() 接受连接（返回一个 SocketChannel）。
      DatagramChannel: 用于 UDP 网络通信。>java
  Selector（选择器）
    NIO 实现非阻塞 I/O 多路复用的核心。允许一个线程管理多个 Channel。
    使用方法>java++
      1.创建 Selector：Selector selector = Selector.open();
      2.将 Channel 设置为非阻塞模式。
      3.将 Channel 注册到 Selector 上，并指定监听的事件（SelectionKey.OP_READ, OP_WRITE, OP_CONNECT, OP_ACCEPT）。
      4.调用 selector.select() 方法，它会阻塞，直到有注册的通道事件就绪。
      5.获取就绪的 SelectionKey 集合，并进行相应的 I/O 操作。
  SelectionKey（选择器键）
    表示一个 Channel 在 Selector 上的注册关系。包含就绪的事件集合、对应的 Channel 和 Selector。
    常用方法>java++
      isReadable()：检查与此键关联的通道是否已经准备好进行读取操作。
      isWritable()：检查与此键关联的通道是否已经准备好进行写入操作。
      isAcceptable()：检查与此键关联的 ServerSocketChannel 是否已经准备好接受一个新的连接。
      isConnectable()：检查与此键关联的 SocketChannel 是否已经完成其连接操作。
      channel()：返回与此键关联的通道对象
      selector()：返回创建此键的选择器对象
NIO.2
  在 `Java 7 `中引入，对旧的` Java I/O `进行了全面现代化升级，提供了更强大、更直观的 API
  核心概念与优势
    统一的路径抽象` (Path)`
    目录树遍历 `(FileVisitor)`
    异步 I/O `(AsynchronousFileChannel)`
    文件更改通知 `(WatchService)`
    实用方法 `(Files)`
    文件属性访问` (Attributes)`
  `Path` 接口
    `NIO.2` 的`基石`，代表一个`文件系统路径`。它可以是`绝对`的，也可以是`相对`的。>java++
    获取 Path 对象：使用 `Paths.get()` 工厂方法。
    常用方法
      path.getFileName(): 获取文件名部分。
      path.getParent(): 获取父目录路径。
      path.getRoot(): 获取根路径（如 C:\ 或 /）。
      path.resolve(Path other): 将两个路径拼接起来。
      path.relativize(Path other): 计算从一个路径到另一个路径的相对路径。
      path.normalize(): 移除路径中的冗余部分（如 . 和 ..）。
      path.toAbsolutePath(): 转换为绝对路径。
      path.toFile(): 转换为旧的 File 对象（用于兼容旧代码）。
      Files.exists(path): 检查路径是否存在（属于 Files 类）。
  `Files` 文件操作
    检查文件状态>java++
      Files.exists(Path path)：检查文件是否存在
      Files.isReadable(Path path)：检查文件是否可读
      Files.isDirectory(Path path)：检查文件是否是目录
      Files.isRegularFile(Path path)：检查文件是否为常规文件
    创建文件/目录>java++
      Files.createFile(Path path)：创建文件
      Files.createDirectory(Path path)：创建目录
      Files.createDirectories(Path path)：创建多级目录
    读取文件>java++
      Files.readAllBytes(Path path)：一次性读取所有文件内容，返回字节数组
      Files.readAllLines(Path path, Charset codeFormat)：一次性读取所有行，返回ArrayList<String>
      Files.newBufferedReader(Path path, Charset codeFormat)：流式处理大文件
      Files.newInputStream(Path path)：处理二进制文件
      Charset常用值：
        StandardCharsets.UTF_8: UTF-8编码（最常用）
        StandardCharsets.UTF_16: UTF-16编码
        StandardCharsets.ISO_8859_1: ISO Latin-1编码
        StandardCharsets.US_ASCII: ASCII编码
    写入文件>java++
      Files.write(Path path, ArrayList<String> arr, Charset codeFormat, OpenOption... options)：写入
      Files.newBufferedWriter(Path path, Charset codeFormat, OpenOption... options)：缓冲写入
      Files.newOutputStream(Path path, OpenOption... options)：二进制写入
      options参数使用StandardOpenOption的常量
      openOption常用值：
        READ / WRITE: 读/写模式。
        CREATE: 如果文件不存在则创建。
        CREATE_NEW: 创建新文件，如果已存在则失败。
        TRUNCATE_EXISTING: 打开时清空文件。
        APPEND: 在文件末尾追加。
    复制、移动/重命名、删除>java+=2
      Files.copy(Path source, Path target, CopyOption... options)：复制
      Files.move(Path source, Path target, StandardCopyOption.REPLACE_EXISTING)：移动
      Files.move(Path source, source.resolveSibling("new_name.txt")) ：重命名
      Files.delete(Path path)：删除目录 如果文件不存在，抛出 NoSuchFileException
      Files.deleteIfExists(path)：安全删除目录，不存在返回false
      options参数使用StandardCopyOption的常量
      copyOption常用值：
        REPLACE_EXISTING：覆盖已存在
    获取文件属性>java++
      基本属性
        Files.size(Path path)：文件大小
        Files.getLastModifiedTime(Path path)：文件上次修改时间
        Files.getOwner(Path path).getName()：拥有者名称
      获取所有属性视图`(POSIX系统)`
        <ViewType>Attributes attributes = Files.readAttributes(path, <ViewType>Attributes.class);
        BasicFileAttributeView: 基本属性
        PosixFileAttributeView: POSIX系统属性（权限，所有者，组）
        DosFileAttributeView: DOS/Windows系统属性（隐藏，存档等）
        FileOwnerAttributeView: 文件所有者
    遍历目录>java++
      Files.newDirectoryStream(Path path)：创建目录流，用于迭代指定目录的直接子项
      Files.walk(Path path)：使用惰性流操作遍历，返回一个惰性填充的 Stream<Path>
      Files.walkFileTree(Path startDir, SimpleFileVisitor fileVisitor)：使用访问者模式递归遍历目录树
  异步 I/O `(AsynchronousFileChannel)`>java++
    var afc = AsynchronousFileChannel.open(Path path, OpenOption option)
    afc.read(ByteBuffer buffer, position, attachment，CompletionHandler<R, A>);
    CompletionHandler需要实现两个方法
      completed(R result, A attachment)：写入成功回调
      failed(Throwable exc, A attachment)：写入失败回调
    文件操作
      afc.size()：获取文件大小
      afc.truncate(newSize)：截断
      afc.force(true)：强制数据写入磁盘
        metaData = true: 强制同步文件内容 + 文件元数据到存储设备
        metaData = false: 只强制同步文件内容到存储设备，不同步元数据
      afc.lock()：文件锁定，返回类型为Future<FileLock>
        afc.lock().get()，获得文件锁
      通道管理
        afc.isOpen()：判断通道是否打开
        afc.close()：关闭通道
        afc.position()：获得文件位置
  文件系统监视 `（WatchService）`>java++
    `WatchService` 可以监控目录的变化，实现文件系统事件的实时响应
    使用方法
      1. 获取文件系统的WatchService： FileSystems.getDefault().newWatchService()
      2. 监控循环：while(true)
        3.遍历获取所有事件：WatchEvent<?> event : key.pollEvents()
          WatchEvent.Kind<?> kind = event.kind()：获取事件类型
          Path fileName = (Path) event.context()：获取文件的`Path`对象
        4. 重置key，继续监控：boolean valid = key.reset()
        5. 非法情况退出：if (!valid) break
      6. 循环退出后关闭：watchService.close();
