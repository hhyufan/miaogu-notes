并发概述
  系统具有处理多个任务的能力
  进程和线程
    进程 Process
      每一个独立执行程序
      进程是操作系统进行资源分配、调度管理的`最小单位`
      每个进程拥有`独立内存单元`
    线程 Thread
      线程是进程中/程序内部的一条执行流程
      一个进程中允许多个线程，至少有一个线程称作`主线程`
      一个进程中多个线程`共享内存单元`
  异步 Future
    异步编程是一种允许任务在后台发起的执行模式，，而无需等待其完成即可继续执行后续代码，
创建和启动
  进程
    使用`ProcessBuilder` >java[1]
    使用 `Runtime.exec() `(旧方式，不推荐) >java++
  线程
    继承`Thread`类 >java++
      优点：简单、直接
      缺点：java单继承，扩展性差
    实现 `Runnable` 接口 >java++
      优点：接口多实现，扩展性查
      优点：接口多实现，扩展性高
    线程池创建 >java++
  异步
    使用 `CompletableFuture` (现代首选，Java 8+) >java++
    使用 `Future` + `ExecutorService` (传统方式) >java++
    使用 `虚拟线程` >java++
线程通信
  线程在执行过程中，可以将数据传递给我我另外一个线程；
  实现
    实现`Callable`，`FutureTask`>java++
      Call回调，Callable执行完毕，外界获得回调返回值
      优点：可以通过回调获取线程执行结果
      缺点：造成线程阻塞
    异步回调
      回调接口实现>java++
      Lambda表达>java++
      回调地狱
        回调地狱是指在异步编程中，执行多个连续的异步操作时回调函数层层嵌套，形成深度嵌套的代码结构
        代码难以阅读、理解和维护。
        解决办法
          CompletableFuture链式调用>java[6]
          虚拟线程>java[8]
基本方法 >java+=5
  线程名称：`thread.getName()`
    主线程：main
    子线程：thread-xx
  命名线程：`thread.setName(String str)`
  获取当前正在执行的线程：Thread.getcurrentThread()
生命周期
  概述
    线程从创建到销毁经历不同阶段
    研究的目的是分析不同阶段需要做不同的事情
  线程生命周期五大状态
    创建
      Thread thread = new Thread()  >java++
    就绪
      thread.start() >java++
    运行
      获得执行权
      失去执行权#被抢走 -> 就绪
    阻塞
      阻塞 -> 就绪
      BLOCKED
        等待进入 synchronized 代码块/方法
        持有锁的线程释放了锁，且该线程竞争到了锁 -> 就绪
      WAITING
        其他线程使用wait()进入此状态，调用 Object.notify()/notifyAll()
        目标线程执行完毕 (对于join无参方法)
      TIMED_WAITING
        调用了某些方法
          join(millis)：插队
          sleep(millis)：休眠
          wait(millis)：等待
        指定的超时时间到期，或其他线程在超时前发出了通知
    终止
      run() 执行完毕
        使用flag控制
      run() 发生异常
        thread.interrupted()
    生命周期综合示例>java++
线程同步
  临界资源
    多个线程同时操作的数据，称为`临界资源`，又叫`共享资源`
  线程同步
    多个线程操作`临界资源`的时候，保证达到`数据一致性`
    数据不一致/线程不同步的原因
      线程在操作`临界资源`的时候，被其他线程`打断` >java++
  解决办法
    使用`synchronized`关键字
      修饰方法>java++
      修饰代码块>java++
        synchronized (Object lock) {}
      同步锁
        1. Java`任意对象`，建议使用`公共资源`
    Lock对象>java++
      1. 实例化 Lock lock = new ReentrantLock();
      2. lock.lock()
      3. lock.unlock()
    死锁
      两个线程同时占有对方所需的锁，等待对方释放，导致死锁>java++
线程设计模式
  单例模式
    确保`一个类`只有一个`实例`，并提供一个`全局访问点`
    注意事项
      1. 不允许外界实例化对象：构造方法私有化
      2. 向外提供唯一接口(方法)，返回对象实例
      3. 保持对象的唯一性
    懒汉式>java++
      优点：避免`延迟初始化开销`
      缺点：无论外部是否使用该对象都会`实例对象`
      `类加载`时创建`实例对象`
    饿汉式>java++
      第一次调用`getInstance()`创建`实例`
      优点：适合`延迟初始化`场景
  生产者/消费者模式
    简单模式>java++
      生产者`(Producer)`
        负责生产数据并将其发送到队列，可以有多个生产者同时工作
      消费者`(Consumer)`
        从队列中获取数据并进行处理，可以有多个消费者同时工作
      队列`(Queue)`
        用于存储数据的缓冲区，生产者将数据放入队列，消费者从队列中获取数据
        包含属性
          容量限制：可满可空
          空/满状态标志
          元素数量
      数据`(Data)`
        生产者生产的数据，消费者消费的数据
      同步机制
        确保生产者和消费者在访问队列时的`线程安全`，避免数据竞争和不一致性
    复杂模式
      生产者`(Producer)`
        负责生产数据并将其发送到交换机，可以有多个生产者同时工作
      消费者`(Consumer)`
        从队列中获取数据并进行处理，可以有多个消费者同时工作
      交换机`(Exchange)`
        负责接收生产者发送的数据，并根据`路由键`将数据发送到指定的队列
        分类
          直接交换机`(Direct Exchange)`
          主题交换机`(Topic Exchange)`
          广播交换机`(Fanout Exchange)`
      队列`(Queue)`
        用于存储数据的`缓冲区`，生产者将数据放入队列，消费者从队列中获取数据
      数据`(Data)`
        生产者，消费者之间传递的实际对象，包含消息内容和路由信息
      同步机制
        确保消息传递过程中的`线程安全`，如阻塞队列，信号量等
ThreadLocal
  实现线程同步处理临界资源，保证数据一致性
  常用方法>java++
    set(T value)：设置当前线程绑定的局部变量
    T get()：获取当前线程绑定的局部变量
    T remove()：移除当前线程绑定的局部变量
守护线程
  概述
    用户线程 `(UserThread)`：默认情况创建的线程
    守护线程 `(DaemonThread)`
      伴随用户线程执行，程序终止，同时终止所有守护线程
      用途
        垃圾回收
        定时任务：数据备份
        服务器监控
  常用方法>java++
    setDaemon(boolean is)：设置当前线程为守护线程
    isDaemon()：判断当前线程是否为守护线程
线程池
  什么是线程池
    线程池是一种线程管理机制，预先创建一定数量的线程并放入 "池" 中统一管理
    任务执行时从池中获取线程，完成后线程返回池中等待下一个任务，避免频繁创建销毁线程
    核心是复用线程资源，降低性能开销
  线程池的作用
    降低资源消耗：减少线程创建 / 销毁的 CPU 和内存开销
    提高响应速度：任务到达时无需等待线程创建，直接使用空闲线程
    便于管理：统一控制线程数量、任务队列大小，防止资源耗尽
    附加功能：支持定时执行、定期执行、线程中断控制等
  核心参数
    核心线程数（corePoolSize）：线程池长期维持的线程数量
    最大线程数（maximumPoolSize）：允许创建的最大线程数量
    空闲线程存活时间（keepAliveTime）：非核心线程空闲超时时间
    时间单位（unit）：keepAliveTime 的时间单位
    工作队列（workQueue）：存放等待执行任务的阻塞队列
    线程工厂（threadFactory）：用于创建线程的工厂
    拒绝策略（handler）：任务满时的处理策略
  工作机制
    当新任务提交时，若当前线程数 < 核心线程数，创建核心线程执行任务
    若当前线程数 ≥ 核心线程数，将任务放入工作队列等待
    若队列已满，且当前线程数 < 最大线程数，创建非核心线程执行任务
    若队列已满且线程数已达最大线程数，触发拒绝策略
  常用线程池>java++
    FixedThreadPool：核心线程数与最大线程数相同
    SingleThreadExecutor：一个线程的线程池
    CachedThreadPool：核心线程为0，最大线程数为Integer.MAX_VALUE
    ScheduledThreadPool：指定核心线程数的定时线程池
    SingleThreadScheduledExecutor：单例的定时线程池
    ForkJoinPool：JDK 7+功能，处理可分解的大任务，采用工作窃取算法