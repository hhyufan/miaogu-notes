并发概述
  系统具有处理多个任务的能力
  进程和线程
    进程 Process
      每一个独立执行程序
      进程是操作系统进行资源分配、调度管理的`最小单位`
      每个进程拥有`独立内存单元`
    线程 Thread
      线程是进程中/程序内部的一条执行流程
      一个进程中允许多个线程，至少有一个线程称作`主线程`
      一个进程中多个线程`共享内存单元`
  异步 Future
    异步编程是一种允许任务在后台发起的执行模式，而无需等待其完成即可继续执行后续代码
创建和启动
  进程
    使用`ProcessBuilder` >java[1]
    使用 `Runtime.exec() `(旧方式，不推荐) >java++
  线程
    继承`Thread`类 >java++
      优点：简单、直接
      缺点：java单继承，扩展性差
    实现 `Runnable` 接口 >java++
      优点：接口多实现，扩展性查
      优点：接口多实现，扩展性高
    线程池创建 >java++
  异步
    使用 `CompletableFuture` (现代首选，Java 8+) >java++
    使用 `Future` + `ExecutorService` (传统方式) >java++
    使用 `虚拟线程` >java++
线程通信
  线程在执行过程中，可以将数据传递给另外一个线程
  实现
    实现`Callable`，`FutureTask`>java++
      Call回调，Callable执行完毕，外界获得回调返回值
      优点：可以通过回调获取线程执行结果
      缺点：造成线程阻塞
    异步回调
      回调接口实现>java++
      Lambda表达>java++
      回调地狱
        回调地狱是指在异步编程中，执行多个连续的异步操作时回调函数层层嵌套，形成深度嵌套的代码结构
        代码难以阅读、理解和维护。
        解决办法
          CompletableFuture链式调用>java[6]
          虚拟线程>java[8]
基本方法 >java+=5
  线程名称：`thread.getName()`
    主线程：main
    子线程：thread-xx
  命名线程：`thread.setName(String str)`
  获取当前正在执行的线程：Thread.getcurrentThread()
生命周期
  概述
    线程从创建到销毁经历不同阶段
    研究的目的是分析不同阶段需要做不同的事情
  线程生命周期五大状态
    创建
      Thread thread = new Thread()  >java++
    就绪
      thread.start() >java++
    运行
      获得执行权
      失去执行权#被抢走 -> 就绪
    阻塞
      阻塞 -> 就绪
      BLOCKED
        等待进入 synchronized 代码块/方法
        持有锁的线程释放了锁，且该线程竞争到了锁 -> 就绪
      WAITING
        其他线程调用 Object.notify()/notifyAll()
        目标线程执行完毕 (对于join无参方法)
      TIMED_WAITING
        调用了某些方法
          join(millis)：插队
          sleep(millis)：休眠
          wait()：等待
        指定的超时时间到期，或其他线程在超时前发出了通知
    终止
      run() 执行完毕
        使用flag控制
      run() 发生异常
        thread.interrupted()
    生命周期综合示例>java++
