概述
	OOP(Object Oriented Programing)：面向对象编程
	面向对象编程（Java、C++、C#）和面向过程编程（C）
	面向对象编程(OOP)是一种编程范式，它以对象为核心，将数据和操作数据的方法组合在一起形成对象。OOP主要基于几个核心概念：封装、继承、多态和抽象
包（package）
	包(Package)是一种代码组织机制，用于将相关的类、接口和其他资源文件逻辑分组在一起。它类似于文件系统中的文件夹
	分类
		工程/项目包
			区分不同工程 / 项目
			命名：域名的倒写 + . + 项目名称，如：com.baidu.map
		功能包
			对代码按照功能进行分类管理
			命名：不能加复数s，比如：test、util、db
	包名的命名规范
		Java命名规范
		全部要求小写，不能加复数
	声明包
		声明当前类所在的包，必须放首行 >java[1]
		package com.miaogu.oop.test >java
	导入包
		声明当前类中使用的类。位于那个包下 >java++
		import java.util.Scanner >java
		导入包下所有内容：import  com.miaogu.oop.test.* >java++
		无需导包
			自动导包
			import java.lang 内置工具类无需导包
		导包快捷键：`Alt` + `Enter`
	同一个包下不能存在同名类，不同可以
类和对象
	类和对象的关系
		类
			类是由对象抽象的模板
			类属于引用类型
		对象
			对象是类的具体实例（实物）
	类的定义
		class定义类 >java++
		变量表达属性（成员变量）>java
		方法表达行为 >java
	对象
		创建 new (实例化对象) >java++
		对象调用自身属性/方法：miaogu.age / miaogu.sleep() >java
		Java中万事万物皆为对象。 >java
	类使用大驼峰命名法（PascalCase）
	文件名称和public修饰的类名保持一致
方法
	返回值类型 方法名称(方法参数, ...more) >java++
	方法名称使用小驼峰（camelCase）命名方式
	方法参数
		作用：接收数据
		形参和实参
			形式参数
				定义时的参数：void sleep(String time) -> time这个时间字符串为形式参数
				重要是数据类型。形参名称不重要
					方法重载：方法名相同，参数不同
						参数类型不同 >java++
						参数数量不同 >java
				作用域：方法的任意位置
				使用完毕，内存自动回收
			实际参数
				调用时的参数：miaogu.sleep("22:00") -> 22:00 为实际参数 >java++
		全局变量和局部变量
			全局变量
				声明在方法外部，类的内部的变量 >java++
				初始值为默认值 >java
				作用域：类的内部任意位置
				内存无法自动释放
			局部变量
				声明在方法或者代码块内部 >java
				局部变量必须初始化才可以使用 >java
				作用域：声明所在的方法/代码块
				使用完毕，内存自动回收
		值传递/引用传递
			值传递
				八大基本类型和String
				传递的是数据的值，函数内修改其参数值，对原始数据无影响 >java++
			引用传递
				除了String外的引用类型
				传递的是数据的内存地址
				方法内修改引用对象的属性会影响原始数据 >java++
				方法内修改引用本身（如 `new`）不影响原始引用 >java
				如果不想修改传入的原始数据，需要创建参数副本（创建传入对象的深拷贝或浅拷贝）
					浅拷贝
						创建内存地址不同的引用类型对象，但是引用类型的字段，仍然指向的是堆内存中同一个子对象 >java++
						Object.clone() 默认是浅拷贝 >java
					深拷贝
						创建内存地址不同的引用类型对象，递归地复制原对象及其所有引用的对象 >java
						通过重写类的clone方法实现深拷贝 >java
		可变参数
			`Jdk5`新增的功能。指`参数个数`可变 >java++
			参数数据类型后使用`...`定义可变参数 >java
			特点
				参数数量灵活（`0`~`N`个）
				可以传入`数组`
				内部以`数组`形式处理
			注意事项
				在`方法`中`最多`只能有`一个`可变参数
				可变参数`必须`在参数列表的`最后`一位
	方法返回类型和返回值
		方法 / 函数向 外部（调用者）返回\提供一个指定类型的结果
		返回类型：返回数据的类型
		返回值：通过`return`返回数据
		void类型
			`void` 是无返回，是一种特殊的返回类型
			`void`的方法也可以使用return。表示`终止方法`的执行
	构造器/构造方法()
		作用：用来构造对象/实例化对象，并给属性赋值
		定义
			方法名必须和类名保持一致
			不能有返回类型，包括void
		使用
			new / 实例化对象的时候，被系统调用
		隐式构造器
			当类中没有定义显示构造器的时候，系统创建一个无参的空的构造器，称为隐式构造器
			当类中有显示构造器的时候，系统不再自动创建隐式构造器
	toString()
		当对象需要转换成字符串的时候，调用`toString()`方法使用其返回值
			触发`自动转换`时，无需手动调用。 >java[17]
			当未定义toString()方法的时候，使用内置方法打印实例对象的内存地址。 >java++
面向对象三大特性
	封装
		它将对象的属性和行为（方法）捆绑在一起，并隐藏内部实现细节，仅对外暴露必要的接口
		作用：实现低耦合/高内聚
			低耦合：不同模块之间的关联越少越好
			高内聚：同一个模块的功能越完善越好
		封装性：不允许外部直接操作属性，在类的内部提供操作属性的方法。（实现高内聚）
		实现
			将属性/成员变量私有化（private修饰符）
			setter / getter>java++
				对于普通成员变量，使用get + 成员名称 / set + 成员名称(getName，setName)
				对于布尔值类型属性，使用 成员名称 / set + 成员名称(isMale，setIsMale)
		注意事项
			对单个对象操作的其他方法可定义在类内部
			类外（Util/ Service类）
				如果定义的是实体/模板类，功能方法应定义类外
				多个对象的共用方法应定义在类外
			当方法内部存在可复用部分，应当方法内联，尽量避免编写重复代码
	继承
		作用：实现代码复用
		概念：允许一个类（子类/派生类）基于另一个类（父类/基类）来构建
		术语
			父类、基类、超类（super class）
			子类、派生类（child class）
			继承 extends
		规则
			单继承：一个子类只能有一个父类
			多层继承：父类有父类，子类有子类
			所有的类都继承Object
			父类中不是所有内容都能被继承
				private
				构造器：无法被继承，但是被子类调用
	多态
		同一个行为（方法）在不同的对象上具有不同的实现方式。
		概念：对象在编译时和运行时状态不同
		子类型多态：类型转换
			自动类型转换 / 向上转型
				IXxxable = new Xxx();
			强制类型转换 / 向下转型
				A a = (a) Xxx();
				强制有风险，类型不匹配，ClassCastException
				类型判断：instanceof
				if (a instanceof A b) {b}
		参数多态：泛型
			概念
				泛泛的类型，定义时不具体指明某种数据类型（类型参数）
				JDK5后支持泛型
				泛型的核心是`类型擦除`。编译时检查泛型类型，运行时擦除转换为原始类型或限定类型。
			Object实现多类型
				没有泛型前需要定义Object对象实现不同参数类型支持 >java[23]
				缺点：每次使用需要类型判断和强制转换，系统处理也麻烦
			实现泛型
				java的泛型只能代表引用类型
				常用的泛型名称
					T：type 类型
					E：element 元素
					N：number 数值
					K：key 键
					V：value 值
				泛型类型可以在其定义下的任意位置使用
				泛型类
					class Identifier <T, I, ...args> {} >java++
				泛型接口：interface Identifier <T, I, ...args> {} >java++
				泛型方法：<R> R process(R input) >java++
			类型变量的限定
				限定T的类型只能是限定类型的子类型 >java++
				<T extends BoundingType>
				可以使用 & 分割限定类型 >java
				T 和 限定类型 可以是类，也可以是接口
			通配符
				定义方法参数和变量中表示任意类型，注意和Object区别
				Type<?> identifier
				逆变和协变
					协变 <? extends BoundingType>
						限定传入类型必须是子类型，只读不写 >java++
						子类能上转型到父类对象，所以可以读 >java
						写入时编译器不知道具体子类是什么，所以Java禁止写入 >java
					逆变 <? super  BoundingType>
						限定传入类型必须是父类型，只写不读 >java++
						父类能够直接写入子类对象内容，所以可以写 >java
						读取时可能是具体子类，所以返回Object，禁止读取 >java
					实际编程可以使用类型判断和强制类型转换来取消逆变协变的读写行为，但不推荐
					逆变协变适用生产者/消费者模型，进行读写安全限制
			注意事项
				不能在实例化时使用类型变量，如 new T()
				不能构造泛型数组
				不能再静态字段和方法中引入泛型类型变量
				不能抛出或捕获泛型类的实例
访问权限修饰符
	作用：控制内容的访问权限
	public：公有的
		任意位置都可以使用
		用于公有的工具类
	protected：受保护的
		本类、本包、子类中可以使用
		用于父类
	无修饰
		本类、本包中可以使用
		用于内部类
	private：私有的
		本类中可以使用
		用于封装性
	类、接口
		只有 public、无修饰 两种修饰符
		一个java文件中只能有一个public类
方法重载和方法重写
	方法重载
		概念：同一个类中，多个方法重名
		方法名相同，参数不同（参数类型和个数不同）>java[32]
		注意
			访问权限修饰符、返回类型无法决定重载
			构造方法可以重载
	方法重写
		概念：子类重写父类方法
		添加`@Override: 表示当前方法是重写父类的方法`
		规则（二同二小一大）
			方法名、参数相同
			返回类型和抛出的异常范围，和父类一致或者更小
			访问权限和父类一致或更大
this和super
	this
		this指向当前对象，表示当前实例化对象本身
		通过点(.)调用自身的属性和方法
			属性名称和形参名相同时使用this点调用 >java[34]
		this()调用自身的构造方法 >java++
	super
		super直接指向父类
		通过点(.)调用父类的属性和方法 >java++
		super()调用父类的构造方法
			子类必须调用父类的构造方法。  >java++
			父类存在无参构造时，自动调用父类的无参构造 >java
	this()、super()只能放在构造方法的首行
final
	final的含义是`最终的`，无法改变的
	修饰常量，值无法改变 >java[39]
	修饰方法，无法被重写 >java++
	修饰类，无法被继承 >java++
	优点：被final修饰的，无需考虑改变，处理速度快。一般工具类定义为final（如String） >java++
static
	static含义是`静态的`
	修饰变量、方法、构造代码块、内部类
	static修饰的事物是独立于实例对象的，静态的内容共享一块静态存储区
	实例变量/方法 和 类变量/方法
		实例变量/实例方法：普通的变量和方法，由实例对象调用 >java++
		静态变量/静态方法：静态的变量和方法，由类调用 >java
	代码块 / 构造代码块 / 静态构造代码块
		代码块：使用代码块括起来的一段代码 >java++
		构造代码块：在方法外部定义的代码块，每次实例化对象都会调用1次构造代码块 >java
		静态构造代码块：使用static修饰的构造代码块。类加载时执行1次的初始化操作 >java
	注意事项和主要应用场景
		注意事项
			静态的内容一旦被分配内存，无法回收释放，直到应用停止
			静态方法只能调用类变量和类方法 >java++
			静态方法中无法使用this和super关键字 >java
			子类无法重写父类的静态方法 >java
		应用场景
			状态码：静态常量
			工具类的方法
			一次性初始化操作：静态构造代码块
抽象
	抽象方法
		只有方法的声明，没有方法的实现
		abstract 抽象 >java[46]
		public abstract void eat();
		抽象方法只能存在于抽象类中
	抽象类
		抽象类无法实例化对象的，只能被子类继承
			抽象类中的构造方法是否可以存在？做什么用。
				可以存在。被子类super调用的
		使用abstract修饰的类称之为抽象类 >java++
		抽象类中可以有普通类的任意内容 >java++
		子类如果继承了抽象父类，或实现抽象方法，或定义为抽象类 >java
接口
	由于抽象类可以包含其他内容。抽象的不够彻底。开发中往往把抽象方法提取出来放到接口中统一定义
	作用：定义行为规范
	定义/声明
		关键字：interface >java++
		一般规范：I + 名称 + able >java
	内部组成
		JDK8之前
			公有的静态常量
				省略前缀：public static final
			公有的抽象方法
				省略前缀：public abstract
		JDK8+
			静态方法
			默认方法
				修饰符：default >java++
				默认方法按需重写 >java
	实现
		关键字：implements >java++
		如果子类实现接口，或实现接口中的抽象方法，或定义为抽象类 >java
		多实现：一个子类可以实现多个接口 >java
	父接口
		接口可以有多个父接口
		关键字：extends >java++
内部类
	概念：一个类定义在另一个类的内部
	优缺点：
		优点：内部类可以直接调用外部类任何组成部分
		缺点：破坏了类的结构，而且使用非常麻烦
		JDK8，内部类的语法基本被Lambda表达式代替
	分类
		普通内部类 >java++
		静态内部类 >java++
		匿名内部类（最主要应用场景） >java++
枚举
	枚举定义一组固定的常量，属于引用类型 >java+=2
	作用：代替静态常量实现状态码
	定义：enum Gender { MAN, WOMEN} >java
	使用： Gender gender = Gender.MAN; >java++
	枚举判断支持 if 和 switch >java++
	每个枚举值默认都是由public static final 修饰的
	常用方法
		values()：类似于类的静态方法，返回当前枚举类型的所有值
		name()：获得枚举变量的名称
		ordinal()：获得枚举变量的值
		equals()：判断两个枚举变量是否相等，等价于==
	内部组成
		枚举值的本质是类的实例对象
		枚举同样包括成员变量、构造方法、属性、方法
