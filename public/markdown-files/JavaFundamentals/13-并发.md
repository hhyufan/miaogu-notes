# 并发

#### 1. 并发概述

系统具有`处理多个任务`的能力

- 进程和线程
  - 进程 Process
    - 每一个独立执行程序
    - 进程是操作系统进行资源分配、调度管理的`最小单位`
    - 每个进程拥有`独立内存单元`
  - 线程 Thread
    - 线程是进程中/程序内部的一条执行流程
    - 一个进程中允许多个线程，至少有一个线程称作`主线程`
    - 一个进程中多个线程`共享内存单元`
- 多线程：进程中存在`多个线程`，线程分别`抢占CPU`来执行
- 异步 Future
  - 异步编程是一种允许任务在后台发起的执行模式，而无需等待其完成即可继续执行后续代码



#### 2. 创建和启动

##### 2.1 进程

- 使用`ProcessBuilder` (推荐)

  ```java
  import java.io.IOException;
  
  public class ProcessCreation {
      public static void main(String[] args) {
          // 1. 使用 ProcessBuilder (推荐)
          ProcessBuilder processBuilder = new ProcessBuilder("notepad.exe");
          // 可以设置工作目录、环境变量等
          // processBuilder.directory(new File("C:\\MyDir"));
          
          try {
              Process process = processBuilder.start(); // 启动外部进程
              System.out.println("进程已启动，PID: " + process.pid());
              
              // 等待进程结束（当前线程会阻塞）
              int exitCode = process.waitFor();
              System.out.println("进程结束，退出码: " + exitCode);
              
          } catch (IOException | InterruptedException e) {
              e.printStackTrace();
          }
      }
  }

- 使用 `Runtime.exec() `(旧方式，不推荐)

  ```java
  import java.io.IOException;
  
  public class ProcessCreation {
      public static void main(String[] args) {
          // 2. 使用 Runtime.exec() (旧方式，不推荐)
          try {
              Process process = Runtime.getRuntime().exec("calc.exe");
              // ... 同样可以用 waitFor() 等待
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

##### 2.2 线程

- 继承`Thread`类

  ```java
  public class ThreadCreation {
      public static void main(String[] args) {
          // 方式一：继承 Thread 类
          class MyThread extends Thread {
              @Override
              public void run() {
                  System.out.println("线程运行中: " + Thread.currentThread().getName());
              }
          }
          MyThread thread1 = new MyThread();
          thread1.start(); // 必须调用 start()，而不是 run()
  
          // 方式二：实现 Runnable 接口 (更常用，更灵活)
          Runnable task = new Runnable() {
              @Override
              public void run() {
                  System.out.println("Runnable线程: " + Thread.currentThread().getName());
              }
          };
          Thread thread2 = new Thread(task);
          thread2.start();
  
          // 方式三：使用 Lambda 表达式 (Java 8+，最简洁)
          Thread thread3 = new Thread(() -> {
              System.out.println("Lambda线程: " + Thread.currentThread().getName());
          });
          thread3.start();
      }
  }
  ```

- 实现 `Runnable` 接口

  ```java
  public class ThreadCreation {
      public static void main(String[] args) {
          // 方式二：实现 Runnable 接口 (更常用，更灵活)
          Runnable task = new Runnable() {
              @Override
              public void run() {
                  System.out.println("Runnable线程: " + Thread.currentThread().getName());
              }
          };
          Thread thread2 = new Thread(task);
          thread2.start();
  
          // 方式三：使用 Lambda 表达式 (Java 8+，最简洁)
          Thread thread3 = new Thread(() -> {
              System.out.println("Lambda线程: " + Thread.currentThread().getName());
          });
          thread3.start();
      }
  }
  ```

- `线程池`创建

  ```java
  public class ThreadCreation {
      public static void main(String[] args) { 
          // 方式四：使用线程池 (生产环境首选)
          // 创建固定大小的线程池
          java.util.concurrent.ExecutorService executor = java.util.concurrent.Executors.newFixedThreadPool(4);
          
          // 提交任务给线程池执行
          for (int i = 0; i < 10; i++) {
              final int taskId = i;
              executor.submit(() -> {
                  System.out.println("任务 " + taskId + " 由线程池执行: " + Thread.currentThread().getName());
              });
          }
          
          // 关闭线程池（不再接受新任务，等待已提交任务完成）
          executor.shutdown();
      }
  }
  ```

##### 2.3 异步

- 使用 `CompletableFuture` (现代首选，Java 8+)

  ```java
  import java.util.concurrent.CompletableFuture;
  import java.util.concurrent.Executors;
  
  public class SimpleAsync {
      public static void main(String[] args) throws Exception {
          // 基本异步任务
          CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
              sleep(1000); // 模拟耗时操作
              return "任务完成！";
          });
          
          System.out.println("主线程继续工作...");
          
          // 获取结果（会阻塞等待）
          String result = future.get();
          System.out.println(result);
          
          // 链式处理示例
          CompletableFuture.supplyAsync(() -> "hello")
              .thenApply(s -> s + " world")
              .thenAccept(System.out::println); // 输出: hello world
      }
      
      private static void sleep(long ms) {
          try { Thread.sleep(ms); } catch (InterruptedException e) {}
      }
  }
  ```

- 使用 `Future` + `ExecutorService` (传统方式)

  ```java
  import java.util.concurrent.*;
  
  public class SimpleFuture {
      public static void main(String[] args) throws Exception {
          ExecutorService executor = Executors.newSingleThreadExecutor();
          
          Future<String> future = executor.submit(() -> {
              sleep(2000);
              return "Future任务结果";
          });
          
          System.out.println("任务已提交，继续处理其他事情...");
          
          // 等待并获取结果
          String result = future.get();
          System.out.println("收到结果: " + result);
          
          executor.shutdown();
      }
      
      private static void sleep(long ms) {
          try { Thread.sleep(ms); } catch (InterruptedException e) {}
      }
  }
  ```

- 使用`虚拟线程`

  ```java
  // 需要 --enable-preview (Java 19/20) 或 Java 21+
  public class VirtualThreadDemo {
      public static void main(String[] args) {
          // 语法与传统线程几乎一致，但背后是高效的异步调度
          // 1. 直接启动
          Thread.startVirtualThread(() -> {
              System.out.println("运行在虚拟线程: " + Thread.currentThread());
          });
  
          // 2. 使用 Builder 创建
          Thread vt = Thread.ofVirtual().name("my-vt-").start(() -> {
              System.out.println("带名字的虚拟线程: " + Thread.currentThread().getName());
          });
  
          // 3. 使用 Executors 创建 (推荐)
          try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
              for (int i = 0; i < 10_000; i++) { // 轻松创建大量虚拟线程
                  executor.submit(() -> {
                      Thread.sleep(Duration.ofSeconds(1));
                      System.out.println("Task executed: " + Thread.currentThread());
                      return null;
                  });
              }
          } // executor.close() 会等待所有任务完成
          System.out.println("所有虚拟线程任务已完成");
      }
  }
  ```

#### 3. 线程通信

线程在执行过程中，可以将数据传递给另外一个线程

##### 3.1 实现

- 实现`Callable`，`FutureTask`

  Call回调，Callable执行完毕，外界获得回调返回值
  
  - 优点：可以通过回调获取线程执行结果
  - 缺点：造成线程阻塞

  ```java
  import java.util.concurrent.*;
  
  public class CallableExample {
      public static void main(String[] args) throws Exception {
          // 创建 Callable 任务
          Callable<String> task = new Callable<String>() {
              @Override
              public String call() throws Exception {
                  Thread.sleep(2000); // 模拟耗时操作
                  return "任务执行完成，返回结果";
              }
          };
          
          // 使用 FutureTask 包装 Callable
          FutureTask<String> futureTask = new FutureTask<>(task);
          
          // 启动线程执行任务
          Thread thread = new Thread(futureTask);
          thread.start();
          
          System.out.println("主线程继续执行其他工作...");
          
          // 获取执行结果（会阻塞等待）
          String result = futureTask.get();
          System.out.println("收到线程执行结果: " + result);
      }
  }
  ```

- 异步回调

  - 回调接口实现

    ```java
    // 定义回调接口
    interface TaskCallback {
        void onSuccess(String result);
        void onError(Exception error);
    }
    
    public class CallbackExample {
        public static void main(String[] args) {
            // 使用回调接口
            executeTaskAsync("处理数据", new TaskCallback() {
                @Override
                public void onSuccess(String result) {
                    System.out.println("任务成功: " + result);
                }
                
                @Override
                public void onError(Exception error) {
                    System.out.println("任务失败: " + error.getMessage());
                }
            });
            
            System.out.println("主线程继续执行...");
            
            // 防止主线程过早结束
            try { Thread.sleep(3000); } catch (InterruptedException e) {}
        }
        
        // 异步执行任务的方法
        public static void executeTaskAsync(String taskName, TaskCallback callback) {
            new Thread(() -> {
                try {
                    Thread.sleep(2000); // 模拟耗时操作
                    String result = taskName + " 执行完成";
                    callback.onSuccess(result);
                } catch (Exception e) {
                    callback.onError(e);
                }
            }).start();
        }
    }
    ```

  - Lambda表达式

    ```java
    public class LambdaCallbackExample {
        public static void main(String[] args) {
            // 使用 Lambda 表达式简化回调
            executeTaskAsync("数据处理任务", 
                result -> System.out.println("成功: " + result),
                error -> System.out.println("失败: " + error.getMessage())
            );
            
            System.out.println("主线程继续工作...");
            
            // 防止主线程过早结束
            try { Thread.sleep(3000); } catch (InterruptedException e) {}
        }
        
        // 支持 Lambda 的异步方法
        public static void executeTaskAsync(String taskName, 
                                          java.util.function.Consumer<String> onSuccess,
                                          java.util.function.Consumer<Exception> onError) {
            new Thread(() -> {
                try {
                    Thread.sleep(2000); // 模拟耗时操作
                    String result = taskName + " 完成";
                    onSuccess.accept(result);
                } catch (Exception e) {
                    onError.accept(e);
                }
            }).start();
        }
    }
    ```
> **回调地狱 (Callback Hell)**
>
> 回调地狱是指在异步编程中，当需要执行多个连续的异步操作时，回调函数层层嵌套，形成深度嵌套的代码结构，使代码难以阅读、理解和维护。
>
> **典型的回调地狱示例：**
> ```java
> // 模拟多个异步操作的嵌套
> executeTaskAsync("任务1", 
>     result1 -> {
>         System.out.println("任务1完成: " + result1);
>         executeTaskAsync("任务2", 
>             result2 -> {
>                 System.out.println("任务2完成: " + result2);
>                 executeTaskAsync("任务3", 
>                     result3 -> {
>                         System.out.println("任务3完成: " + result3);
>                     },
>                     error3 -> System.out.println("任务3失败: " + error3.getMessage())
>                 );
>             },
>             error2 -> System.out.println("任务2失败: " + error2.getMessage())
>         );
>     },
>     error1 -> System.out.println("任务1失败: " + error1.getMessage())
>    );
>    ```
>    
>    **回调地狱的问题：**
>    - 代码可读性差，难以理解执行流程
>    - 错误处理复杂，每层都需要处理异常
> - 代码维护困难，修改逻辑需要在多层嵌套中操作
> - 调试困难，堆栈跟踪复杂
>
> **解决回调地狱的方法（参考异步创建）：**
> 
> - 使用 CompletableFuture 链式调用
> 
> - 使用虚拟线程 (Java 21+)

#### 4. 基本方法

- **线程名称**：`thread.getName()`
  - 主线程：main
  - 子线程：thread-xx
- **命名线程**：`thread.setName(String str)`
- **获取当前正在执行的线程**：`Thread.getCurrentThread()`

```java
public class ThreadBasicMethods {
    public static void main(String[] args) {
        // 获取当前线程（主线程）
        Thread mainThread = Thread.currentThread();
        System.out.println("主线程名称: " + mainThread.getName());
        
        // 创建子线程
        Thread childThread = new Thread(() -> {
            Thread current = Thread.currentThread();
            System.out.println("子线程默认名称: " + current.getName());
        });
        
        // 设置线程名称
        childThread.setName("MyWorkerThread");
        childThread.start();
        
        // 再次获取名称
        System.out.println("子线程设置后名称: " + childThread.getName());
    }
}
```

#### 5. 生命周期

##### 5.1 概述

线程从创建到销毁经历不同阶段，研究的目的是分析不同阶段需要做不同的事情。

##### 5.2 线程生命周期五大状态

- **创建 (NEW)**
  ```java
  Thread thread = new Thread();
  ```

- **就绪 (RUNNABLE)**
  ```java
  thread.start(); // 线程进入就绪状态，等待CPU调度
  ```

- **运行 (RUNNING)**
  - 获得执行权
  - 失去执行权（被抢走）→ 就绪

- **阻塞 (BLOCKED/WAITING/TIMED_WAITING)**
  - **BLOCKED**：等待进入 synchronized 代码块/方法
    - 持有锁的线程释放了锁，且该线程竞争到了锁 → 就绪
  - **WAITING**：无限期等待
    - 其他线程调用 `Object.notify()`/`notifyAll()`
    - 目标线程执行完毕（对于join无参方法）
  - **TIMED_WAITING**：有时限的等待
    - 调用了某些方法：
      - `join(millis)`：插队
      - `sleep(millis)`：休眠
      - `wait(timeout)`：等待
    - 指定的超时时间到期，或其他线程在超时前发出了通知

- **终止 (TERMINATED)**
  - `run()` 执行完毕
    - 使用flag控制
  - `run()` 发生异常
    - `thread.interrupt()`

```java
public class ThreadLifecycleDemo {
    private static volatile boolean running = true;
    
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            System.out.println("线程状态: " + Thread.currentThread().getState()); // RUNNABLE
            
            while (running) {
                try {
                    Thread.sleep(1000); // TIMED_WAITING
                    System.out.println("工作中...");
                } catch (InterruptedException e) {
                    System.out.println("线程被中断");
                    break;
                }
            }
            System.out.println("线程即将结束");
        });
        
        System.out.println("创建后状态: " + worker.getState()); // NEW
        
        worker.start();
        System.out.println("启动后状态: " + worker.getState()); // RUNNABLE
        
        Thread.sleep(3000);
        
        // 优雅停止线程
        running = false;
        worker.join(); // 等待线程结束
        
        System.out.println("结束后状态: " + worker.getState()); // TERMINATED
    }
}
```