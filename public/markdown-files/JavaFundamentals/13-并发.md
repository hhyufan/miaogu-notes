# 并发

#### 1. 并发概述

系统具有`处理多个任务`的能力

- 进程和线程
  - 进程 Process
    - 每一个独立执行程序
    - 进程是操作系统进行资源分配、调度管理的`最小单位`
    - 每个进程拥有`独立内存单元`
  - 线程 Thread
    - 线程是进程中/程序内部的一条执行流程
    - 一个进程中允许多个线程，至少有一个线程称作`主线程`
    - 一个进程中多个线程`共享内存单元`
- 多线程：进程中存在`多个线程`，线程分别`抢占CPU`来执行
- 异步 Future
  - 异步编程是一种允许任务在后台发起的执行模式，而无需等待其完成即可继续执行后续代码



#### 2. 创建和启动

##### 2.1 进程

- 使用`ProcessBuilder` (推荐)

  ```java
  import java.io.IOException;
  
  public class ProcessCreation {
      public static void main(String[] args) {
          // 1. 使用 ProcessBuilder (推荐)
          ProcessBuilder processBuilder = new ProcessBuilder("notepad.exe");
          // 可以设置工作目录、环境变量等
          // processBuilder.directory(new File("C:\\MyDir"));
          
          try {
              Process process = processBuilder.start(); // 启动外部进程
              System.out.println("进程已启动，PID: " + process.pid());
              
              // 等待进程结束（当前线程会阻塞）
              int exitCode = process.waitFor();
              System.out.println("进程结束，退出码: " + exitCode);
              
          } catch (IOException | InterruptedException e) {
              e.printStackTrace();
          }
      }
  }

- 使用 `Runtime.exec() `(旧方式，不推荐)

  ```java
  import java.io.IOException;
  
  public class ProcessCreation {
      public static void main(String[] args) {
          // 2. 使用 Runtime.exec() (旧方式，不推荐)
          try {
              Process process = Runtime.getRuntime().exec("calc.exe");
              // ... 同样可以用 waitFor() 等待
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

##### 2.2 线程

- 继承`Thread`类

  ```java
  public class ThreadCreation {
      public static void main(String[] args) {
          // 方式一：继承 Thread 类
          class MyThread extends Thread {
              @Override
              public void run() {
                  System.out.println("线程运行中: " + Thread.currentThread().getName());
              }
          }
          MyThread thread1 = new MyThread();
          thread1.start(); // 必须调用 start()，而不是 run()
  
          // 方式二：实现 Runnable 接口 (更常用，更灵活)
          Runnable task = new Runnable() {
              @Override
              public void run() {
                  System.out.println("Runnable线程: " + Thread.currentThread().getName());
              }
          };
          Thread thread2 = new Thread(task);
          thread2.start();
  
          // 方式三：使用 Lambda 表达式 (Java 8+，最简洁)
          Thread thread3 = new Thread(() -> {
              System.out.println("Lambda线程: " + Thread.currentThread().getName());
          });
          thread3.start();
      }
  }
  ```

- 实现 `Runnable` 接口

  ```java
  public class ThreadCreation {
      public static void main(String[] args) {
          // 方式二：实现 Runnable 接口 (更常用，更灵活)
          Runnable task = new Runnable() {
              @Override
              public void run() {
                  System.out.println("Runnable线程: " + Thread.currentThread().getName());
              }
          };
          Thread thread2 = new Thread(task);
          thread2.start();
  
          // 方式三：使用 Lambda 表达式 (Java 8+，最简洁)
          Thread thread3 = new Thread(() -> {
              System.out.println("Lambda线程: " + Thread.currentThread().getName());
          });
          thread3.start();
      }
  }
  ```

- `线程池`创建

  ```java
  public class ThreadCreation {
      public static void main(String[] args) { 
          // 方式四：使用线程池 (生产环境首选)
          // 创建固定大小的线程池
          java.util.concurrent.ExecutorService executor = java.util.concurrent.Executors.newFixedThreadPool(4);
          
          // 提交任务给线程池执行
          for (int i = 0; i < 10; i++) {
              final int taskId = i;
              executor.submit(() -> {
                  System.out.println("任务 " + taskId + " 由线程池执行: " + Thread.currentThread().getName());
              });
          }
          
          // 关闭线程池（不再接受新任务，等待已提交任务完成）
          executor.shutdown();
      }
  }
  ```

##### 2.3 异步

- 使用 `CompletableFuture` (现代首选，Java 8+)

  ```java
  import java.util.concurrent.CompletableFuture;
  import java.util.concurrent.Executors;
  
  public class SimpleAsync {
      public static void main(String[] args) throws Exception {
          // 基本异步任务
          CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
              sleep(1000); // 模拟耗时操作
              return "任务完成！";
          });
          
          System.out.println("主线程继续工作...");
          
          // 获取结果（会阻塞等待）
          String result = future.get();
          System.out.println(result);
          
          // 链式处理示例
          CompletableFuture.supplyAsync(() -> "hello")
              .thenApply(s -> s + " world")
              .thenAccept(System.out::println); // 输出: hello world
      }
      
      private static void sleep(long ms) {
          try { Thread.sleep(ms); } catch (InterruptedException e) {}
      }
  }
  ```

- 使用 `Future` + `ExecutorService` (传统方式)

  ```java
  import java.util.concurrent.*;
  
  public class SimpleFuture {
      public static void main(String[] args) throws Exception {
          ExecutorService executor = Executors.newSingleThreadExecutor();
          
          Future<String> future = executor.submit(() -> {
              sleep(2000);
              return "Future任务结果";
          });
          
          System.out.println("任务已提交，继续处理其他事情...");
          
          // 等待并获取结果
          String result = future.get();
          System.out.println("收到结果: " + result);
          
          executor.shutdown();
      }
      
      private static void sleep(long ms) {
          try { Thread.sleep(ms); } catch (InterruptedException e) {}
      }
  }
  ```

- 使用`虚拟线程`

  ```java
  // 需要 --enable-preview (Java 19/20) 或 Java 21+
  public class VirtualThreadDemo {
      public static void main(String[] args) {
          // 语法与传统线程几乎一致，但背后是高效的异步调度
          // 1. 直接启动
          Thread.startVirtualThread(() -> {
              System.out.println("运行在虚拟线程: " + Thread.currentThread());
          });
  
          // 2. 使用 Builder 创建
          Thread vt = Thread.ofVirtual().name("my-vt-").start(() -> {
              System.out.println("带名字的虚拟线程: " + Thread.currentThread().getName());
          });
  
          // 3. 使用 Executors 创建 (推荐)
          try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
              for (int i = 0; i < 10_000; i++) { // 轻松创建大量虚拟线程
                  executor.submit(() -> {
                      Thread.sleep(Duration.ofSeconds(1));
                      System.out.println("Task executed: " + Thread.currentThread());
                      return null;
                  });
              }
          } // executor.close() 会等待所有任务完成
          System.out.println("所有虚拟线程任务已完成");
      }
  }
  ```

#### 3. 线程通信

线程在执行过程中，可以将数据传递给另外一个线程

##### 3.1 实现

- 实现`Callable`，`FutureTask`

  Call回调，Callable执行完毕，外界获得回调返回值
  
  - 优点：可以通过回调获取线程执行结果
  - 缺点：造成线程阻塞

  ```java
  import java.util.concurrent.*;
  
  public class CallableExample {
      public static void main(String[] args) throws Exception {
          // 创建 Callable 任务
          Callable<String> task = new Callable<String>() {
              @Override
              public String call() throws Exception {
                  Thread.sleep(2000); // 模拟耗时操作
                  return "任务执行完成，返回结果";
              }
          };
          
          // 使用 FutureTask 包装 Callable
          FutureTask<String> futureTask = new FutureTask<>(task);
          
          // 启动线程执行任务
          Thread thread = new Thread(futureTask);
          thread.start();
          
          System.out.println("主线程继续执行其他工作...");
          
          // 获取执行结果（会阻塞等待）
          String result = futureTask.get();
          System.out.println("收到线程执行结果: " + result);
      }
  }
  ```

- 异步回调

  - 回调接口实现

    ```java
    // 定义回调接口
    interface TaskCallback {
        void onSuccess(String result);
        void onError(Exception error);
    }
    
    public class CallbackExample {
        public static void main(String[] args) {
            // 使用回调接口
            executeTaskAsync("处理数据", new TaskCallback() {
                @Override
                public void onSuccess(String result) {
                    System.out.println("任务成功: " + result);
                }
                
                @Override
                public void onError(Exception error) {
                    System.out.println("任务失败: " + error.getMessage());
                }
            });
            
            System.out.println("主线程继续执行...");
            
            // 防止主线程过早结束
            try { Thread.sleep(3000); } catch (InterruptedException e) {}
        }
        
        // 异步执行任务的方法
        public static void executeTaskAsync(String taskName, TaskCallback callback) {
            new Thread(() -> {
                try {
                    Thread.sleep(2000); // 模拟耗时操作
                    String result = taskName + " 执行完成";
                    callback.onSuccess(result);
                } catch (Exception e) {
                    callback.onError(e);
                }
            }).start();
        }
    }
    ```

  - Lambda表达式

    ```java
    public class LambdaCallbackExample {
        public static void main(String[] args) {
            // 使用 Lambda 表达式简化回调
            executeTaskAsync("数据处理任务", 
                result -> System.out.println("成功: " + result),
                error -> System.out.println("失败: " + error.getMessage())
            );
            
            System.out.println("主线程继续工作...");
            
            // 防止主线程过早结束
            try { Thread.sleep(3000); } catch (InterruptedException e) {}
        }
        
        // 支持 Lambda 的异步方法
        public static void executeTaskAsync(String taskName, 
                                          java.util.function.Consumer<String> onSuccess,
                                          java.util.function.Consumer<Exception> onError) {
            new Thread(() -> {
                try {
                    Thread.sleep(2000); // 模拟耗时操作
                    String result = taskName + " 完成";
                    onSuccess.accept(result);
                } catch (Exception e) {
                    onError.accept(e);
                }
            }).start();
        }
    }
    ```
> **回调地狱 (Callback Hell)**
>
> 回调地狱是指在异步编程中，当需要执行多个连续的异步操作时，回调函数层层嵌套，形成深度嵌套的代码结构，使代码难以阅读、理解和维护。
>
> **典型的回调地狱示例：**
> ```java
> // 模拟多个异步操作的嵌套
> executeTaskAsync("任务1", 
>     result1 -> {
>         System.out.println("任务1完成: " + result1);
>         executeTaskAsync("任务2", 
>             result2 -> {
>                 System.out.println("任务2完成: " + result2);
>                 executeTaskAsync("任务3", 
>                     result3 -> {
>                         System.out.println("任务3完成: " + result3);
>                     },
>                     error3 -> System.out.println("任务3失败: " + error3.getMessage())
>                 );
>             },
>             error2 -> System.out.println("任务2失败: " + error2.getMessage())
>         );
>     },
>     error1 -> System.out.println("任务1失败: " + error1.getMessage())
>    );
>    ```
>    
>    **回调地狱的问题：**
>    - 代码可读性差，难以理解执行流程
>    - 错误处理复杂，每层都需要处理异常
> - 代码维护困难，修改逻辑需要在多层嵌套中操作
> - 调试困难，堆栈跟踪复杂
>
> **解决回调地狱的方法（参考异步创建）：**
> 
> - 使用 CompletableFuture 链式调用
> 
> - 使用虚拟线程 (Java 21+)

#### 4. 基本方法

- **线程名称**：`thread.getName()`
  - 主线程：main
  - 子线程：thread-xx
- **命名线程**：`thread.setName(String str)`
- **获取当前正在执行的线程**：`Thread.getCurrentThread()`

```java
public class ThreadBasicMethods {
    public static void main(String[] args) {
        // 获取当前线程（主线程）
        Thread mainThread = Thread.currentThread();
        System.out.println("主线程名称: " + mainThread.getName());
        
        // 创建子线程
        Thread childThread = new Thread(() -> {
            Thread current = Thread.currentThread();
            System.out.println("子线程默认名称: " + current.getName());
        });
        
        // 设置线程名称
        childThread.setName("MyWorkerThread");
        childThread.start();
        
        // 再次获取名称
        System.out.println("子线程设置后名称: " + childThread.getName());
    }
}
```

#### 5. 生命周期

##### 5.1 概述

线程从创建到销毁经历不同阶段，研究的目的是分析不同阶段需要做不同的事情。

##### 5.2 线程生命周期五大状态

- **创建 (NEW)**
  ```java
  Thread thread = new Thread();
  ```

- **就绪 (RUNNABLE)**
  ```java
  thread.start(); // 线程进入就绪状态，等待CPU调度
  ```

- **运行 (RUNNING)**
  - 获得执行权
  - 失去执行权（被抢走）→ 就绪

- **阻塞 (BLOCKED/WAITING/TIMED_WAITING)**
  - **BLOCKED**：等待进入 synchronized 代码块/方法
    - 持有锁的线程释放了锁，且该线程竞争到了锁 → 就绪
    
  - **WAITING**：无限期等待
  
    - 其他线程使用`object.wait()`等待`当前线程`
  
    - 其他线程调用 `object.notify()`/`notifyAll()`恢复就绪
    - 目标线程执行完毕（对于join无参方法）
  
  - **TIMED_WAITING**：有时限的等待
    
    - 调用了某些方法：
      - `join(millis)`：插队
      - `sleep(millis)`：休眠
      - `object.wait(timeout)`：等待
    - 指定的超时时间到期，或其他线程在超时前发出了通知
  
- **终止 (TERMINATED)**
  - `run()` 执行完毕
    - 使用flag控制
  - `run()` 发生异常
    - `thread.interrupt()`

```java
public class ThreadLifecycleDemo {
    private static volatile boolean running = true;
    
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            System.out.println("线程状态: " + Thread.currentThread().getState()); // RUNNABLE
            
            while (running) {
                try {
                    Thread.sleep(1000); // TIMED_WAITING
                    System.out.println("工作中...");
                } catch (InterruptedException e) {
                    System.out.println("线程被中断");
                    break;
                }
            }
            System.out.println("线程即将结束");
        });
        
        System.out.println("创建后状态: " + worker.getState()); // NEW
        
        worker.start();
        System.out.println("启动后状态: " + worker.getState()); // RUNNABLE
        
        Thread.sleep(3000);
        
        // 优雅停止线程
        running = false;
        worker.join(); // 等待线程结束
        
        System.out.println("结束后状态: " + worker.getState()); // TERMINATED
    }
}
```

#### 6.线程同步

多个线程操作`临界资源`的时候，保证达到`数据一致性`，称为`线程同步`

- 临界资源：多个线程同时操作的数据，称为`临界资源`，又叫`共享资源`

- 数据不一致/线程不同步的原因：线程在操作`临界资源`的时候，被其他线程`打断`

  ```java
  public class SimplestDemo {
      static int count = 0; // 共享变量-临界资源
  
      public static void main(String[] args) throws InterruptedException {
          Runnable counter = () -> {
              for (int i = 0; i < 10000; i++) {
                  count++; // 这不是原子操作
              }
          };
          // 创建两个线程，每个线程对count自增10000次
          Thread t1 = new Thread(counter);
          Thread t2 = new Thread(counter);
  
          t1.start();
          t2.start();
  
          t1.join();
          t2.join();
  
          // 结果应该为20000，但实际会小于20000
          System.out.println("最终结果: " + count);
          System.out.println("应该为: 20000");
      }
  }
  ```

##### 6.1 使用`synchronized`关键字

- 修饰方法

  ```java
  // synchronized 方法
  public static synchronized void increment() {
      count++;
  }
  //...
  Runnable counter = () -> {
      for (int i = 0; i < 10000; i++) {
          increment(); // 这不是原子操作
      }
  };
      
  ```

- 修饰代码块（同步代码块）

  - `同步锁`：同步锁是一种**互斥机制**，它通过保证`同一时刻`只有`一个线程`能够访问临界资源来实现`线程同步`。

    - **同步是一种机制**：互斥访问、线程同步的机制

    - **锁是一个对象**：在Java中，同步机制是通过对象的内置锁（monitor lock）来实现的

  ```java
  static final Object lock = new Object(); // 锁对象
  //...
  Runnable counter = () -> {
      for (int i = 0; i < 10000; i++) {
          synchronized (lock) {
              count++;
          }
      }
  };
  ```

##### 6.2 Lock接口

- `Lock`是一个接口，`ReentrantLock`是它的`唯一`的`直接实现类`
- 通过`lock`加锁，通过`unlock`解锁

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockDemo {
    static int count = 0;
    static final Lock lock = new ReentrantLock(); // 创建Lock对象
    
    public static void main(String[] args) throws InterruptedException {
        Runnable counter = () -> {
            for (int i = 0; i < 10000; i++) {
                lock.lock();    // 加锁
                try {
                    count++;    // 临界区操作
                } finally {
                    lock.unlock(); // 解锁（确保一定会执行）
                }
            }
        };
        Thread t1 = new Thread(counter);
        
        Thread t2 = new Thread(counter);
        
        t1.start();
        t2.start();
        
        t1.join();
        t2.join();
        
        System.out.println("最终结果: " + count); // 保证是20000
    }
}
```

>##### **🔒 死锁 (Deadlock)**
>
>死锁是指两个或两个以上的线程在执行过程中，因**争夺资源**而造成的一种**互相等待**的现象。若无外力干涉，这些线程都将无法推进下去。
>
>- 条件`(缺一不可)`：
>
>  - **互斥**：资源独占
>  - **不可抢占**：资源只能主动释放
>  - **请求与保持**：边持有边申请
>  - **循环等待**：A等B，B等A
>
>  ```java
>  public class SimpleDeadlock {
>      private static final Object lock1 = new StringBuffer("lock1");
>      private static final Object lock2 = new StringBuffer("lock2");
>  
>      public static void main(String[] args) {
>          // 使用lambda表达式和var关键字
>          var thread1 = new Thread(() -> acquireLocks(lock1, lock2, "Thread1"));
>          var thread2 = new Thread(() -> acquireLocks(lock2, lock1, "Thread2"));
>  
>          thread1.start();
>          thread2.start();
>      }
>  
>      private static void acquireLocks(Object firstLock, Object secondLock, String threadName) {
>          synchronized (firstLock) {
>              System.out.println(threadName + " acquired "+ firstLock + " lock");
>              synchronized (secondLock) {
>                  System.out.println(threadName + " acquired " + firstLock + " lock");
>              }
>          }
>      }
>  }
>  // result：
>  // Thread2 acquired lock2 lock
>  // Thread1 acquired lock1 lock
>  ```
>
>- 解决方案：
>  - **顺序获取**：所有线程按固定顺序申请锁
>  - **超时放弃**：使用 `lock.tryLock(timeout)`，失败后释放已有锁并重试
>  - **一次性申请**：使用 `Allocator` 类统一申请所有所需资源

#### 7.线程设计模式

##### 7.1 单例模式

确保`一个类`只有`一个实例`，并提供一个`全局访问点`。

- `不允许外界`实例化对象：构造方法`私有化`
- 向外提供`唯一接口(方法)`，返回`对象实例`
- 保持对象的`唯一性`

```Mermaid
classDiagram
    class Singleton {
        -Singleton()
        -static instance: Singleton
        +static getInstance(): Singleton
    }
    Singleton o-- Singleton
```

- 饿汉式（Eager Initialization）`

  **优点：**

  - ✅ 实现简单，代码简洁
  - ✅ 线程安全，无需同步
  - ✅ 性能好，无锁开销

  **缺点：**

  - ❌ 类加载时就创建实例，可能造成资源浪费
  - ❌ 如果实例很大且不常用，会占用内存
  - ❌ 无法实现延迟加载

  ```java
  /* 饿汉式 */
  public class EagerSingleton {
      // 类加载时就初始化实例
      private static final EagerSingleton INSTANCE = new EagerSingleton();
      
      // 私有构造函数，防止外部实例化
      private EagerSingleton() {
          System.out.println("EagerSingleton instance created");
      }
      
      // 提供全局访问点
      public static EagerSingleton getInstance() {
          return INSTANCE;
      }
      
      public void doSomething() {
          System.out.println("EagerSingleton is working");
      }
  }
  ```

- 懒汉式（Lazy Initialization）`

  **优点：**

  - ✅ 延迟加载，节省内存
  - ✅ 只有在需要时才创建实例

  **缺点：**

  - ❌ 同步方法版性能较差（每次获取都要同步）
  - ❌ 检查锁定实现较复杂

  ```java
  /* 懒汉式（双重检查） */
  public class DoubleCheckedSingleton {
      // 使用volatile保证可见性和禁止指令重排序
      private static volatile DoubleCheckedSingleton instance;
      
      private DoubleCheckedSingleton() {
          System.out.println("DoubleCheckedSingleton instance created");
      }
      
      public static DoubleCheckedSingleton getInstance() {
          if (instance == null) { // 第一次检查
              synchronized (DoubleCheckedSingleton.class) {
                  if (instance == null) { // 第二次检查
                      instance = new DoubleCheckedSingleton();
                  }
              }
          }
          return instance;
      }
      
      public void doSomething() {
          System.out.println("DoubleCheckedSingleton is working");
      }
  }
  ```

> 关于`单例模式`的`详解`，移步到`DesignPatter/01-单例模式.md`

##### 7.2 生产者/消费者模式

- 简单模式
  - 生产者`(Producer)`：负责生产数据并将其发送到队列，可以有多个生产者同时工作
  - 消费者`(Consumer)`：从队列中获取数据并进行处理，可以有多个消费者同时工作
  - 队列`(Queue)`：用于存储数据的缓冲区，生产者将数据放入队列，消费者从队列中获取数据
    - 包含属性
      - 容量限制：可满可空
      - 空/满状态标志
      - 元素数量
  - 数据`(Data)`：生产者生产的数据，消费者消费的数据
  - 同步机制：确保生产者和消费者在访问队列时的`线程安全`，避免数据竞争和不一致性
  
  ```java
  import java.util.LinkedList;
  import java.util.function.Consumer;
  import java.util.function.Supplier;
  
  public class FunctionalPC {
      private static final LinkedList<Integer> queue = new LinkedList<>();
      private static final int CAPACITY = 3;
      private static int count = 0;
      
      public static void main(String[] args) {
          // 生产者函数
          Supplier<Integer> producer = () -> {
              synchronized (queue) {
                  while (queue.size() == CAPACITY) {
                      try { queue.wait(); } catch (InterruptedException e) {}
                  }
                  int product = ++count;
                  queue.add(product);
                  System.out.println("生产: " + product + "，队列: " + queue.size());
                  queue.notifyAll();
                  return product;
              }
          };
          
          // 消费者函数
          Consumer<Integer> consumer = (product) -> {
              synchronized (queue) {
                  while (queue.isEmpty()) {
                      try { queue.wait(); } catch (InterruptedException e) {}
                  }
                  int consumed = queue.removeFirst();
                  System.out.println("消费: " + consumed + "，队列: " + queue.size());
                  queue.notifyAll();
              }
          };
          
          // 启动生产者线程
          new Thread(() -> {
              while (true) {
                  Integer product = producer.get();
                  try { Thread.sleep(300); } catch (InterruptedException e) {}
              }
          }).start();
          
          // 启动消费者线程
          new Thread(() -> {
              while (true) {
                  consumer.accept(null);
                  try { Thread.sleep(500); } catch (InterruptedException e) {}
              }
          }).start();
      }
  }
  ```
  
- 复杂模式：参考`DesignPatter/30-生产者消费者模式.md`

> 关于`生产者消费者模式`的`详解`，移步到`DesignPatter/30-生产者消费者模式.md`

#### 8.ThreadLocal类

`ThreadLocal`是 Java 中用于`创建线程局部变量`的类。`每个线程`都有自己`独立的变量副本`，`互不干扰`。以实现`线程同步处理`临界资源，`保证数据一致性`

- set(T value)：设置当前线程绑定的局部变量
- T get()：获取当前线程绑定的局部变量
- T remove()：移除当前线程绑定的局部变量

```java
public class TinyThreadLocalDemo {
    private static ThreadLocal<String> tl = new ThreadLocal<>();

    public static void main(String[] args) {
        new Thread(() -> {
            tl.set("线程A数据");
            System.out.println("A:get=" + tl.get());
            tl.remove();
            System.out.println("A:remove后=" + tl.get());
        }).start();

        new Thread(() -> {
            tl.set("线程B数据");
            System.out.println("B:get=" + tl.get());
            tl.remove();
            System.out.println("B:remove后=" + tl.get());
        }).start();
    }
}
```

#### 9.守护线程

`守护线程（Daemon Thread`）是 Java 中一种`特殊的线程类型`，

- 本质是为其他线程（通常是用户线程）提供服务
- 使用`setDaemon(true)`将线程定义为`守护线程`，使用`isDaemon()`判断是否为`守护线程`

- 伴随主线程而生，随主线程结束而消亡
- 使用场景
  - 垃圾回收
  - 定时任务：数据备份
  - 服务器监控

```java
public class DaemonDemo {
    public static void main(String[] args) throws InterruptedException {
        // 创建守护线程
        Thread daemon = new Thread(() -> {
            while (true) { // 无限循环，模拟持续运行
                System.out.println("守护线程运行中...");
                try { Thread.sleep(500); } 
                catch (InterruptedException e) {}
            }
        });
        
        daemon.setDaemon(true); // 标记为守护线程
        daemon.start();         // 启动
        
        // 主线程（用户线程）运行1秒后结束
        Thread.sleep(1000);
        System.out.println("主线程结束，守护线程将被强制终止");
    }
}
```

#### 10. 线程池

##### 10.1 什么是线程池

- 线程池是一种**线程管理机制**，预先创建一定数量的线程并放入 "池" 中统一管理。
- 任务执行时从池中获取线程，完成后线程返回池中等待下一个任务，避免频繁创建销毁线程。
- 核心是**复用线程资源**，降低性能开销。

##### 10.2 线程池的作用

- 降低资源消耗：减少线程创建 / 销毁的 CPU 和内存开销。
- 提高响应速度：任务到达时无需等待线程创建，直接使用空闲线程。
- 便于管理：统一控制线程数量、任务队列大小，防止资源耗尽。
- 附加功能：支持定时执行、定期执行、线程中断控制等。

##### 10.3 核心参数

- 核心线程数（corePoolSize）：线程池长期维持的线程数量
- 最大线程数（maximumPoolSize）：允许创建的最大线程数量
- 空闲线程存活时间（keepAliveTime）：非核心线程空闲超时时间
- 时间单位（unit）：keepAliveTime 的时间单位
- 工作队列（workQueue）：存放等待执行任务的阻塞队列
- 线程工厂（threadFactory）：用于创建线程的工厂
- 拒绝策略（handler）：任务满时的处理策略

##### 10.4 工作机制

- 当新任务提交时，若当前线程数 < 核心线程数，创建核心线程执行任务
- 若当前线程数 ≥ 核心线程数，将任务放入工作队列等待
- 若队列已满，且当前线程数 < 最大线程数，创建非核心线程执行任务
- 若队列已满且线程数已达最大线程数，触发拒绝策略

##### 10.5 常用线程池

 | 线程池名称                    | 描述                                        |
  | ----------------------------- | ------------------------------------------- |
  | FixedThreadPool               | 核心线程数与最大线程数相同                  |
  | SingleThreadExecutor          | 一个线程的线程池                            |
  | CachedThreadPool              | 核心线程为0，最大线程数为Integer. MAX_VALUE |
  | ScheduledThreadPool           | 指定核心线程数的定时线程池                  |
  | SingleThreadScheduledExecutor | 单例的定时线程池                            |
  | ForkJoinPool                  | 处理可分解的大任务，采用工作窃取算法        |

```java
// 1. FixedThreadPool - 固定线程数的CPU密集型任务
ExecutorService fixedPool = Executors.newFixedThreadPool(4);
fixedPool.submit(() -> System.out.println("FixedThreadPool task running on: " + Thread.currentThread().getName()));
fixedPool.shutdown();

// 2. SingleThreadExecutor - 需要顺序执行的任务
ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
IntStream.range(0, 3).forEach(i -> 
    singleThreadPool.submit(() -> System.out.println("Task " + i + " executed by SingleThreadPool")));
singleThreadPool.shutdown();

// 3. CachedThreadPool - 大量短生命周期异步任务
ExecutorService cachedPool = Executors.newCachedThreadPool();
IntStream.range(0, 10).forEach(i ->
    cachedPool.submit(() -> System.out.println("CachedThreadPool task: " + i)));
cachedPool.shutdown();

// 4. ScheduledThreadPool - 定时周期性任务
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(2);
scheduledPool.scheduleAtFixedRate(() -> 
    System.out.println("Scheduled task running at: " + new Date()), 1, 2, TimeUnit.SECONDS);
Thread.sleep(5000);
scheduledPool.shutdown();

// 5. SingleThreadScheduledExecutor - 单线程定时任务
ScheduledExecutorService singleScheduled = Executors.newSingleThreadScheduledExecutor();
singleScheduled.schedule(() -> 
    System.out.println("Single scheduled task executed after delay"), 1, TimeUnit.SECONDS);
Thread.sleep(2000);
singleScheduled.shutdown();

// 6. ForkJoinPool - 分治递归任务
ForkJoinPool forkJoinPool = new ForkJoinPool();
forkJoinPool.submit(() -> {
    IntStream.range(0, 4).parallel().forEach(i -> 
        System.out.println("ForkJoin task " + i + " executed by " + Thread.currentThread().getName()));
}).join();
forkJoinPool.shutdown();
```









