# Java集合

![集合](images\集合.png)

#### 1. 集合概述

##### 1.1 集合和数组

`集合和数组`都用于存放`一组数据`

###### 1.1.2 数组特点

- **长度不变**：一旦创建，长度`固定`
  - **元素类型**：可以存储`任意类型`（基本类型和引用类型）


```java
public class ArrayDemo {
    public static void main(String[] args) {
        // 基本类型数组
        int[] nums = {1, 2, 3, 4, 5};
        
        // 引用类型数组
        String[] names = {"张三", "李四", "王五"};
        
        System.out.println("数组长度：" + nums.length);  // 5
        // nums.length = 10;  // 编译错误，长度不可变
    }
}
```

###### 1.1.3 集合特点

- **长度可变**：可以动态增加或删除元素
- **元素类型**：只能存储引用类型（基本类型需要包装类）

```java
import java.util.ArrayList;
import java.util.List;

public class CollectionDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        
        // 动态添加元素
        list.add("张三");
        list.add("李四");
        System.out.println("集合大小：" + list.size());  // 2
        
        // 动态删除元素
        list.remove("张三");
        System.out.println("集合大小：" + list.size());  // 1
        
        // 只能存储引用类型
        List<Integer> nums = new ArrayList<>();  // 使用包装类
        nums.add(10);  // 自动装箱
    }
}
```

#### 2. Collection接口

##### 2.1 概述

- Collection是Java集合框架的根接口
- 定义了所有集合的通用方法
- 有两个主要子接口：List和Set

##### 2.2 Collection通用方法

```java
import java.util.*;

public class CollectionMethodDemo {
    public static void main(String[] args) {
        Collection<String> col = new ArrayList<>();
        Collection<String> col2 = new ArrayList<>();
        
        // 大小
        int size = col.size();
        System.out.println("集合大小：" + size);
        
        // 添加元素
        boolean added = col.add("Java");
        col.add("Python");
        col.add("C++");
        
        // 添加其他集合
        col2.add("JavaScript");
        col2.add("Go");
        boolean addedAll = col.addAll(col2);
        
        // 删除元素
        boolean removed = col.remove("Python");
        
        // 删除其他集合中的元素
        boolean removedAll = col.removeAll(col2);
        
        // 包含判断
        boolean contains = col.contains("Java");
        
        // 包含其他集合
        boolean containsAll = col.containsAll(col2);
        
        // 判空
        boolean isEmpty = col.isEmpty();
        
        // 清空
        col.clear();
        
        // forEach循环
        col.add("Java");
        col.add("Python");
        col.forEach(item -> System.out.println(item));
    }
}
```

#### 3. List接口

`List`是`Collection`的`子接口`，数据`有序`且可`重复`

- **有序**：元素有下标索引
- **可重复**：允许存储相同的元素

##### 3.2 List的循环方式

```java
import java.util.*;

public class ListLoopDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Java");
        list.add("Python");
        list.add("C++");
        
        // 1. 下标循环
        System.out.println("下标循环：");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(i + ": " + list.get(i));
        }
        
        // 2. 迭代器循环
        System.out.println("迭代器循环：");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        
        // 3. 增强for循环
        System.out.println("增强for循环：");
        for (String item : list) {
            System.out.println(item);
        }
        
        // 4. forEach方法
        System.out.println("forEach方法：");
        list.forEach(item -> System.out.println(item));
        // 或使用方法引用
        list.forEach(System.out::println);
    }
}
```

##### 3.3 ArrayList实现类

###### 3.3.1 特点

- 基于数组存放数据
- 查询快，增删慢
- 线程不安全
- 内存地址连续

```java
import java.util.ArrayList;
import java.util.List;

public class ArrayListDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        
        // 添加元素
        list.add("苹果");
        list.add("香蕉");
        list.add("橘子");
        list.add("苹果");  // 可重复
        
        // 根据索引获取元素
        String fruit = list.get(0);
        System.out.println("第一个元素：" + fruit);
        
        // 根据索引修改元素
        list.set(1, "葡萄");
        
        // 根据索引插入元素
        list.add(1, "西瓜");
        
        // 根据索引删除元素
        String removed = list.remove(2);
        
        // 遍历
        for (int i = 0; i < list.size(); i++) {
            System.out.println(i + ": " + list.get(i));
        }
    }
}
```

##### 3.4 LinkedList实现类

###### 3.4.1 特点

- 基于双向链表存放数据
- 增删快，查询慢
- 线程不安全
- 内存地址不连续

```java
import java.util.LinkedList;

public class LinkedListDemo {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        
        // 添加元素
        list.add("第一个");
        list.add("第二个");
        list.add("第三个");
        
        // 链表特有方法
        list.addFirst("头部元素");  // 在头部添加
        list.addLast("尾部元素");   // 在尾部添加
        
        // 获取头尾元素
        String first = list.getFirst();
        String last = list.getLast();
        
        // 删除头尾元素
        String removedFirst = list.removeFirst();
        String removedLast = list.removeLast();
        
        System.out.println("当前列表：" + list);
    }
}
```

#### 4. Set接口

##### 4.1 概述

- Set是Collection的子接口
- **特点**：数据无序且不可重复
- **无序**：元素没有下标索引
- **不可重复**：不允许存储相同的元素
- Set没有任何新增方法，所有方法都继承于Collection

##### 4.2 不可重复性判断依据

```java
// 判断两个元素是否重复的条件
set1 == set2 || set1.equals(set2)
```

##### 4.3 HashSet实现类

###### 4.3.1 特点

- 基于哈希码散列存放
- 无序存储
- 查询效率高

```java
import java.util.HashSet;
import java.util.Set;

public class HashSetDemo {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        
        // 添加元素
        set.add("Java");
        set.add("Python");
        set.add("C++");
        set.add("Java");  // 重复元素，不会添加
        
        System.out.println("集合大小：" + set.size());  // 3
        System.out.println("集合内容：" + set);
        
        // 判断是否包含
        boolean contains = set.contains("Java");
        System.out.println("包含Java：" + contains);
        
        // 遍历（无序）
        for (String item : set) {
            System.out.println(item);
        }
    }
}
```

##### 4.4 TreeSet实现类

基于`红黑二叉树`存放，会`自动排序`

- 元素必须实现Comparable接口或提供Comparator

```java
import java.util.TreeSet;
import java.util.Set;

public class TreeSetDemo {
    public static void main(String[] args) {
        Set<Integer> set = new TreeSet<>();
        
        // 添加元素
        set.add(30);
        set.add(10);
        set.add(50);
        set.add(20);
        set.add(10);  // 重复元素，不会添加
        
        System.out.println("集合大小：" + set.size());  // 4
        System.out.println("集合内容：" + set);  // [10, 20, 30, 50] 自动排序
        
        // 自定义对象排序
        Set<String> stringSet = new TreeSet<>();
        stringSet.add("banana");
        stringSet.add("apple");
        stringSet.add("cherry");
        
        System.out.println("字符串集合：" + stringSet);  // [apple, banana, cherry]
    }
}
```

#### 5. Iterator迭代器

`Iterator`是用来`遍历Collection`集合的`统一接口`

- 提供了`统一`的`遍历方式`
- 支持在`遍历过程`中`安全删除`元素

```java
import java.util.*;

public class IteratorDemo {
    public static void main(String[] args) {
        Collection<String> col = new ArrayList<>();
        col.add("Java");
        col.add("Python");
        col.add("C++");
        
        // 获取迭代器
        Iterator<String> iterator = col.iterator();
        
        // 遍历集合
        while (iterator.hasNext()) {
            String item = iterator.next();
            System.out.println(item);
            
            // 安全删除
            if ("Python".equals(item)) {
                iterator.remove();
            }
        }
        
        System.out.println("删除后的集合：" + col);
    }
}
```

#### 6. Map接口

`Map`是`键值对映射接口`，存储`key-value`对

- key不可重复，value可以重复

##### 6.1 HashMap实现类

`HashMap`基于`哈希码散列` `无序`存放

- 允许null键和null值

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapDemo {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        
        // 添加键值对
        map.put("张三", 85);
        map.put("李四", 92);
        map.put("王五", 78);
        map.put("张三", 90);  // 覆盖原值
        
        // 获取值
        Integer score = map.get("张三");
        System.out.println("张三的成绩：" + score);
        
        // 判断是否包含键
        boolean hasKey = map.containsKey("李四");
        
        // 判断是否包含值
        boolean hasValue = map.containsValue(92);
        
        // 删除
        Integer removed = map.remove("王五");
        
        // 遍历键
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
        
        // 遍历值
        for (Integer value : map.values()) {
            System.out.println("成绩：" + value);
        }
        
        // 遍历键值对
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 使用forEach方法遍历
        System.out.println("使用forEach遍历：");
        map.forEach((key, value) -> {
            System.out.println(key + ": " + value);
        });
    }
}
```

##### 6.2 TreeMap实现类

`TreeMap`基于`红黑二叉树` `自动排序`存放

- 不允许null键

```java
import java.util.TreeMap;
import java.util.Map;

public class TreeMapDemo {
    public static void main(String[] args) {
        Map<String, Integer> map = new TreeMap<>();
        
        // 添加键值对
        map.put("banana", 3);
        map.put("apple", 5);
        map.put("cherry", 2);
        
        // 按键排序输出
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        // 输出：apple: 5, banana: 3, cherry: 2
    }
}
```

#### 7. Collections工具类

`Collections`是`集合的工具类`，提供了`大量静态方法`来`操作集合`

```java
import java.util.*;

public class CollectionsDemo {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(3);
        list.add(1);
        list.add(4);
        list.add(2);
        
        // 排序
        Collections.sort(list);
        System.out.println("排序后：" + list);
        
        // 反转
        Collections.reverse(list);
        System.out.println("反转后：" + list);
        
        // 打乱
        Collections.shuffle(list);
        System.out.println("打乱后：" + list);
        
        // 最大值和最小值
        Integer max = Collections.max(list);
        Integer min = Collections.min(list);
        System.out.println("最大值：" + max + "，最小值：" + min);
        
        // 二分查找（需要先排序）
        Collections.sort(list);
        int index = Collections.binarySearch(list, 3);
        System.out.println("元素3的索引：" + index);
        
        // 填充
        Collections.fill(list, 0);
        System.out.println("填充后：" + list);
        
        // 重新添加数据用于其他方法演示
        list.clear();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(2);
        list.add(4);
        
        // 统计元素出现次数
        int frequency = Collections.frequency(list, 2);
        System.out.println("元素2出现次数：" + frequency);
        
        // 右移（循环移位）
        Collections.rotate(list, 2);
        System.out.println("右移2位后：" + list);
        
        // 交换元素位置
        Collections.swap(list, 0, 2);
        System.out.println("交换位置后：" + list);
        
        // 替换所有指定元素
        Collections.replaceAll(list, 2, 9);
        System.out.println("替换元素2为9：" + list);
    }
}
```

#### 8. Comparator和Comparable

`Comparator`和`Comparable`用于`自定义对象`的`比较`和`排序`

- **Comparable**：内部比较器，在`类内部`实现
- **Comparator**：外部比较器，`独立`的`比较器`

##### 8.2 Comparable接口

```java
class Student implements Comparable<Student> {
    private String name;
    private int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    @Override
    public int compareTo(Student other) {
        // 按成绩升序排列
        return Integer.compare(this.score, other.score);
    }
    
    @Override
    public String toString() {
        return name + "(" + score + ")";
    }
    
    // getter方法
    public String getName() { return name; }
    public int getScore() { return score; }
}

public class ComparableDemo {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("张三", 85));
        students.add(new Student("李四", 92));
        students.add(new Student("王五", 78));
        
        // 使用Comparable排序
        Collections.sort(students);
        System.out.println("按成绩排序：" + students);
        
        // TreeSet自动排序
        Set<Student> studentSet = new TreeSet<>();
        studentSet.add(new Student("赵六", 88));
        studentSet.add(new Student("钱七", 95));
        System.out.println("TreeSet排序：" + studentSet);
    }
}
```

##### 8.3 Comparator接口

```java
import java.util.*;

public class ComparatorDemo {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("张三", 85));
        students.add(new Student("李四", 92));
        students.add(new Student("王五", 78));
        
        // 使用Comparator按成绩降序排列
        Comparator<Student> scoreComparator = new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                return Integer.compare(s2.getScore(), s1.getScore());
            }
        };
        
        Collections.sort(students, scoreComparator);
        System.out.println("按成绩降序：" + students);
        
        // 使用Lambda表达式
        students.sort((s1, s2) -> s1.getName().compareTo(s2.getName()));
        System.out.println("按姓名排序：" + students);
        
        // 使用方法引用
        students.sort(Comparator.comparing(Student::getScore));
        System.out.println("按成绩升序：" + students);
        
        // 多条件排序
        students.sort(Comparator.comparing(Student::getScore)
                               .thenComparing(Student::getName));
        System.out.println("先按成绩后按姓名：" + students);
        
        // 使用内部类实现Comparator
        class NameComparator implements Comparator<Student> {
            @Override
            public int compare(Student s1, Student s2) {
                return s1.getName().compareTo(s2.getName());
            }
        }
        
        students.sort(new NameComparator());
        System.out.println("使用内部类排序：" + students);
        
        // 使用匿名内部类
        students.sort(new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                return Integer.compare(s2.getScore(), s1.getScore());
            }
        });
        System.out.println("使用匿名内部类排序：" + students);
    }
}
```

> **Tips**：
> - 当类需要有默认排序规则时，实现Comparable接口
> - 当需要多种排序方式时，使用Comparator接口
> - Comparator更灵活，推荐使用Lambda表达式简化代码

#### 9. 比较器实现方式总结

##### 9.1 Comparable vs Comparator

| 特性 | Comparable | Comparator |
|------|------------|------------|
| 使用场景 | 排序规则固定 | 自定义排序规则 |
| 实现位置 | 类内部实现 | 外部独立实现 |
| 灵活性 | 较低 | 较高 |
| 方法名 | compareTo() | compare() |

##### 9.2 Comparator的多种实现方式

```java
// 1. 实现类方式
class ScoreComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return Integer.compare(s1.getScore(), s2.getScore());
    }
}

// 2. 内部类方式
class Demo {
    class NameComparator implements Comparator<Student> {
        @Override
        public int compare(Student s1, Student s2) {
            return s1.getName().compareTo(s2.getName());
        }
    }
}

// 3. 匿名内部类方式
Comparator<Student> comparator = new Comparator<Student>() {
    @Override
    public int compare(Student s1, Student s2) {
        return Integer.compare(s1.getScore(), s2.getScore());
    }
};

// 4. Lambda表达式方式
Comparator<Student> lambdaComparator = (s1, s2) -> 
    Integer.compare(s1.getScore(), s2.getScore());

// 5. 方法引用方式
Comparator<Student> methodRefComparator = 
    Comparator.comparing(Student::getScore);
```

> **推荐使用顺序**：方法引用 > Lambda表达式 > 匿名内部类 > 内部类 > 实现类

#### 10. 线程安全

在`多线程环境`下，集合的`线程安全性`是一个`重要考虑因素`。`Java集合框架`中的`大部分集合类`都是`**线程不安全**`的，这意味着在`多线程并发`访问时可能会出现`数据不一致`的问题。

##### 10.1 线程不安全集合

- **List**：ArrayList、LinkedList
- **Set**：HashSet、TreeSet
- **Map**：HashMap、TreeMap

**特点**：
- 处理速度`快`
- 线程安全需要`单独处理`
- 在`单线程环境`下`性能最佳`

```java
import java.util.*;
import java.util.concurrent.*;

public class ThreadUnsafeDemo {
    public static void main(String[] args) throws InterruptedException {
        List<Integer> list = new ArrayList<>();
        
        // 创建多个线程同时操作集合
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        for (int i = 0; i < 10; i++) {
            final int threadNum = i;
            executor.submit(() -> {
                for (int j = 0; j < 1000; j++) {
                    list.add(threadNum * 1000 + j);
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.SECONDS);
        
        // 可能出现数据丢失或异常
        System.out.println("期望大小：10000，实际大小：" + list.size());
    }
}
```

##### 10.2 线程安全集合

###### 10.2.1 Collections同步包装器

`Collections工具类`提供了将`线程不安全`集合转换为`线程安全集合`的方法：

```java
import java.util.*;

public class SynchronizedCollectionDemo {
    public static void main(String[] args) {
        // 创建线程安全的List
        List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
        
        // 创建线程安全的Set
        Set<String> synchronizedSet = Collections.synchronizedSet(new HashSet<>());
        
        // 创建线程安全的Map
        Map<String, Integer> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
        
        // 使用示例
        synchronizedList.add("Java");
        synchronizedSet.add("Python");
        synchronizedMap.put("C++", 1);
        
        // 注意：遍历时仍需要手动同步
        synchronized (synchronizedList) {
            for (String item : synchronizedList) {
                System.out.println(item);
            }
        }
    }
}
```

###### 10.2.2 传统线程安全集合

- **Vector**：线程安全的List实现类（栈结构）
- **Hashtable**：线程安全的Map实现类

```java
import java.util.*;

public class LegacyThreadSafeDemo {
    public static void main(String[] args) {
        // Vector - 线程安全的List
        Vector<String> vector = new Vector<>();
        vector.add("元素1");
        vector.add("元素2");
        
        // Hashtable - 线程安全的Map
        Hashtable<String, Integer> hashtable = new Hashtable<>();
        hashtable.put("key1", 100);
        hashtable.put("key2", 200);
        
        System.out.println("Vector: " + vector);
        System.out.println("Hashtable: " + hashtable);
    }
}
```

##### 10.3 性能对比

| 集合类型 | 线程安全 | 性能 | 推荐场景 |
|----------|----------|------|----------|
| ArrayList | 否 | 高 | 单线程环境 |
| Vector | 是 | 中 | 多线程环境（不推荐） |
| Collections.synchronizedList() | 是 | 中 | 需要线程安全的List |
| ConcurrentHashMap | 是 | 高 | 高并发Map操作 |

#### 11. 集合容量

`集合容量`是指`集合内部数据结构`能够`存储元素`的`数量`

##### 11.1 ArrayList容量机制

###### 111.1 默认容量

```java
import java.util.*;

public class ArrayListCapacityDemo {
    public static void main(String[] args) {
        // 默认初始容量：10
        List<String> list = new ArrayList<>();
        System.out.println("默认初始容量：10");
        
        // 添加元素测试
        for (int i = 0; i < 15; i++) {
            list.add("元素" + i);
            System.out.println("添加第" + (i + 1) + "个元素，当前大小：" + list.size());
        }
    }
}
```

###### 11.1.2 自定义初始容量

```java
import java.util.*;

public class CustomCapacityDemo {
    public static void main(String[] args) {
        // 自定义初始容量：100
        List<String> list = new ArrayList<>(100);
        System.out.println("自定义初始容量：100");
        
        // 当知道大概需要存储多少元素时，建议指定初始容量
        // 这样可以避免频繁扩容，提高性能
        for (int i = 0; i < 50; i++) {
            list.add("数据" + i);
        }
        
        System.out.println("添加50个元素后，列表大小：" + list.size());
    }
}
```

###### 11.1.3 扩容机制

- **扩容公式**：新容量 = 当前容量 × 1.5 + 1
- **扩容时机**：当添加元素时发现容量不足
- **扩容成本**：需要创建新数组并复制所有元素

```java
import java.util.*;
import java.lang.reflect.Field;

public class ArrayListGrowthDemo {
    public static void main(String[] args) throws Exception {
        List<Integer> list = new ArrayList<>();
        
        // 通过反射获取ArrayList的内部数组容量
        Field elementDataField = ArrayList.class.getDeclaredField("elementData");
        elementDataField.setAccessible(true);
        
        System.out.println("ArrayList扩容过程演示：");
        
        for (int i = 0; i < 20; i++) {
            list.add(i);
            Object[] elementData = (Object[]) elementDataField.get(list);
            System.out.println("元素数量：" + list.size() + 
                             "，内部数组容量：" + elementData.length);
        }
    }
}
```

##### 11.2 HashSet容量机制

###### 11.2.1 默认容量

```java
import java.util.*;

public class HashSetCapacityDemo {
    public static void main(String[] args) {
        // 默认初始容量：16
        Set<String> set = new HashSet<>();
        System.out.println("HashSet默认初始容量：16");
        
        // 添加元素测试
        for (int i = 0; i < 20; i++) {
            set.add("元素" + i);
        }
        
        System.out.println("添加20个元素后，集合大小：" + set.size());
    }
}
```

###### 11.2.2 扩容机制

- **扩容公式**：新容量 = 当前容量 × 2
- **负载因子**：默认0.75，当元素数量达到容量×负载因子时触发扩容
- **扩容时机**：当 size > capacity × loadFactor 时

```java
import java.util.*;

public class HashSetGrowthDemo {
    public static void main(String[] args) {
        // 自定义初始容量和负载因子
        Set<Integer> set = new HashSet<>(8, 0.75f);
        
        System.out.println("HashSet扩容演示：");
        System.out.println("初始容量：8，负载因子：0.75");
        System.out.println("扩容阈值：8 × 0.75 = 6");
        
        for (int i = 0; i < 10; i++) {
            set.add(i);
            System.out.println("添加元素" + i + "，当前大小：" + set.size());
            
            if (i == 5) {
                System.out.println(">>> 达到扩容阈值，容量将扩展为：8 × 2 = 16");
            }
        }
    }
}
```

| 集合类型 | 默认容量 | 扩容机制 | 建议 |
|----------|----------|----------|------|
| ArrayList | 10 | 容量 × 1.5 + 1 | 预估元素数量，设置合适初始容量 |
| HashSet | 16 | 容量 × 2 | 根据预期元素数量设置初始容量 |
| HashMap | 16 | 容量 × 2 | 考虑负载因子，预设合适容量 |
| LinkedList | 无固定容量 | 动态节点 | 无需考虑容量问题 |

> **性能提示**：
> - 当能预估集合大小时，建议设置合适的初始容量
> - 避免频繁扩容操作，减少内存分配和数据复制开销
> - 对于大量数据操作，合理的容量设置能显著提升性能
